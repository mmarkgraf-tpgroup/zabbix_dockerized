{
    "zabbix_export": {
        "version": "5.2",
        "date": "2022-07-19T10:32:44Z",
        "media_types": [
            {
                "name": "Brevis.one",
                "type": "WEBHOOK",
                "parameters": [
                    {
                        "name": "endpoint",
                        "value": "<PLACE HTTP API URL>"
                    },
                    {
                        "name": "flash",
                        "value": "false"
                    },
                    {
                        "name": "password",
                        "value": "<PLACE PASSWORD>"
                    },
                    {
                        "name": "ring",
                        "value": "false"
                    },
                    {
                        "name": "send_to",
                        "value": "{ALERT.SENDTO}"
                    },
                    {
                        "name": "telauto",
                        "value": "true"
                    },
                    {
                        "name": "text",
                        "value": "{ALERT.MESSAGE}"
                    },
                    {
                        "name": "username",
                        "value": "<PLACE USERNAME>"
                    }
                ],
                "status": "DISABLED",
                "script": "var BrevisOne = {\n    params: [],\n\n    addParam: function (name, value) {\n        BrevisOne.params.push(name + '=' + encodeURIComponent(value));\n    },\n\n    setProxy: function (HTTPProxy) {\n        BrevisOne.HTTPProxy = HTTPProxy;\n    },\n\n    setPayload: function (params) {\n        var parts = params.send_to.split(':'),\n            defaultValues = {\n                ring: 'true',\n                flash: 'true',\n                telauto: 'false'\n            };\n\n        BrevisOne.addParam('username', params.username);\n        BrevisOne.addParam('password', params.password);\n        BrevisOne.addParam('text', params.text);\n\n        if (parts.length > 1) {\n            BrevisOne.addParam('mode', parts[0]);\n            BrevisOne.addParam('to', parts[1]);\n        }\n        else {\n            BrevisOne.addParam('to', parts[0]);\n        }\n\n        Object.keys(defaultValues)\n            .forEach(function (key) {\n                if (params[key] && params[key].trim() && params[key].toLowerCase() === defaultValues[key]) {\n                    BrevisOne.addParam(key, defaultValues[key]);\n                }\n            });\n    },\n\n    request: function () {\n        var response,\n            request = new CurlHttpRequest(),\n            data = '?' + BrevisOne.params.join('&');\n\n        request.AddHeader('Content-Type: multipart/form-data');\n\n        if (typeof BrevisOne.HTTPProxy !== 'undefined' && BrevisOne.HTTPProxy !== '') {\n            request.SetProxy(BrevisOne.HTTPProxy);\n        }\n\n        Zabbix.Log(4, '[ BrevisOne Webhook ] Sending request.');\n\n        response = request.Post(params.endpoint + data);\n\n        Zabbix.Log(4, '[ BrevisOne Webhook ] Received response with status code ' +\n            request.Status() + '\\n' + response);\n\n        if (request.Status() < 200 || request.Status() >= 300) {\n            var message = 'Request failed with status code ' + request.Status();\n\n            if (response) {\n                message += ': ' + response;\n            }\n\n            throw message + '. Check debug log for more information.';\n        }\n    }\n};\n\ntry {\n    var params = JSON.parse(value);\n\n    ['endpoint', 'password', 'username', 'text', 'send_to'].forEach(function (field) {\n        if (typeof params !== 'object' || typeof params[field] === 'undefined'\n                || !params[field].trim()) {\n            throw 'Required parameter is not set: \"' + field + '\".';\n        }\n    });\n\n    if (params.send_to === '{ALERT.SENDTO}') {\n        throw 'Required parameter is not set: \"send_to\".';\n    }\n\n    BrevisOne.setProxy(params.HTTPProxy);\n    BrevisOne.setPayload(params);\n    BrevisOne.request();\n\n    return 'OK';\n}\ncatch (error) {\n    Zabbix.Log(3, '[ BrevisOne Webhook ] ERROR: ' + error);\n    throw 'Sending failed: ' + error;\n}",
                "message_templates": [
                    {
                        "event_source": "TRIGGERS",
                        "operation_mode": "PROBLEM",
                        "subject": "[{EVENT.STATUS}] {EVENT.NAME}",
                        "message": "[{EVENT.STATUS}] {EVENT.NAME}\nStarted at {EVENT.TIME} on {EVENT.DATE}\nHost: {HOST.NAME}\nSeverity: {EVENT.SEVERITY}\nOperational data: {EVENT.OPDATA}\nEvent info: {$ZABBIX.URL}/tr_events.php?triggerid={TRIGGER.ID}&eventid={EVENT.ID}"
                    },
                    {
                        "event_source": "TRIGGERS",
                        "operation_mode": "RECOVERY",
                        "subject": "Resolved in {EVENT.DURATION}: {EVENT.NAME}",
                        "message": "[{EVENT.STATUS}] {EVENT.NAME}\nResolved in {EVENT.DURATION} at {EVENT.RECOVERY.TIME} on {EVENT.RECOVERY.DATE}\nHost: {HOST.NAME}\nSeverity: {EVENT.SEVERITY}\nEvent info: {$ZABBIX.URL}/tr_events.php?triggerid={TRIGGER.ID}&eventid={EVENT.ID}"
                    },
                    {
                        "event_source": "TRIGGERS",
                        "operation_mode": "UPDATE",
                        "subject": "[{EVENT.STATUS}] {EVENT.NAME}",
                        "message": "[{EVENT.STATUS}] {EVENT.NAME}\n\n{USER.FULLNAME} {EVENT.UPDATE.ACTION} problem at {EVENT.UPDATE.DATE} {EVENT.UPDATE.TIME}.\n{EVENT.UPDATE.MESSAGE}"
                    },
                    {
                        "event_source": "DISCOVERY",
                        "operation_mode": "PROBLEM",
                        "subject": "Discovery: {DISCOVERY.DEVICE.STATUS} {DISCOVERY.DEVICE.IPADDRESS}",
                        "message": "Discovery: {DISCOVERY.DEVICE.STATUS} {DISCOVERY.DEVICE.IPADDRESS}\nDiscovery rule: {DISCOVERY.RULE.NAME}\n\nDevice IP: {DISCOVERY.DEVICE.IPADDRESS}\nDevice DNS: {DISCOVERY.DEVICE.DNS}\nDevice status: {DISCOVERY.DEVICE.STATUS}\nDevice uptime: {DISCOVERY.DEVICE.UPTIME}\n\nDevice service name: {DISCOVERY.SERVICE.NAME}\nDevice service port: {DISCOVERY.SERVICE.PORT}\nDevice service status: {DISCOVERY.SERVICE.STATUS}\nDevice service uptime: {DISCOVERY.SERVICE.UPTIME}"
                    },
                    {
                        "event_source": "AUTOREGISTRATION",
                        "operation_mode": "PROBLEM",
                        "subject": "Autoregistration: {HOST.HOST}",
                        "message": "Autoregistration: {HOST.HOST}\nHost IP: {HOST.IP}\nAgent port: {HOST.PORT}"
                    }
                ]
            },
            {
                "name": "Discord",
                "type": "WEBHOOK",
                "parameters": {
                    "3": {
                        "name": "alert_message",
                        "value": "{ALERT.MESSAGE}"
                    },
                    "4": {
                        "name": "alert_subject",
                        "value": "{ALERT.SUBJECT}"
                    },
                    "1": {
                        "name": "discord_endpoint",
                        "value": "{ALERT.SENDTO}"
                    },
                    "12": {
                        "name": "event_date",
                        "value": "{EVENT.DATE}"
                    },
                    "6": {
                        "name": "event_id",
                        "value": "{EVENT.ID}"
                    },
                    "5": {
                        "name": "event_name",
                        "value": "{EVENT.NAME}"
                    },
                    "8": {
                        "name": "event_nseverity",
                        "value": "{EVENT.NSEVERITY}"
                    },
                    "9": {
                        "name": "event_opdata",
                        "value": "{EVENT.OPDATA}"
                    },
                    "13": {
                        "name": "event_recovery_date",
                        "value": "{EVENT.RECOVERY.DATE}"
                    },
                    "14": {
                        "name": "event_recovery_time",
                        "value": "{EVENT.RECOVERY.TIME}"
                    },
                    "7": {
                        "name": "event_severity",
                        "value": "{EVENT.SEVERITY}"
                    },
                    "26": {
                        "name": "event_source",
                        "value": "{EVENT.SOURCE}"
                    },
                    "10": {
                        "name": "event_tags",
                        "value": "{EVENT.TAGS}"
                    },
                    "11": {
                        "name": "event_time",
                        "value": "{EVENT.TIME}"
                    },
                    "17": {
                        "name": "event_update_action",
                        "value": "{EVENT.UPDATE.ACTION}"
                    },
                    "15": {
                        "name": "event_update_date",
                        "value": "{EVENT.UPDATE.DATE}"
                    },
                    "18": {
                        "name": "event_update_message",
                        "value": "{EVENT.UPDATE.MESSAGE}"
                    },
                    "19": {
                        "name": "event_update_status",
                        "value": "{EVENT.UPDATE.STATUS}"
                    },
                    "16": {
                        "name": "event_update_time",
                        "value": "{EVENT.UPDATE.TIME}"
                    },
                    "20": {
                        "name": "event_update_user",
                        "value": "{USER.FULLNAME}"
                    },
                    "21": {
                        "name": "event_value",
                        "value": "{EVENT.VALUE}"
                    },
                    "22": {
                        "name": "host_ip",
                        "value": "{HOST.IP}"
                    },
                    "23": {
                        "name": "host_name",
                        "value": "{HOST.NAME}"
                    },
                    "24": {
                        "name": "trigger_description",
                        "value": "{TRIGGER.DESCRIPTION}"
                    },
                    "25": {
                        "name": "trigger_id",
                        "value": "{TRIGGER.ID}"
                    },
                    "2": {
                        "name": "use_default_message",
                        "value": "false"
                    },
                    "0": {
                        "name": "zabbix_url",
                        "value": "{$ZABBIX.URL}"
                    }
                },
                "status": "DISABLED",
                "script": "var SEVERITY_COLORS = [\n    '#97AAB3', // Not classified.\n    '#7499FF', // Information.\n    '#FFC859', // Warning.\n    '#FFA059', // Average.\n    '#E97659', // High.\n    '#E45959', // Disaster.\n    '#009900'  // Resolved.\n];\n\nfunction stringTruncate(str, len) {\n    return str.length > len ? str.substring(0, len - 3) + '...' : str;\n}\n\ntry {\n    Zabbix.Log(4, '[ Discord Webhook ] Executed with params: ' + value);\n\n    var params = JSON.parse(value);\n\n    if (!params.discord_endpoint) {\n        throw 'Cannot get discord_endpoint';\n    }\n    else {\n        params.discord_endpoint = params.discord_endpoint.replace('/api/', '/api/v7/') + '?wait=True';\n    }\n\n    params.zabbix_url = (params.zabbix_url.endsWith('/'))\n        ? params.zabbix_url.slice(0, -1) : params.zabbix_url;\n\n    if ([0, 1, 2, 3].indexOf(parseInt(params.event_source)) === -1) {\n        throw 'Incorrect \"event_source\" parameter given: \"' + params.event_source + '\".\\nMust be 0-3.';\n    }\n\n    // Set params to true for non trigger-based events.\n    if (params.event_source !== '0') {\n        params.use_default_message = 'true';\n        params.event_nseverity = '0';\n    }\n\n    // Check {EVENT.VALUE} for trigger-based and internal events.\n    if (params.event_value !== '0' && params.event_value !== '1'\n        && (params.event_source === '0' || params.event_source === '3')) {\n        throw 'Incorrect \"event_value\" parameter given: \"' + params.event_value + '\".\\nMust be 0 or 1.';\n    }\n\n    // Check {EVENT.UPDATE.STATUS} only for trigger-based events.\n    if (params.event_update_status !== '0' && params.event_update_status !== '1' && params.event_source === '0') {\n        throw 'Incorrect \"event_update_status\" parameter given: \"' + params.event_update_status + '\".\\nMust be 0 or 1.';\n    }\n\n    if (params.event_value == 0) {\n        params.event_nseverity = '6';\n    }\n\n    if (!SEVERITY_COLORS[params.event_nseverity]) {\n        throw 'Incorrect \"event_nseverity\" parameter given: ' + params.event_nseverity + '\\nMust be 0-5.';\n    }\n\n    var color = parseInt(SEVERITY_COLORS[params.event_nseverity].replace('#', ''), 16),\n        fields = [],\n        body = {\n            embeds: [\n                {\n                    color: color || 0,\n                    url: (params.event_source === '0')\n                        ? params.zabbix_url + '/tr_events.php?triggerid=' + params.trigger_id +\n                            '&eventid=' + params.event_id\n                        : params.zabbix_url\n                }\n            ]\n        };\n\n    // Default message from {ALERT.MESSAGE}.\n    if (params.use_default_message.toLowerCase() == 'true') {\n        body.embeds[0].title = stringTruncate(params.alert_subject, 256);\n        body.embeds[0].description = stringTruncate(params.alert_message, 2048);\n    }\n    else {\n        fields.push(\n            {\n                name: 'Host',\n                value: params.host_name + ' [' + params.host_ip + ']'\n            }\n        );\n\n        // Resolved message.\n        if (params.event_value == 0 && params.event_update_status == 0) {\n            body.embeds[0].title = stringTruncate('OK: ' + params.event_name, 256);\n            fields.push(\n                {\n                    name: 'Recovery time',\n                    value: params.event_recovery_time + ' ' + params.event_recovery_date,\n                    inline: 'True'\n                }\n            );\n        }\n\n        // Problem message.\n        else if (params.event_value == 1 && params.event_update_status == 0) {\n            body.embeds[0].title = stringTruncate('PROBLEM: ' + params.event_name, 256);\n            fields.push(\n                {\n                    name: 'Event time',\n                    value: params.event_time + ' ' + params.event_date,\n                    inline: 'True'\n                }\n            );\n        }\n\n        // Update message.\n        else if (params.event_update_status == 1) {\n            body.embeds[0].title = stringTruncate('UPDATE: ' + params.event_name, 256);\n            body.embeds[0].description = params.event_update_user + ' ' + params.event_update_action + '.';\n\n            if (params.event_update_message) {\n                body.embeds[0].description += ' Comment:\\n>>> ' + params.event_update_message;\n            }\n\n            body.embeds[0].description = stringTruncate(body.embeds[0].description, 2048);\n\n            fields.push(\n                {\n                    name: 'Event update time',\n                    value: params.event_update_time + ' ' + params.event_update_date,\n                    inline: 'True'\n                }\n            );\n        }\n\n        fields.push(\n            {\n                name: 'Severity',\n                value: params.event_severity,\n                inline: 'True'\n            }\n        );\n\n        if (params.event_opdata) {\n            fields.push(\n                {\n                    name: 'Operational data',\n                    value: stringTruncate(params.event_opdata, 1024),\n                    inline: 'True'\n                }\n            );\n        }\n\n        if (params.event_value == 1 && params.event_update_status == 0 && params.trigger_description) {\n            fields.push(\n                {\n                    name: 'Trigger description',\n                    value: stringTruncate(params.trigger_description, 1024)\n                }\n            );\n        }\n\n        body.embeds[0].footer = {\n            text: 'Event ID: ' + params.event_id\n        };\n\n        if (params.event_tags) {\n            body.embeds[0].footer.text += '\\nEvent tags: ' + params.event_tags;\n        }\n        body.embeds[0].footer.text = stringTruncate(body.embeds[0].footer.text, 2048);\n    }\n\n    if (fields.length > 0) {\n        body.embeds[0].fields = fields;\n    }\n\n    var req = new CurlHttpRequest();\n\n    if (typeof params.HTTPProxy === 'string' && params.HTTPProxy.trim() !== '') {\n        req.SetProxy(params.HTTPProxy);\n    }\n\n    req.AddHeader('Content-Type: application/json');\n\n    var resp = req.Post(params.discord_endpoint, JSON.stringify(body)),\n        data = JSON.parse(resp);\n\n    Zabbix.Log(4, '[ Discord Webhook ] JSON: ' + JSON.stringify(body));\n    Zabbix.Log(4, '[ Discord Webhook ] Response: ' + resp);\n\n    if (data.id) {\n        return resp;\n    }\n    else {\n        var message = ((typeof data.message === 'string') ? data.message : 'Unknown error');\n\n        Zabbix.Log(3, '[ Discord Webhook ] FAILED with response: ' + resp);\n        throw message + '. For more details check zabbix server log.';\n    }\n}\ncatch (error) {\n    Zabbix.Log(3, '[ Discord Webhook ] ERROR: ' + error);\n    throw 'Sending failed: ' + error;\n}",
                "message_templates": [
                    {
                        "event_source": "TRIGGERS",
                        "operation_mode": "PROBLEM",
                        "subject": "[{EVENT.STATUS}] {EVENT.NAME}",
                        "message": "Problem started at {EVENT.TIME} on {EVENT.DATE}\nProblem name: {EVENT.NAME}\nHost: {HOST.NAME}\nSeverity: {EVENT.SEVERITY}\nOperational data: {EVENT.OPDATA}\nOriginal problem ID: {EVENT.ID}\n{TRIGGER.URL}"
                    },
                    {
                        "event_source": "TRIGGERS",
                        "operation_mode": "RECOVERY",
                        "subject": "[{EVENT.STATUS}] {EVENT.NAME}",
                        "message": "Problem has been resolved in {EVENT.DURATION} at {EVENT.RECOVERY.TIME} on {EVENT.RECOVERY.DATE}\nProblem name: {EVENT.NAME}\nHost: {HOST.NAME}\nSeverity: {EVENT.SEVERITY}\nOriginal problem ID: {EVENT.ID}\n{TRIGGER.URL}"
                    },
                    {
                        "event_source": "TRIGGERS",
                        "operation_mode": "UPDATE",
                        "subject": "[{EVENT.STATUS}] {EVENT.NAME}",
                        "message": "{USER.FULLNAME} {EVENT.UPDATE.ACTION} problem at {EVENT.UPDATE.DATE} {EVENT.UPDATE.TIME}.\n{EVENT.UPDATE.MESSAGE}\n\nCurrent problem status is {EVENT.STATUS}, acknowledged: {EVENT.ACK.STATUS}."
                    },
                    {
                        "event_source": "DISCOVERY",
                        "operation_mode": "PROBLEM",
                        "subject": "Discovery: {DISCOVERY.DEVICE.STATUS} {DISCOVERY.DEVICE.IPADDRESS}",
                        "message": "Discovery rule: {DISCOVERY.RULE.NAME}\n\nDevice IP: {DISCOVERY.DEVICE.IPADDRESS}\nDevice DNS: {DISCOVERY.DEVICE.DNS}\nDevice status: {DISCOVERY.DEVICE.STATUS}\nDevice uptime: {DISCOVERY.DEVICE.UPTIME}\n\nDevice service name: {DISCOVERY.SERVICE.NAME}\nDevice service port: {DISCOVERY.SERVICE.PORT}\nDevice service status: {DISCOVERY.SERVICE.STATUS}\nDevice service uptime: {DISCOVERY.SERVICE.UPTIME}"
                    },
                    {
                        "event_source": "AUTOREGISTRATION",
                        "operation_mode": "PROBLEM",
                        "subject": "Autoregistration: {HOST.HOST}",
                        "message": "Host name: {HOST.HOST}\nHost IP: {HOST.IP}\nAgent port: {HOST.PORT}"
                    }
                ]
            },
            {
                "name": "Email",
                "type": "EMAIL",
                "smtp_server": "mail.example.com",
                "smtp_helo": "example.com",
                "smtp_email": "zabbix@example.com",
                "content_type": "TEXT",
                "status": "DISABLED",
                "message_templates": [
                    {
                        "event_source": "TRIGGERS",
                        "operation_mode": "PROBLEM",
                        "subject": "Problem: {EVENT.NAME}",
                        "message": "Problem started at {EVENT.TIME} on {EVENT.DATE}\nProblem name: {EVENT.NAME}\nHost: {HOST.NAME}\nSeverity: {EVENT.SEVERITY}\nOperational data: {EVENT.OPDATA}\nOriginal problem ID: {EVENT.ID}\n{TRIGGER.URL}"
                    },
                    {
                        "event_source": "TRIGGERS",
                        "operation_mode": "RECOVERY",
                        "subject": "Resolved in {EVENT.DURATION}: {EVENT.NAME}",
                        "message": "Problem has been resolved at {EVENT.RECOVERY.TIME} on {EVENT.RECOVERY.DATE}\nProblem name: {EVENT.NAME}\nProblem duration: {EVENT.DURATION}\nHost: {HOST.NAME}\nSeverity: {EVENT.SEVERITY}\nOriginal problem ID: {EVENT.ID}\n{TRIGGER.URL}"
                    },
                    {
                        "event_source": "TRIGGERS",
                        "operation_mode": "UPDATE",
                        "subject": "Updated problem in {EVENT.AGE}: {EVENT.NAME}",
                        "message": "{USER.FULLNAME} {EVENT.UPDATE.ACTION} problem at {EVENT.UPDATE.DATE} {EVENT.UPDATE.TIME}.\n{EVENT.UPDATE.MESSAGE}\n\nCurrent problem status is {EVENT.STATUS}, age is {EVENT.AGE}, acknowledged: {EVENT.ACK.STATUS}."
                    },
                    {
                        "event_source": "DISCOVERY",
                        "operation_mode": "PROBLEM",
                        "subject": "Discovery: {DISCOVERY.DEVICE.STATUS} {DISCOVERY.DEVICE.IPADDRESS}",
                        "message": "Discovery rule: {DISCOVERY.RULE.NAME}\n\nDevice IP: {DISCOVERY.DEVICE.IPADDRESS}\nDevice DNS: {DISCOVERY.DEVICE.DNS}\nDevice status: {DISCOVERY.DEVICE.STATUS}\nDevice uptime: {DISCOVERY.DEVICE.UPTIME}\n\nDevice service name: {DISCOVERY.SERVICE.NAME}\nDevice service port: {DISCOVERY.SERVICE.PORT}\nDevice service status: {DISCOVERY.SERVICE.STATUS}\nDevice service uptime: {DISCOVERY.SERVICE.UPTIME}"
                    },
                    {
                        "event_source": "AUTOREGISTRATION",
                        "operation_mode": "PROBLEM",
                        "subject": "Autoregistration: {HOST.HOST}",
                        "message": "Host name: {HOST.HOST}\nHost IP: {HOST.IP}\nAgent port: {HOST.PORT}"
                    }
                ]
            },
            {
                "name": "Email (HTML)",
                "type": "EMAIL",
                "smtp_server": "mail.example.com",
                "smtp_helo": "example.com",
                "smtp_email": "zabbix@example.com",
                "status": "DISABLED",
                "message_templates": [
                    {
                        "event_source": "TRIGGERS",
                        "operation_mode": "PROBLEM",
                        "subject": "Problem: {EVENT.NAME}",
                        "message": "<b>Problem started</b> at {EVENT.TIME} on {EVENT.DATE}<br><b>Problem name:</b> {EVENT.NAME}<br><b>Host:</b> {HOST.NAME}<br><b>Severity:</b> {EVENT.SEVERITY}<br><b>Operational data:</b> {EVENT.OPDATA}<br><b>Original problem ID:</b> {EVENT.ID}<br>{TRIGGER.URL}"
                    },
                    {
                        "event_source": "TRIGGERS",
                        "operation_mode": "RECOVERY",
                        "subject": "Resolved in {EVENT.DURATION}: {EVENT.NAME}",
                        "message": "<b>Problem has been resolved</b> at {EVENT.RECOVERY.TIME} on {EVENT.RECOVERY.DATE}<br><b>Problem name:</b> {EVENT.NAME}<br><b>Problem duration:</b> {EVENT.DURATION}<br><b>Host:</b> {HOST.NAME}<br><b>Severity:</b> {EVENT.SEVERITY}<br><b>Original problem ID:</b> {EVENT.ID}<br>{TRIGGER.URL}"
                    },
                    {
                        "event_source": "TRIGGERS",
                        "operation_mode": "UPDATE",
                        "subject": "Updated problem in {EVENT.AGE}: {EVENT.NAME}",
                        "message": "<b>{USER.FULLNAME} {EVENT.UPDATE.ACTION} problem</b> at {EVENT.UPDATE.DATE} {EVENT.UPDATE.TIME}.<br>{EVENT.UPDATE.MESSAGE}<br><br><b>Current problem status:</b> {EVENT.STATUS}<br><b>Age:</b> {EVENT.AGE}<br><b>Acknowledged:</b> {EVENT.ACK.STATUS}."
                    },
                    {
                        "event_source": "DISCOVERY",
                        "operation_mode": "PROBLEM",
                        "subject": "Discovery: {DISCOVERY.DEVICE.STATUS} {DISCOVERY.DEVICE.IPADDRESS}",
                        "message": "<b>Discovery rule:</b> {DISCOVERY.RULE.NAME}<br><br><b>Device IP:</b> {DISCOVERY.DEVICE.IPADDRESS}<br><b>Device DNS:</b> {DISCOVERY.DEVICE.DNS}<br><b>Device status:</b> {DISCOVERY.DEVICE.STATUS}<br><b>Device uptime:</b> {DISCOVERY.DEVICE.UPTIME}<br><br><b>Device service name:</b> {DISCOVERY.SERVICE.NAME}<br><b>Device service port:</b> {DISCOVERY.SERVICE.PORT}<br><b>Device service status:</b> {DISCOVERY.SERVICE.STATUS}<br><b>Device service uptime:</b> {DISCOVERY.SERVICE.UPTIME}"
                    },
                    {
                        "event_source": "AUTOREGISTRATION",
                        "operation_mode": "PROBLEM",
                        "subject": "Autoregistration: {HOST.HOST}",
                        "message": "<b>Host name:</b> {HOST.HOST}<br><b>Host IP:</b> {HOST.IP}<br><b>Agent port:</b> {HOST.PORT}"
                    }
                ]
            },
            {
                "name": "iLert",
                "type": "WEBHOOK",
                "parameters": [
                    {
                        "name": ".ILERT.ALERT.SOURCE.KEY",
                        "value": "{ALERT.SENDTO}"
                    },
                    {
                        "name": ".ILERT.INCIDENT.SUMMARY",
                        "value": ""
                    },
                    {
                        "name": "ALERT.MESSAGE",
                        "value": "{ALERT.MESSAGE}"
                    },
                    {
                        "name": "ALERT.SUBJECT",
                        "value": "{ALERT.SUBJECT}"
                    },
                    {
                        "name": "EVENT.ACK.STATUS",
                        "value": "{EVENT.ACK.STATUS}"
                    },
                    {
                        "name": "EVENT.DATE",
                        "value": "{EVENT.DATE}"
                    },
                    {
                        "name": "EVENT.ID",
                        "value": "{EVENT.ID}"
                    },
                    {
                        "name": "EVENT.NAME",
                        "value": "{EVENT.NAME}"
                    },
                    {
                        "name": "EVENT.NSEVERITY",
                        "value": "{EVENT.NSEVERITY}"
                    },
                    {
                        "name": "EVENT.OPDATA",
                        "value": "{EVENT.OPDATA}"
                    },
                    {
                        "name": "EVENT.RECOVERY.DATE",
                        "value": "{EVENT.RECOVERY.DATE}"
                    },
                    {
                        "name": "EVENT.RECOVERY.TIME",
                        "value": "{EVENT.RECOVERY.TIME}"
                    },
                    {
                        "name": "EVENT.RECOVERY.VALUE",
                        "value": "{EVENT.RECOVERY.VALUE}"
                    },
                    {
                        "name": "EVENT.SEVERITY",
                        "value": "{EVENT.SEVERITY}"
                    },
                    {
                        "name": "EVENT.TAGS",
                        "value": "{EVENT.TAGS}"
                    },
                    {
                        "name": "EVENT.TIME",
                        "value": "{EVENT.TIME}"
                    },
                    {
                        "name": "EVENT.UPDATE.ACTION",
                        "value": "{EVENT.UPDATE.ACTION}"
                    },
                    {
                        "name": "EVENT.UPDATE.DATE",
                        "value": "{EVENT.UPDATE.DATE}"
                    },
                    {
                        "name": "EVENT.UPDATE.MESSAGE",
                        "value": "{EVENT.UPDATE.MESSAGE}"
                    },
                    {
                        "name": "EVENT.UPDATE.STATUS",
                        "value": "{EVENT.UPDATE.STATUS}"
                    },
                    {
                        "name": "EVENT.UPDATE.TIME",
                        "value": "{EVENT.UPDATE.TIME}"
                    },
                    {
                        "name": "EVENT.VALUE",
                        "value": "{EVENT.VALUE}"
                    },
                    {
                        "name": "HOST.HOST",
                        "value": "{HOST.HOST}"
                    },
                    {
                        "name": "HOST.IP",
                        "value": "{HOST.IP}"
                    },
                    {
                        "name": "HOST.NAME",
                        "value": "{HOST.NAME}"
                    },
                    {
                        "name": "ITEM.ID1",
                        "value": "{ITEM.ID1}"
                    },
                    {
                        "name": "ITEM.ID2",
                        "value": "{ITEM.ID2}"
                    },
                    {
                        "name": "ITEM.ID3",
                        "value": "{ITEM.ID3}"
                    },
                    {
                        "name": "ITEM.ID4",
                        "value": "{ITEM.ID4}"
                    },
                    {
                        "name": "ITEM.ID5",
                        "value": "{ITEM.ID5}"
                    },
                    {
                        "name": "ITEM.NAME1",
                        "value": "{ITEM.NAME1}"
                    },
                    {
                        "name": "ITEM.NAME2",
                        "value": "{ITEM.NAME2}"
                    },
                    {
                        "name": "ITEM.NAME3",
                        "value": "{ITEM.NAME3}"
                    },
                    {
                        "name": "ITEM.NAME4",
                        "value": "{ITEM.NAME4}"
                    },
                    {
                        "name": "ITEM.NAME5",
                        "value": "{ITEM.NAME5}"
                    },
                    {
                        "name": "TRIGGER.DESCRIPTION",
                        "value": "{TRIGGER.DESCRIPTION}"
                    },
                    {
                        "name": "TRIGGER.ID",
                        "value": "{TRIGGER.ID}"
                    },
                    {
                        "name": "TRIGGER.NAME",
                        "value": "{TRIGGER.NAME}"
                    },
                    {
                        "name": "TRIGGER.SEVERITY",
                        "value": "{TRIGGER.SEVERITY}"
                    },
                    {
                        "name": "TRIGGER.STATUS",
                        "value": "{TRIGGER.STATUS}"
                    },
                    {
                        "name": "TRIGGER.URL",
                        "value": "{TRIGGER.URL}"
                    },
                    {
                        "name": "TRIGGER.VALUE",
                        "value": "{TRIGGER.VALUE}"
                    },
                    {
                        "name": "USER.FULLNAME",
                        "value": "{USER.FULLNAME}"
                    },
                    {
                        "name": "ZABBIX.URL",
                        "value": "{$ZABBIX.URL}"
                    }
                ],
                "status": "DISABLED",
                "script": "try {\n    var result = { tags: {} },\n        params = JSON.parse(value),\n        req = new CurlHttpRequest(),\n        resp = '';\n\n    if (typeof params.HTTPProxy === 'string' && params.HTTPProxy.trim() !== '') {\n        req.SetProxy(params.HTTPProxy);\n    }\n    var alertSourceKey = params['.ILERT.ALERT.SOURCE.KEY'];\n    if (!alertSourceKey || (typeof alertSourceKey === 'string' && alertSourceKey.trim() === '')) {\n        throw 'incorrect value for variable \"ILERT.ALERT.SOURCE.KEY\". The value must be a non-empty string.';\n    }\n    delete params['.ILERT.ALERT.SOURCE.KEY'];\n    \n    var ilertApiBaseURL = \"https://api.ilert.com\";\n    var reqURL = encodeURI(ilertApiBaseURL + \"/api/v1/events/zabbix-mt/\" + alertSourceKey)\n\n    var incidentKey = \"zabbix-\" + params['EVENT.ID'];\n    var incidentViewURL = ilertApiBaseURL + \"/api/v1/incidents/resolve-ik/\" + alertSourceKey + \"/\" + incidentKey;\n\n    req.AddHeader('Accept: application/json');\n    req.AddHeader('Content-Type: application/json');\n\n    Zabbix.Log(4, '[iLert Webhook] Sending request:' + JSON.stringify(params));\n    resp = req.Post(reqURL, JSON.stringify(params));\n    Zabbix.Log(4, '[iLert Webhook] Receiving response:' + resp);\n\n    try {\n        resp = JSON.parse(resp);\n    }\n    catch (error) {\n        throw 'incorrect response. iLert returned a non-JSON object.';\n    }\n\n    if (req.Status() == 200) {\n        result.tags.__ilert_incident_url = incidentViewURL;\n        return JSON.stringify(result);\n    }\n\n    if (req.Status() == 400 && typeof resp === 'object' && typeof resp.code === 'string') {\n        if (resp.code === 'NO_OPEN_INCIDENT_WITH_KEY') {\n          return JSON.stringify(result);\n        }\n        if (resp.code === 'INCIDENT_ALREADY_ACCEPTED') {\n          result.tags.__ilert_incident_url = incidentViewURL;\n          return JSON.stringify(result);\n        }\n    }\n\n    if (typeof resp === 'object' && typeof resp.message === 'string') {\n        throw resp.message;\n    }\n    else {\n        throw 'Unknown error.';\n    }\n}\ncatch (error) {\n    Zabbix.Log(3, '[iLert Webhook] Notification failed : ' + error);\n    throw 'iLert notification failed : ' + error;\n}",
                "process_tags": "YES",
                "show_event_menu": "YES",
                "event_menu_url": "{EVENT.TAGS.__ilert_incident_url}",
                "event_menu_name": "iLert incident",
                "description": "Please refer to https://docs.ilert.com/integrations/zabbix/native \n  \nSet global macro {$ZABBIX.URL} with your Zabbix server URL.\nAdd a dedicated user with the media type \"iLert\". You can also rewrite the incident summary via \".ILERT.INCIDENT.SUMMARY\" parameter or leave it empty to use the standard pattern.",
                "message_templates": [
                    {
                        "event_source": "TRIGGERS",
                        "operation_mode": "PROBLEM",
                        "subject": "Problem: {EVENT.NAME}",
                        "message": "Problem started at {EVENT.TIME} on {EVENT.DATE}\nProblem name: {EVENT.NAME}\nHost: {HOST.NAME}\nSeverity: {EVENT.SEVERITY}\nOperational data: {EVENT.OPDATA}\nOriginal problem ID: {EVENT.ID}\n{TRIGGER.URL}"
                    },
                    {
                        "event_source": "TRIGGERS",
                        "operation_mode": "UPDATE",
                        "subject": "Updated problem in {EVENT.AGE}: {EVENT.NAME}",
                        "message": "{USER.FULLNAME} {EVENT.UPDATE.ACTION} problem at {EVENT.UPDATE.DATE} {EVENT.UPDATE.TIME}.\n{EVENT.UPDATE.MESSAGE}\n\nCurrent problem status is {EVENT.STATUS}, age is {EVENT.AGE}, acknowledged: {EVENT.ACK.STATUS}."
                    },
                    {
                        "event_source": "TRIGGERS",
                        "operation_mode": "RECOVERY",
                        "subject": "Resolved in {EVENT.DURATION}: {EVENT.NAME}",
                        "message": "Problem has been resolved at {EVENT.RECOVERY.TIME} on {EVENT.RECOVERY.DATE}\nProblem name: {EVENT.NAME}\nProblem duration: {EVENT.DURATION}\nHost: {HOST.NAME}\nSeverity: {EVENT.SEVERITY}\nOriginal problem ID: {EVENT.ID}\n{TRIGGER.URL}"
                    }
                ]
            },
            {
                "name": "iTop",
                "type": "WEBHOOK",
                "parameters": [
                    {
                        "name": "alert_message",
                        "value": "{ALERT.MESSAGE}"
                    },
                    {
                        "name": "alert_subject",
                        "value": "{ALERT.SUBJECT}"
                    },
                    {
                        "name": "event_recovery_value",
                        "value": "{EVENT.RECOVERY.VALUE}"
                    },
                    {
                        "name": "event_source",
                        "value": "{EVENT.SOURCE}"
                    },
                    {
                        "name": "event_update_status",
                        "value": "{EVENT.UPDATE.STATUS}"
                    },
                    {
                        "name": "event_value",
                        "value": "{EVENT.VALUE}"
                    },
                    {
                        "name": "itop_api_version",
                        "value": "1.3"
                    },
                    {
                        "name": "itop_class",
                        "value": "UserRequest"
                    },
                    {
                        "name": "itop_comment",
                        "value": "Created by Zabbix action {ACTION.NAME}"
                    },
                    {
                        "name": "itop_id",
                        "value": "{EVENT.TAGS.__zbx_itop_id}"
                    },
                    {
                        "name": "itop_log",
                        "value": "private_log"
                    },
                    {
                        "name": "itop_organization_id",
                        "value": "<PLACE ORGANIZATION ID>"
                    },
                    {
                        "name": "itop_password",
                        "value": "<PLACE PASSWORD OR TOKEN>"
                    },
                    {
                        "name": "itop_url",
                        "value": "<PLACE YOUR ITOP URL>"
                    },
                    {
                        "name": "itop_user",
                        "value": "<PLACE LOGIN>"
                    }
                ],
                "status": "DISABLED",
                "script": "var Itop = {\n    params: {},\n\n    setParams: function (params) {\n        if (typeof params !== 'object') {\n            return;\n        }\n\n        if (params.log !== 'private_log' && params.log !== 'public_log') {\n            throw 'Incorrect \"itop_log\" parameter given: ' + params.log + '\\nMust be \"private_log\" or \"public_log\".';\n        }\n\n        Itop.params = params;\n        if (typeof Itop.params.url === 'string') {\n            if (!Itop.params.url.endsWith('/')) {\n                Itop.params.url += '/';\n            }\n\n            Itop.params.url += 'webservices/rest.php?version=' + encodeURIComponent(Itop.params.api_version);\n        }\n    },\n\n    setProxy: function (HTTPProxy) {\n        Itop.HTTPProxy = HTTPProxy;\n    },\n\n    setCreatePayload: function () {\n        json_data.operation = 'core/create';\n        json_data.fields.org_id = Itop.params.organization_id;\n        json_data.fields.title = params.alert_subject;\n        json_data.fields.description = params.alert_message.replace('<', '&lt;')\n            .replace('>', '&gt;')\n            .replace(/(?:\\r\\n|\\r|\\n)/g, '<br>');\n    },\n\n    setUpdatePayload: function () {\n        json_data.operation = 'core/update';\n        json_data.key = Itop.params.id;\n        json_data.fields.title = params.alert_subject;\n        json_data.fields[Itop.params.log] = {\n            add_item: {\n                message: params.alert_subject + '\\n' + params.alert_message,\n                format: 'text'\n            }\n        };\n    },\n\n    request: function (data) {\n        ['url', 'user', 'password', 'organization_id', 'class', 'api_version', 'id'].forEach(function (field) {\n            if (typeof Itop.params !== 'object' || typeof Itop.params[field] === 'undefined'\n                    || Itop.params[field] === '' ) {\n                throw 'Required Itop param is not set: \"itop_' + field + '\".';\n            }\n        });\n\n        var response,\n            url = Itop.params.url,\n            request = new CurlHttpRequest(),\n            object;\n\n        request.AddHeader('Content-Type: multipart/form-data');\n        request.AddHeader('Authorization: Basic ' + btoa(Itop.params.user + ':' + Itop.params.password));\n\n        if (Itop.HTTPProxy) {\n            request.SetProxy(Itop.HTTPProxy);\n        }\n\n        if (typeof data !== 'undefined') {\n            data = JSON.stringify(data);\n        }\n\n        Zabbix.Log(4, '[ iTop Webhook ] Sending request: ' + url + '&json_data=' + data);\n\n        response = request.Post(url + '&json_data=' + encodeURIComponent(data));\n\n        Zabbix.Log(4, '[ iTop Webhook ] Received response with status code ' + request.Status() + '\\n' + response);\n\n        try {\n            response = JSON.parse(response);\n        }\n        catch (error) {\n            Zabbix.Log(4, '[ iTop Webhook ] Failed to parse response received from iTop');\n            throw 'Failed to parse response received from iTop.\\nRequest status code ' +\n                    request.Status() + '. Check debug log for more information.';\n        }\n\n        if (request.Status() < 200 || request.Status() >= 300) {\n            throw 'Request failed with status code ' + request.Status() + '. Check debug log for more information.';\n        }\n        else if (typeof response.code !== 'undefined' && response.code !== 0) {\n            throw 'Request failed with iTop code ' + response.code + ': ' +\n                    JSON.stringify(response.message) + '. Check debug log for more information.';\n        }\n        else {\n            Object.keys(response.objects)\n                .forEach(function (key) {\n                    object = response.objects[key];\n                });\n    \n            return {\n                status: request.Status(),\n                response: object.fields\n            };\n        }\n    }\n};\n\ntry {\n    var params = JSON.parse(value),\n        json_data = {},\n        itop_params = {},\n        result = {tags: {}},\n        required_params = [\n            'alert_subject', 'summary', 'event_recovery_value',\n            'event_source', 'event_value', 'action_name'\n        ];\n\n    Object.keys(params)\n        .forEach(function (key) {\n            if (key.startsWith('itop_')) {\n                itop_params[key.substring(5)] = params[key];\n            }\n            else if (required_params.indexOf(key) !== -1 && params[key] === '') {\n                throw 'Parameter \"' + key + '\" can\\'t be empty.';\n            }\n        });\n\n    if ([0, 1, 2, 3].indexOf(parseInt(params.event_source)) === -1) {\n        throw 'Incorrect \"event_source\" parameter given: ' + params.event_source + '\\nMust be 0-3.';\n    }\n\n    // Check {EVENT.VALUE} for trigger-based and internal events.\n    if (params.event_value !== '0' && params.event_value !== '1'\n            && (params.event_source === '0' || params.event_source === '3')) {\n        throw 'Incorrect \"event_value\" parameter given: ' + params.event_value + '\\nMust be 0 or 1.';\n    }\n\n    // Check {EVENT.UPDATE.STATUS} only for trigger-based events.\n    if (params.event_update_status !== '0' && params.event_update_status !== '1' && params.event_source === '0') {\n        throw 'Incorrect \"event_update_status\" parameter given: ' + params.event_update_status + '\\nMust be 0 or 1.';\n    }\n\n    if (params.event_source !== '0' && params.event_recovery_value === '0') {\n        throw 'Recovery operations are supported only for trigger-based actions.';\n    }\n\n    Itop.setParams(itop_params);\n    Itop.setProxy(params.HTTPProxy);\n\n    json_data.operation = '';\n    json_data.class = Itop.params.class;\n    json_data.comment = Itop.params.comment;\n    json_data.output_fields = 'id, friendlyname';\n    json_data.fields = {};\n\n    // Create issue for non trigger-based events.\n    if (params.event_source !== '0' && params.event_recovery_value !== '0') {\n        Itop.setCreatePayload();\n        Itop.request(json_data);\n    }\n    // Create issue for trigger-based events.\n    else if (params.event_value === '1' && params.event_update_status === '0'\n            && Itop.params.id === '{EVENT.TAGS.__zbx_itop_id}') {\n        Itop.setCreatePayload();\n\n        var response = Itop.request(json_data);\n\n        result.tags.__zbx_itop_id = response.response.id;\n        result.tags.__zbx_itop_key = response.response.friendlyname;\n        result.tags.__zbx_itop_link = params.itop_url + (params.itop_url.endsWith('/') ? '' : '/') +\n                'pages/UI.php?operation=details&class=' + encodeURIComponent(Itop.params.class) + '&id=' +\n                encodeURIComponent(response.response.id);\n    }\n    // Update created issue for trigger-based event.\n    else {\n        if (Itop.params.id === '{EVENT.TAGS.__zbx_itop_id}') {\n            throw 'Incorrect iTop ticket ID given: ' + Itop.params.id;\n        }\n        Itop.setUpdatePayload();\n        Itop.request(json_data);\n    }\n\n    return JSON.stringify(result);\n}\ncatch (error) {\n    Zabbix.Log(3, '[ iTop Webhook ] ERROR: ' + error);\n    throw 'Sending failed: ' + error;\n}",
                "process_tags": "YES",
                "show_event_menu": "YES",
                "event_menu_url": "{EVENT.TAGS.__zbx_itop_link}",
                "event_menu_name": "iTop: {EVENT.TAGS.__zbx_itop_key}",
                "message_templates": [
                    {
                        "event_source": "TRIGGERS",
                        "operation_mode": "PROBLEM",
                        "subject": "[{EVENT.STATUS}] {EVENT.NAME}",
                        "message": "Problem started at {EVENT.TIME} on {EVENT.DATE}\nProblem name: {EVENT.NAME}\nHost: {HOST.NAME}\nSeverity: {EVENT.SEVERITY}\nOperational data: {EVENT.OPDATA}\nOriginal problem ID: {EVENT.ID}\n{TRIGGER.URL}"
                    },
                    {
                        "event_source": "TRIGGERS",
                        "operation_mode": "RECOVERY",
                        "subject": "[{EVENT.STATUS}] {EVENT.NAME}",
                        "message": "Problem has been resolved in {EVENT.DURATION} at {EVENT.RECOVERY.TIME} on {EVENT.RECOVERY.DATE}\nProblem name: {EVENT.NAME}\nHost: {HOST.NAME}\nSeverity: {EVENT.SEVERITY}\nOriginal problem ID: {EVENT.ID}\n{TRIGGER.URL}"
                    },
                    {
                        "event_source": "TRIGGERS",
                        "operation_mode": "UPDATE",
                        "subject": "[{EVENT.STATUS}] {EVENT.NAME}",
                        "message": "{USER.FULLNAME} {EVENT.UPDATE.ACTION} problem at {EVENT.UPDATE.DATE} {EVENT.UPDATE.TIME}.\n{EVENT.UPDATE.MESSAGE}\n\nCurrent problem status is {EVENT.STATUS}, acknowledged: {EVENT.ACK.STATUS}."
                    },
                    {
                        "event_source": "DISCOVERY",
                        "operation_mode": "PROBLEM",
                        "subject": "Discovery: {DISCOVERY.DEVICE.STATUS} {DISCOVERY.DEVICE.IPADDRESS}",
                        "message": "Discovery rule: {DISCOVERY.RULE.NAME}\n\nDevice IP: {DISCOVERY.DEVICE.IPADDRESS}\nDevice DNS: {DISCOVERY.DEVICE.DNS}\nDevice status: {DISCOVERY.DEVICE.STATUS}\nDevice uptime: {DISCOVERY.DEVICE.UPTIME}\n\nDevice service name: {DISCOVERY.SERVICE.NAME}\nDevice service port: {DISCOVERY.SERVICE.PORT}\nDevice service status: {DISCOVERY.SERVICE.STATUS}\nDevice service uptime: {DISCOVERY.SERVICE.UPTIME}"
                    },
                    {
                        "event_source": "AUTOREGISTRATION",
                        "operation_mode": "PROBLEM",
                        "subject": "Autoregistration: {HOST.HOST}",
                        "message": "Host name: {HOST.HOST}\nHost IP: {HOST.IP}\nAgent port: {HOST.PORT}"
                    }
                ]
            },
            {
                "name": "Jira",
                "type": "WEBHOOK",
                "parameters": [
                    {
                        "name": "alert_message",
                        "value": "{ALERT.MESSAGE}"
                    },
                    {
                        "name": "alert_subject",
                        "value": "{ALERT.SUBJECT}"
                    },
                    {
                        "name": "event_recovery_value",
                        "value": "{EVENT.RECOVERY.VALUE}"
                    },
                    {
                        "name": "event_source",
                        "value": "{EVENT.SOURCE}"
                    },
                    {
                        "name": "event_tags_json",
                        "value": "{EVENT.TAGSJSON}"
                    },
                    {
                        "name": "event_update_action",
                        "value": "{EVENT.UPDATE.ACTION}"
                    },
                    {
                        "name": "event_update_message",
                        "value": "{EVENT.UPDATE.MESSAGE}"
                    },
                    {
                        "name": "event_update_status",
                        "value": "{EVENT.UPDATE.STATUS}"
                    },
                    {
                        "name": "event_update_user",
                        "value": "{USER.FULLNAME}"
                    },
                    {
                        "name": "event_value",
                        "value": "{EVENT.VALUE}"
                    },
                    {
                        "name": "jira_issue_key",
                        "value": "{EVENT.TAGS.__zbx_jira_issuekey}"
                    },
                    {
                        "name": "jira_issue_type",
                        "value": "<PLACE ISSUETYPE NAME>"
                    },
                    {
                        "name": "jira_password",
                        "value": "<PLACE PASSWORD OR TOKEN>"
                    },
                    {
                        "name": "jira_project_key",
                        "value": "<PLACE PROJECT KEY>"
                    },
                    {
                        "name": "jira_url",
                        "value": "<PLACE YOUR JIRA URL>"
                    },
                    {
                        "name": "jira_user",
                        "value": "<PLACE LOGIN>"
                    },
                    {
                        "name": "trigger_description",
                        "value": "{TRIGGER.DESCRIPTION}"
                    }
                ],
                "status": "DISABLED",
                "script": "var Jira = {\n    params: {},\n\n    setParams: function (params) {\n        if (typeof params !== 'object') {\n            return;\n        }\n\n        Jira.params = params;\n        if (typeof Jira.params.url === 'string') {\n            if (!Jira.params.url.endsWith('/')) {\n                Jira.params.url += '/';\n            }\n\n            Jira.params.url += 'rest/api/latest/';\n        }\n    },\n\n    setProxy: function (HTTPProxy) {\n        Jira.HTTPProxy = HTTPProxy;\n    },\n\n    setTags: function(event_tags_json) {\n        if (typeof event_tags_json !== 'undefined' && event_tags_json !== ''\n            && event_tags_json !== '{EVENT.TAGSJSON}') {\n            try {\n                var tags = JSON.parse(event_tags_json),\n                    label;\n\n                Jira.labels = [];\n\n                tags.forEach(function (tag) {\n                    if (typeof tag.tag !== 'undefined' && typeof tag.value !== 'undefined'\n                        && !tag.tag.startsWith('__zbx')) {\n                        label = (tag.tag + (tag.value ? (':' + tag.value) : '')).replace(/\\s/g, '_');\n                        if (label.length < 256) {\n                            Jira.labels.push(label);\n                        }\n                    }\n                });\n            }\n            catch (error) {\n                // Code is not missing here.\n            }\n        }\n    },\n\n    escapeMarkup: function (str) {\n        var length = str.length,\n            result = '',\n            markup = ['{', '|', '}', '~', '_', '\\\\', '[', ']', '^', '<', '>', '?', '!', '#', '+', '*', '&'];\n\n        for (var i = 0; i < length; i++) {\n            var char = str[i];\n\n            result += (markup.indexOf(char) !== -1) ? ('&#' + str[i].charCodeAt() + ';') : char;\n        }\n\n        return result;\n    },\n\n    addCustomFields: function (data, fields) {\n        if (typeof fields === 'object' && Object.keys(fields).length) {\n            var schema = Jira.getSchema(),\n                path = ['projects', 0, 'issuetypes', 0, 'fields'],\n                field;\n\n            while ((field = path.shift()) !== undefined) {\n                schema = schema[field];\n                if (typeof schema === 'undefined') {\n                    schema = null;\n                    break;\n                }\n            }\n\n            if (schema) {\n                Object.keys(fields)\n                    .forEach(function(field) {\n                        if (typeof schema[field] === 'object' && typeof schema[field].schema === 'object') {\n                            switch (schema[field].schema.type) {\n                                case 'number':\n                                    data.fields[field] = parseInt(fields[field]);\n                                    break;\n\n                                case 'datetime':\n                                    if (fields[field].match(/\\d+[.-]\\d+[.-]\\d+T\\d+:\\d+:\\d+/) !== null) {\n                                        data.fields[field] = fields[field].replace(/\\./g, '-');\n                                    }\n                                    break;\n\n                                case 'option':\n                                    data.fields[field] = {value: fields[field]};\n                                    break;\n\n                                case 'array':\n                                    if (schema[field].schema.items === 'option') {\n                                        data.fields[field] = [{value: fields[field]}];\n                                    }\n                                    else {\n                                        data.fields[field] = [fields[field]];\n                                    }\n                                    break;\n\n                                default:\n                                    data.fields[field] = fields[field];\n                            }\n                        }\n                    });\n            }\n            else {\n                Zabbix.Log(4, '[ Jira Webhook ] Failed to retrieve field schema.');\n            }\n        }\n\n        return data;\n    },\n\n    request: function (method, query, data) {\n        ['url', 'user', 'password', 'project_key', 'issue_type'].forEach(function (field) {\n            if (typeof Jira.params !== 'object' || typeof Jira.params[field] === 'undefined'\n                || Jira.params[field] === '' ) {\n                throw 'Required Jira param is not set: \"' + field + '\".';\n            }\n        });\n\n        var response,\n            url = Jira.params.url + query,\n            request = new CurlHttpRequest();\n\n        request.AddHeader('Content-Type: application/json');\n        request.AddHeader('Authorization: Basic ' + btoa(Jira.params.user + ':' + Jira.params.password));\n\n        if (typeof Jira.HTTPProxy !== 'undefined' && Jira.HTTPProxy !== '') {\n            request.SetProxy(Jira.HTTPProxy);\n        }\n\n        if (typeof data !== 'undefined') {\n            data = JSON.stringify(data);\n        }\n\n        Zabbix.Log(4, '[ Jira Webhook ] Sending request: ' + url + ((typeof data === 'string') ? ('\\n' + data) : ''));\n\n        switch (method) {\n            case 'get':\n                response = request.Get(url, data);\n                break;\n\n            case 'post':\n                response = request.Post(url, data);\n                break;\n\n            case 'put':\n                response = request.Put(url, data);\n                break;\n\n            default:\n                throw 'Unsupported HTTP request method: ' + method;\n        }\n\n        Zabbix.Log(4, '[ Jira Webhook ] Received response with status code ' + request.Status() + '\\n' + response);\n\n        if (response !== null) {\n            try {\n                response = JSON.parse(response);\n            }\n            catch (error) {\n                Zabbix.Log(4, '[ Jira Webhook ] Failed to parse response received from Jira');\n                response = null;\n            }\n        }\n\n        if (request.Status() < 200 || request.Status() >= 300) {\n            var message = 'Request failed with status code ' + request.Status();\n\n            if (response !== null && typeof response.errors !== 'undefined'\n                && Object.keys(response.errors).length > 0) {\n                message += ': ' + JSON.stringify(response.errors);\n            }\n            else if (response !== null && typeof response.errorMessages !== 'undefined'\n                && Object.keys(response.errorMessages).length > 0) {\n                message += ': ' + JSON.stringify(response.errorMessages);\n            }\n\n            throw message + ' Check debug log for more information.';\n        }\n\n        return {\n            status: request.Status(),\n            response: response\n        };\n    },\n\n    getSchema: function() {\n        var result = Jira.request('get', 'issue/createmeta?expand=projects.issuetypes.fields&projectKeys=' +\n            encodeURIComponent(Jira.params.project_key) + '&issuetypeNames=' +\n            encodeURIComponent(Jira.params.issue_type));\n\n        return result.response;\n    },\n\n    createIssue: function(summary, description, fields) {\n        var data = {\n            fields: {\n                project: {\n                    key: Jira.params.project_key\n                },\n                issuetype: {\n                    name: Jira.params.issue_type\n                },\n                summary: summary,\n                description: description\n            }\n        };\n\n        if (Jira.labels && Jira.labels.length > 0) {\n            data.fields.labels = Jira.labels;\n        }\n        var result = Jira.request('post', 'issue', Jira.addCustomFields(data, fields));\n\n        if (typeof result.response !== 'object' || typeof result.response.key === 'undefined') {\n            throw 'Cannot create Jira issue. Check debug log for more information.';\n        }\n\n        return result.response.key;\n    },\n\n    updateIssue: function(summary, fields, update) {\n        var data = {fields: {}};\n\n        if (summary) {\n            data.fields.summary = summary;\n        }\n\n        Jira.request('put', 'issue/' + encodeURIComponent(Jira.params.issue_key), Jira.addCustomFields(data, fields));\n        Jira.commentIssue(update);\n    },\n\n    commentIssue: function(update) {\n        var data = {};\n\n        if (typeof update === 'string') {\n            data.body = update;\n            Jira.request('post', 'issue/' + encodeURIComponent(Jira.params.issue_key) + '/comment', data);\n        }\n        else if (update.status === '1') {\n            data.body = update.user + ' ' + update.action + '.';\n\n            if (update.message) {\n                data.body += '\\nMessage: {quote}' + Jira.escapeMarkup(update.message) + '{quote}';\n            }\n\n            Jira.request('post', 'issue/' + encodeURIComponent(Jira.params.issue_key) + '/comment', data);\n        }\n    }\n};\n\ntry {\n    var params = JSON.parse(value),\n        fields = {},\n        jira = {},\n        update = {},\n        result = {tags: {}},\n        required_params = ['alert_subject', 'summary', 'event_recovery_value', 'event_source', 'event_value'];\n\n    Object.keys(params)\n        .forEach(function (key) {\n            if (key.startsWith('jira_')) {\n                jira[key.substring(5)] = params[key];\n            }\n            else if (key.startsWith('customfield_')) {\n                fields[key] = params[key];\n            }\n            else if (key.startsWith('event_update_')) {\n                update[key.substring(13)] = params[key];\n            }\n            else if (required_params.indexOf(key) !== -1 && params[key] === '') {\n                throw 'Parameter \"' + key + '\" can\\'t be empty.';\n            }\n        });\n\n    if ([0, 1, 2, 3].indexOf(parseInt(params.event_source)) === -1) {\n        throw 'Incorrect \"event_source\" parameter given: ' + params.event_source + '\\nMust be 0-3.';\n    }\n\n    // Check {EVENT.VALUE} for trigger-based and internal events.\n    if (params.event_value !== '0' && params.event_value !== '1'\n        && (params.event_source === '0' || params.event_source === '3')) {\n        throw 'Incorrect \"event_value\" parameter given: ' + params.event_value + '\\nMust be 0 or 1.';\n    }\n\n    // Check {EVENT.UPDATE.STATUS} only for trigger-based events.\n    if (params.event_update_status !== '0' && params.event_update_status !== '1' && params.event_source === '0') {\n        throw 'Incorrect \"event_update_status\" parameter given: ' + params.event_update_status + '\\nMust be 0 or 1.';\n    }\n\n    if (params.event_source !== '0' && params.event_recovery_value === '0') {\n        throw 'Recovery operations are supported only for trigger-based actions.';\n    }\n\n    Jira.setParams(jira);\n    Jira.setProxy(params.HTTPProxy);\n    Jira.setTags(params.event_tags_json);\n\n    // Create issue for non trigger-based events.\n    if (params.event_source !== '0' && params.event_recovery_value !== '0') {\n        Jira.createIssue(params.alert_subject, params.alert_message);\n    }\n    // Create issue for trigger-based events.\n    else if (params.event_value === '1' && update.status === '0' && !jira.issue_key.startsWith(jira.project_key)) {\n        var key = Jira.createIssue(params.alert_subject,\n            (Object.keys(fields).length ? params.trigger_description : params.alert_message), fields);\n\n\n        result.tags.__zbx_jira_issuekey = key;\n        result.tags.__zbx_jira_issuelink = params.jira_url +\n            (params.jira_url.endsWith('/') ? '' : '/') + 'browse/' + key;\n    }\n    // Update created issue for trigger-based event.\n    else {\n        if (!jira.issue_key.startsWith(jira.project_key)) {\n            throw 'Incorrect Issue key given: ' + jira.issue_key;\n        }\n        Jira.updateIssue(params.alert_subject, fields,\n            ((params.event_value === '0' && !Object.keys(fields).length)\n                ? params.alert_message : update));\n    }\n\n    return JSON.stringify(result);\n}\ncatch (error) {\n    Zabbix.Log(3, '[ Jira Webhook ] ERROR: ' + error);\n    throw 'Sending failed: ' + error;\n}",
                "process_tags": "YES",
                "show_event_menu": "YES",
                "event_menu_url": "{EVENT.TAGS.__zbx_jira_issuelink}",
                "event_menu_name": "Jira: {EVENT.TAGS.__zbx_jira_issuekey}",
                "message_templates": [
                    {
                        "event_source": "TRIGGERS",
                        "operation_mode": "PROBLEM",
                        "subject": "[{EVENT.STATUS}] {EVENT.NAME}",
                        "message": "Problem started at {EVENT.TIME} on {EVENT.DATE}\nProblem name: {EVENT.NAME}\nHost: {HOST.NAME}\nSeverity: {EVENT.SEVERITY}\nOperational data: {EVENT.OPDATA}\nOriginal problem ID: {EVENT.ID}\n{TRIGGER.URL}"
                    },
                    {
                        "event_source": "TRIGGERS",
                        "operation_mode": "RECOVERY",
                        "subject": "[{EVENT.STATUS}] {EVENT.NAME}",
                        "message": "Problem has been resolved in {EVENT.DURATION} at {EVENT.RECOVERY.TIME} on {EVENT.RECOVERY.DATE}\nProblem name: {EVENT.NAME}\nHost: {HOST.NAME}\nSeverity: {EVENT.SEVERITY}\nOriginal problem ID: {EVENT.ID}\n{TRIGGER.URL}"
                    },
                    {
                        "event_source": "TRIGGERS",
                        "operation_mode": "UPDATE",
                        "subject": "[{EVENT.STATUS}] {EVENT.NAME}",
                        "message": "{USER.FULLNAME} {EVENT.UPDATE.ACTION} problem at {EVENT.UPDATE.DATE} {EVENT.UPDATE.TIME}.\n{EVENT.UPDATE.MESSAGE}\n\nCurrent problem status is {EVENT.STATUS}, acknowledged: {EVENT.ACK.STATUS}."
                    },
                    {
                        "event_source": "DISCOVERY",
                        "operation_mode": "PROBLEM",
                        "subject": "Discovery: {DISCOVERY.DEVICE.STATUS} {DISCOVERY.DEVICE.IPADDRESS}",
                        "message": "Discovery rule: {DISCOVERY.RULE.NAME}\n\nDevice IP: {DISCOVERY.DEVICE.IPADDRESS}\nDevice DNS: {DISCOVERY.DEVICE.DNS}\nDevice status: {DISCOVERY.DEVICE.STATUS}\nDevice uptime: {DISCOVERY.DEVICE.UPTIME}\n\nDevice service name: {DISCOVERY.SERVICE.NAME}\nDevice service port: {DISCOVERY.SERVICE.PORT}\nDevice service status: {DISCOVERY.SERVICE.STATUS}\nDevice service uptime: {DISCOVERY.SERVICE.UPTIME}"
                    },
                    {
                        "event_source": "AUTOREGISTRATION",
                        "operation_mode": "PROBLEM",
                        "subject": "Autoregistration: {HOST.HOST}",
                        "message": "Host name: {HOST.HOST}\nHost IP: {HOST.IP}\nAgent port: {HOST.PORT}"
                    }
                ]
            },
            {
                "name": "Jira ServiceDesk",
                "type": "WEBHOOK",
                "parameters": [
                    {
                        "name": "alert_message",
                        "value": "{ALERT.MESSAGE}"
                    },
                    {
                        "name": "alert_subject",
                        "value": "{ALERT.SUBJECT}"
                    },
                    {
                        "name": "event_recovery_value",
                        "value": "{EVENT.RECOVERY.VALUE}"
                    },
                    {
                        "name": "event_source",
                        "value": "{EVENT.SOURCE}"
                    },
                    {
                        "name": "event_tags_json",
                        "value": "{EVENT.TAGSJSON}"
                    },
                    {
                        "name": "event_update_status",
                        "value": "{EVENT.UPDATE.STATUS}"
                    },
                    {
                        "name": "event_value",
                        "value": "{EVENT.VALUE}"
                    },
                    {
                        "name": "jira_password",
                        "value": "<PLACE PASSWORD OR TOKEN>"
                    },
                    {
                        "name": "jira_request_key",
                        "value": "{EVENT.TAGS.__zbx_jira_requestkey}"
                    },
                    {
                        "name": "jira_request_type_id",
                        "value": "<PLACE REQUEST TYPE ID>"
                    },
                    {
                        "name": "jira_servicedesk_id",
                        "value": "<PLACE SERVICEDESK ID>"
                    },
                    {
                        "name": "jira_url",
                        "value": "<PLACE YOUR JIRA URL>"
                    },
                    {
                        "name": "jira_user",
                        "value": "<PLACE LOGIN>"
                    }
                ],
                "status": "DISABLED",
                "script": "var Jira = {\n    params: {},\n    schema: {},\n\n    setParams: function (params) {\n        if (typeof params !== 'object') {\n            return;\n        }\n\n        Jira.params = params;\n        if (typeof Jira.params.url === 'string') {\n            if (!Jira.params.url.endsWith('/')) {\n                Jira.params.url += '/';\n            }\n\n            Jira.params.url += 'rest/servicedeskapi/latest/';\n        }\n    },\n\n    setProxy: function (HTTPProxy) {\n        Jira.HTTPProxy = HTTPProxy;\n    },\n\n    setTags: function(event_tags_json) {\n        if (!Jira.schema) {\n            Zabbix.Log(4, '[ Jira Service Desk Webhook ] Cannot add labels because failed to retrieve field schema.');\n\n            return;\n        }\n\n        var block = Jira.schema.requestTypeFields.filter(function(object) {\n            return object.fieldId == 'labels';\n        });\n\n        if (block[0] && typeof event_tags_json !== 'undefined' && event_tags_json !== ''\n            && event_tags_json !== '{EVENT.TAGSJSON}') {\n            try {\n                var tags = JSON.parse(event_tags_json),\n                    label;\n\n                Jira.labels = [];\n\n                tags.forEach(function (tag) {\n                    if (typeof tag.tag !== 'undefined' && typeof tag.value !== 'undefined' ) {\n                        label = (tag.tag + (tag.value ? (':' + tag.value) : '')).replace(/\\s/g, '_');\n                        if (label.length < 255) {\n                            Jira.labels.push(label);\n                        }\n                    }\n                });\n            }\n            catch (error) {\n                // Code is not missing here.\n            }\n        }\n    },\n\n    addCustomFields: function (data, fields) {\n        if (typeof fields === 'object' && Object.keys(fields).length) {\n            if (Jira.schema) {\n                Object.keys(fields)\n                    .forEach(function(field) {\n                        data.requestFieldValues[field] = fields[field];\n\n                        var block = Jira.schema.requestTypeFields.filter(function(object) {\n                            return object.fieldId == field;\n                        });\n\n                        if (typeof block[0] === 'object' && typeof block[0].jiraSchema === 'object'\n                            && (block[0].jiraSchema.type === 'number' || block[0].jiraSchema.type === 'datetime')) {\n                            switch (block[0].jiraSchema.type) {\n                                case 'number':\n                                    data.requestFieldValues[field] = parseInt(fields[field]);\n                                    break;\n\n                                case 'datetime':\n                                    if (fields[field].match(/\\d+[.-]\\d+[.-]\\d+T\\d+:\\d+:\\d+/) !== null) {\n                                        data.requestFieldValues[field] = fields[field].replace(/\\./g, '-');\n                                    }\n                                    else {\n                                        delete data.requestFieldValues[field];\n                                    }\n                                    break;\n                            }\n                        }\n                    });\n            }\n            else {\n                Zabbix.Log(4, '[ Jira Service Desk Webhook ] Cannot add custom fields' +\n                    'because failed to retrieve field schema.');\n            }\n        }\n\n        return data;\n    },\n\n    request: function (method, query, data) {\n        ['url', 'user', 'password', 'servicedesk_id', 'request_type_id'].forEach(function (field) {\n            if (typeof Jira.params !== 'object' || typeof Jira.params[field] === 'undefined'\n                || Jira.params[field] === '' ) {\n                throw 'Required Jira param is not set: \"' + field + '\".';\n            }\n        });\n\n        var response,\n            url = Jira.params.url + query,\n            request = new CurlHttpRequest();\n\n        request.AddHeader('Content-Type: application/json');\n        request.AddHeader('Authorization: Basic ' + btoa(Jira.params.user + ':' + Jira.params.password));\n        request.AddHeader('X-ExperimentalApi: opt-in');\n\n        if (typeof Jira.HTTPProxy !== 'undefined' && Jira.HTTPProxy !== '') {\n            request.SetProxy(Jira.HTTPProxy);\n        }\n\n        if (typeof data !== 'undefined') {\n            data = JSON.stringify(data);\n        }\n\n        Zabbix.Log(4, '[ Jira Service Desk Webhook ] Sending request: ' + url +\n            ((typeof data === 'string') ? ('\\n' + data) : ''));\n\n        switch (method) {\n            case 'get':\n                response = request.Get(url, data);\n                break;\n\n            case 'post':\n                response = request.Post(url, data);\n                break;\n\n            case 'put':\n                response = request.Put(url, data);\n                break;\n\n            default:\n                throw 'Unsupported HTTP request method: ' + method;\n        }\n\n        Zabbix.Log(4, '[ Jira Service Desk Webhook ] Received response with status code ' +\n            request.Status() + '\\n' + response);\n\n        if (response !== null) {\n            try {\n                response = JSON.parse(response);\n            }\n            catch (error) {\n                Zabbix.Log(4, '[ Jira Service Desk Webhook ] Failed to parse response received from Jira');\n                response = null;\n            }\n        }\n\n        if (request.Status() < 200 || request.Status() >= 300) {\n            var message = 'Request failed with status code ' + request.Status();\n\n            if (response !== null && typeof response.errors !== 'undefined'\n                && Object.keys(response.errors).length > 0) {\n                message += ': ' + JSON.stringify(response.errors);\n            }\n            else if (response !== null && typeof response.errorMessage !== 'undefined'\n                && Object.keys(response.errorMessage).length > 0) {\n                message += ': ' + JSON.stringify(response.errorMessage);\n            }\n\n            throw message + ' Check debug log for more information.';\n        }\n\n        return {\n            status: request.Status(),\n            response: response\n        };\n    },\n\n    getSchema: function() {\n        var result = Jira.request('get', 'servicedesk/' + Jira.params.servicedesk_id + '/requesttype/' +\n            Jira.params.request_type_id + '/field');\n\n        if (typeof Jira.schema !== 'object' && typeof Jira.schema.requestTypeFields !== 'object') {\n            Jira.schema = null;\n        }\n        else {\n            Jira.schema = result.response;\n        }\n    },\n\n    createRequest: function(summary, description, fields) {\n        var data = {\n            serviceDeskId: Jira.params.servicedesk_id,\n            requestTypeId: Jira.params.request_type_id,\n            requestFieldValues: {\n                summary: summary,\n                description: description\n            }\n        };\n\n        if (Jira.labels && Jira.labels.length > 0) {\n            data.requestFieldValues.labels = Jira.labels;\n        }\n        var result = Jira.request('post', 'request', Jira.addCustomFields(data, fields));\n\n        if (typeof result.response !== 'object' || typeof result.response.issueKey === 'undefined') {\n            throw 'Cannot create Jira request. Check debug log for more information.';\n        }\n\n        return result.response.issueKey;\n    }\n};\n\ntry {\n    var params = JSON.parse(value),\n        fields = {},\n        jira = {},\n        comment = {public: true},\n        result = {tags: {}},\n        required_params = [\n            'alert_subject', 'alert_message', 'event_source', 'event_value',\n            'event_update_status', 'event_recovery_value'\n        ];\n\n    Object.keys(params)\n        .forEach(function (key) {\n            if (key.startsWith('jira_')) {\n                jira[key.substring(5)] = params[key];\n            }\n            else if (key.startsWith('customfield_')) {\n                fields[key] = params[key];\n            }\n            else if (required_params.indexOf(key) !== -1 && params[key] === '') {\n                throw 'Parameter \"' + key + '\" cannot be empty.';\n            }\n        });\n\n    if ([0, 1, 2, 3].indexOf(parseInt(params.event_source)) === -1) {\n        throw 'Incorrect \"event_source\" parameter given: ' + params.event_source + '\\nMust be 0-3.';\n    }\n\n    // Check {EVENT.VALUE} for trigger-based and internal events.\n    if (params.event_value !== '0' && params.event_value !== '1'\n        && (params.event_source === '0' || params.event_source === '3')) {\n        throw 'Incorrect \"event_value\" parameter given: ' + params.event_value + '\\nMust be 0 or 1.';\n    }\n\n    // Check {EVENT.UPDATE.STATUS} only for trigger-based events.\n    if (params.event_update_status !== '0' && params.event_update_status !== '1' && params.event_source === '0') {\n        throw 'Incorrect \"event_update_status\" parameter given: ' + params.event_update_status + '\\nMust be 0 or 1.';\n    }\n\n    if (params.event_source !== '0' && params.event_recovery_value === '0') {\n        throw 'Recovery operations are supported only for trigger-based actions.';\n    }\n\n    Jira.setParams(jira);\n    Jira.setProxy(params.HTTPProxy);\n    Jira.getSchema();\n    Jira.setTags(params.event_tags_json);\n\n    // Create request for non trigger-based events.\n    if (params.event_source !== '0' && params.event_recovery_value !== '0') {\n        Jira.createRequest(params.alert_subject, params.alert_message);\n    }\n    // Create request for trigger-based events.\n    else if (params.event_value === '1' && params.event_update_status === '0'\n        && jira.request_key === '{EVENT.TAGS.__zbx_jira_requestkey}') {\n        var key = Jira.createRequest(params.alert_subject, params.alert_message, fields);\n\n        result.tags.__zbx_jira_requestkey = key;\n        result.tags.__zbx_jira_requestlink = params.jira_url +\n            (params.jira_url.endsWith('/') ? '' : '/') + 'browse/' + key;\n    }\n    // Comment created request for trigger-based event.\n    else {\n        if (jira.request_key === '{EVENT.TAGS.__zbx_jira_requestkey}' || jira.request_key.trim() === '') {\n            throw 'Incorrect Request key given: ' + jira.request_key;\n        }\n        comment.body = params.alert_message;\n        Jira.request('post', 'request/' + Jira.params.request_key + '/comment', comment);\n    }\n\n    return JSON.stringify(result);\n}\ncatch (error) {\n    Zabbix.Log(3, '[ Jira Service Desk Webhook ] ERROR: ' + error);\n    throw 'Sending failed: ' + error;\n}",
                "process_tags": "YES",
                "show_event_menu": "YES",
                "event_menu_url": "{EVENT.TAGS.__zbx_jira_requestlink}",
                "event_menu_name": "Jira ServiceDesk: {EVENT.TAGS.__zbx_jira_requestkey}",
                "message_templates": [
                    {
                        "event_source": "TRIGGERS",
                        "operation_mode": "PROBLEM",
                        "subject": "{EVENT.NAME}",
                        "message": "Problem started at {EVENT.TIME} on {EVENT.DATE}\nProblem name: {EVENT.NAME}\nHost: {HOST.NAME}\nSeverity: {EVENT.SEVERITY}\nOperational data: {EVENT.OPDATA}\nOriginal problem ID: {EVENT.ID}\n{TRIGGER.URL}"
                    },
                    {
                        "event_source": "TRIGGERS",
                        "operation_mode": "RECOVERY",
                        "subject": "{EVENT.NAME}",
                        "message": "Problem has been resolved in {EVENT.DURATION} at {EVENT.RECOVERY.TIME} on {EVENT.RECOVERY.DATE}\nProblem name: {EVENT.NAME}\nHost: {HOST.NAME}\nSeverity: {EVENT.SEVERITY}\nOriginal problem ID: {EVENT.ID}\n{TRIGGER.URL}"
                    },
                    {
                        "event_source": "TRIGGERS",
                        "operation_mode": "UPDATE",
                        "subject": "{EVENT.NAME}",
                        "message": "{USER.FULLNAME} {EVENT.UPDATE.ACTION} problem at {EVENT.UPDATE.DATE} {EVENT.UPDATE.TIME}.\n{EVENT.UPDATE.MESSAGE}\n\nCurrent problem status is {EVENT.STATUS}, acknowledged: {EVENT.ACK.STATUS}."
                    },
                    {
                        "event_source": "DISCOVERY",
                        "operation_mode": "PROBLEM",
                        "subject": "Discovery: {DISCOVERY.DEVICE.STATUS} {DISCOVERY.DEVICE.IPADDRESS}",
                        "message": "Discovery rule: {DISCOVERY.RULE.NAME}\n\nDevice IP: {DISCOVERY.DEVICE.IPADDRESS}\nDevice DNS: {DISCOVERY.DEVICE.DNS}\nDevice status: {DISCOVERY.DEVICE.STATUS}\nDevice uptime: {DISCOVERY.DEVICE.UPTIME}\n\nDevice service name: {DISCOVERY.SERVICE.NAME}\nDevice service port: {DISCOVERY.SERVICE.PORT}\nDevice service status: {DISCOVERY.SERVICE.STATUS}\nDevice service uptime: {DISCOVERY.SERVICE.UPTIME}"
                    },
                    {
                        "event_source": "AUTOREGISTRATION",
                        "operation_mode": "PROBLEM",
                        "subject": "Autoregistration: {HOST.HOST}",
                        "message": "Host name: {HOST.HOST}\nHost IP: {HOST.IP}\nAgent port: {HOST.PORT}"
                    }
                ]
            },
            {
                "name": "Jira with CustomFields",
                "type": "WEBHOOK",
                "parameters": [
                    {
                        "name": "<'DATETIME' CUSTOMFIELD FOR EVENT RECOVERY TIME>",
                        "value": "{EVENT.RECOVERY.DATE}T{EVENT.RECOVERY.TIME}"
                    },
                    {
                        "name": "<'DATETIME' CUSTOMFIELD FOR EVENT TIME>",
                        "value": "{EVENT.DATE}T{EVENT.TIME}"
                    },
                    {
                        "name": "<'NUMBER' CUSTOMFIELD FOR EVENT.ID>",
                        "value": "{EVENT.ID}"
                    },
                    {
                        "name": "<'NUMBER' CUSTOMFIELD FOR TRIGGER.ID>",
                        "value": "{TRIGGER.ID}"
                    },
                    {
                        "name": "<'STRING' CUSTOMFIELD FOR HOST\\IP>",
                        "value": "{HOST.HOST} [{HOST.IP}]"
                    },
                    {
                        "name": "<'STRING' CUSTOMFIELD FOR OPERATIONAL DATA>",
                        "value": "{EVENT.OPDATA}"
                    },
                    {
                        "name": "<'STRING' CUSTOMFIELD FOR SEVERITY>",
                        "value": "{EVENT.SEVERITY}"
                    },
                    {
                        "name": "<'URL' CUSTOMFIELD FOR EVENT URL>",
                        "value": "{$ZABBIX.URL}/tr_events.php?triggerid={TRIGGER.ID}&eventid={EVENT.ID}"
                    },
                    {
                        "name": "alert_message",
                        "value": "{ALERT.MESSAGE}"
                    },
                    {
                        "name": "alert_subject",
                        "value": "{ALERT.SUBJECT}"
                    },
                    {
                        "name": "event_recovery_value",
                        "value": "{EVENT.RECOVERY.VALUE}"
                    },
                    {
                        "name": "event_source",
                        "value": "{EVENT.SOURCE}"
                    },
                    {
                        "name": "event_tags_json",
                        "value": "{EVENT.TAGSJSON}"
                    },
                    {
                        "name": "event_update_action",
                        "value": "{EVENT.UPDATE.ACTION}"
                    },
                    {
                        "name": "event_update_message",
                        "value": "{EVENT.UPDATE.MESSAGE}"
                    },
                    {
                        "name": "event_update_status",
                        "value": "{EVENT.UPDATE.STATUS}"
                    },
                    {
                        "name": "event_update_user",
                        "value": "{USER.FULLNAME}"
                    },
                    {
                        "name": "event_value",
                        "value": "{EVENT.VALUE}"
                    },
                    {
                        "name": "jira_issue_key",
                        "value": "{EVENT.TAGS.__zbx_jira_issuekey}"
                    },
                    {
                        "name": "jira_issue_type",
                        "value": "<PLACE ISSUETYPE NAME>"
                    },
                    {
                        "name": "jira_password",
                        "value": "<PLACE PASSWORD OR TOKEN>"
                    },
                    {
                        "name": "jira_project_key",
                        "value": "<PLACE PROJECT KEY>"
                    },
                    {
                        "name": "jira_url",
                        "value": "<PLACE YOUR JIRA URL>"
                    },
                    {
                        "name": "jira_user",
                        "value": "<PLACE LOGIN>"
                    },
                    {
                        "name": "trigger_description",
                        "value": "{TRIGGER.DESCRIPTION}"
                    }
                ],
                "status": "DISABLED",
                "script": "var Jira = {\n    params: {},\n\n    setParams: function (params) {\n        if (typeof params !== 'object') {\n            return;\n        }\n\n        Jira.params = params;\n        if (typeof Jira.params.url === 'string') {\n            if (!Jira.params.url.endsWith('/')) {\n                Jira.params.url += '/';\n            }\n\n            Jira.params.url += 'rest/api/latest/';\n        }\n    },\n\n    setProxy: function (HTTPProxy) {\n        Jira.HTTPProxy = HTTPProxy;\n    },\n\n    setTags: function(event_tags_json) {\n        if (typeof event_tags_json !== 'undefined' && event_tags_json !== ''\n            && event_tags_json !== '{EVENT.TAGSJSON}') {\n            try {\n                var tags = JSON.parse(event_tags_json),\n                    label;\n\n                Jira.labels = [];\n\n                tags.forEach(function (tag) {\n                    if (typeof tag.tag !== 'undefined' && typeof tag.value !== 'undefined' ) {\n                        label = (tag.tag + (tag.value ? (':' + tag.value) : '')).replace(/\\s/g, '_');\n                        if (label.length < 256) {\n                            Jira.labels.push(label);\n                        }\n                    }\n                });\n            }\n            catch (error) {\n                // Code is not missing here.\n            }\n        }\n    },\n\n    escapeMarkup: function (str) {\n        var length = str.length,\n            result = '',\n            markup = ['{', '|', '}', '~', '_', '\\\\', '[', ']', '^', '<', '>', '?', '!', '#', '+', '*', '&'];\n\n        for (var i = 0; i < length; i++) {\n            var char = str[i];\n\n            result += (markup.indexOf(char) !== -1) ? ('&#' + str[i].charCodeAt() + ';') : char;\n        }\n\n        return result;\n    },\n\n    addCustomFields: function (data, fields) {\n        if (typeof fields === 'object' && Object.keys(fields).length) {\n            var schema = Jira.getSchema(),\n                path = ['projects', 0, 'issuetypes', 0, 'fields'],\n                field;\n\n            while ((field = path.shift()) !== undefined) {\n                schema = schema[field];\n                if (typeof schema === 'undefined') {\n                    schema = null;\n                    break;\n                }\n            }\n\n            if (schema) {\n                Object.keys(fields)\n                    .forEach(function(field) {\n                        data.fields[field] = fields[field];\n\n                        if (typeof schema[field] === 'object' && typeof schema[field].schema === 'object'\n                            && (schema[field].schema.type === 'number' || schema[field].schema.type === 'datetime')) {\n                            switch (schema[field].schema.type) {\n                                case 'number':\n                                    data.fields[field] = parseInt(fields[field]);\n                                    break;\n\n                                case 'datetime':\n                                    if (fields[field].match(/\\d+[.-]\\d+[.-]\\d+T\\d+:\\d+:\\d+/) !== null) {\n                                        data.fields[field] = fields[field].replace(/\\./g, '-');\n                                    }\n                                    else {\n                                        delete data.fields[field];\n                                    }\n                                    break;\n                            }\n                        }\n                    });\n            }\n            else {\n                Zabbix.Log(4, '[ Jira Webhook ] Failed to retrieve field schema.');\n            }\n        }\n\n        return data;\n    },\n\n    request: function (method, query, data) {\n        ['url', 'user', 'password', 'project_key', 'issue_type'].forEach(function (field) {\n            if (typeof Jira.params !== 'object' || typeof Jira.params[field] === 'undefined'\n                || Jira.params[field] === '' ) {\n                throw 'Required Jira param is not set: \"' + field + '\".';\n            }\n        });\n\n        var response,\n            url = Jira.params.url + query,\n            request = new CurlHttpRequest();\n\n        request.AddHeader('Content-Type: application/json');\n        request.AddHeader('Authorization: Basic ' + btoa(Jira.params.user + ':' + Jira.params.password));\n\n        if (typeof Jira.HTTPProxy !== 'undefined' && Jira.HTTPProxy !== '') {\n            request.SetProxy(Jira.HTTPProxy);\n        }\n\n        if (typeof data !== 'undefined') {\n            data = JSON.stringify(data);\n        }\n\n        Zabbix.Log(4, '[ Jira Webhook ] Sending request: ' + url + ((typeof data === 'string') ? ('\\n' + data) : ''));\n\n        switch (method) {\n            case 'get':\n                response = request.Get(url, data);\n                break;\n\n            case 'post':\n                response = request.Post(url, data);\n                break;\n\n            case 'put':\n                response = request.Put(url, data);\n                break;\n\n            default:\n                throw 'Unsupported HTTP request method: ' + method;\n        }\n\n        Zabbix.Log(4, '[ Jira Webhook ] Received response with status code ' + request.Status() + '\\n' + response);\n\n        if (response !== null) {\n            try {\n                response = JSON.parse(response);\n            }\n            catch (error) {\n                Zabbix.Log(4, '[ Jira Webhook ] Failed to parse response received from Jira');\n                response = null;\n            }\n        }\n\n        if (request.Status() < 200 || request.Status() >= 300) {\n            var message = 'Request failed with status code ' + request.Status();\n\n            if (response !== null && typeof response.errors !== 'undefined'\n                && Object.keys(response.errors).length > 0) {\n                message += ': ' + JSON.stringify(response.errors);\n            }\n            else if (response !== null && typeof response.errorMessages !== 'undefined'\n                && Object.keys(response.errorMessages).length > 0) {\n                message += ': ' + JSON.stringify(response.errorMessages);\n            }\n\n            throw message + ' Check debug log for more information.';\n        }\n\n        return {\n            status: request.Status(),\n            response: response\n        };\n    },\n\n    getSchema: function() {\n        var result = Jira.request('get', 'issue/createmeta?expand=projects.issuetypes.fields&projectKeys=' +\n                Jira.params.project_key + '&issuetypeNames=' + Jira.params.issue_type);\n\n        return result.response;\n    },\n\n    createIssue: function(summary, description, fields) {\n        var data = {\n            fields: {\n                project: {\n                    key: Jira.params.project_key\n                },\n                issuetype: {\n                    name: Jira.params.issue_type\n                },\n                summary: summary,\n                description: description\n            }\n        };\n\n        if (Jira.labels && Jira.labels.length > 0) {\n            data.fields.labels = Jira.labels;\n        }\n        var result = Jira.request('post', 'issue', Jira.addCustomFields(data, fields));\n\n        if (typeof result.response !== 'object' || typeof result.response.key === 'undefined') {\n            throw 'Cannot create Jira issue. Check debug log for more information.';\n        }\n\n        return result.response.key;\n    },\n\n    updateIssue: function(summary, fields, update) {\n        var data = {fields: {}};\n\n        if (summary) {\n            data.fields.summary = summary;\n        }\n\n        Jira.request('put', 'issue/' + Jira.params.issue_key, Jira.addCustomFields(data, fields));\n        Jira.commentIssue(update);\n    },\n\n    commentIssue: function(update) {\n        var data = {};\n\n        if (typeof update === 'string') {\n            data.body = update;\n            Jira.request('post', 'issue/' + Jira.params.issue_key + '/comment', data);\n        }\n        else if (update.status === '1') {\n            data.body = update.user + ' ' + update.action + '.';\n\n            if (update.message) {\n                data.body += '\\nMessage: {quote}' + Jira.escapeMarkup(update.message) + '{quote}';\n            }\n\n            Jira.request('post', 'issue/' + Jira.params.issue_key + '/comment', data);\n        }\n    }\n};\n\ntry {\n    var params = JSON.parse(value),\n        fields = {},\n        jira = {},\n        update = {},\n        result = {tags: {}},\n        required_params = ['alert_subject', 'summary', 'event_recovery_value', 'event_source', 'event_value'];\n\n    Object.keys(params)\n        .forEach(function (key) {\n            if (key.startsWith('jira_')) {\n                jira[key.substring(5)] = params[key];\n            }\n            else if (key.startsWith('customfield_')) {\n                fields[key] = params[key];\n            }\n            else if (key.startsWith('event_update_')) {\n                update[key.substring(13)] = params[key];\n            }\n            else if (required_params.indexOf(key) !== -1 && params[key] === '') {\n                throw 'Parameter \"' + key + '\" can\\'t be empty.';\n            }\n        });\n\n    if ([0, 1, 2, 3].indexOf(parseInt(params.event_source)) === -1) {\n        throw 'Incorrect \"event_source\" parameter given: ' + params.event_source + '\\nMust be 0-3.';\n    }\n\n    // Check {EVENT.VALUE} for trigger-based and internal events.\n    if (params.event_value !== '0' && params.event_value !== '1'\n        && (params.event_source === '0' || params.event_source === '3')) {\n        throw 'Incorrect \"event_value\" parameter given: ' + params.event_value + '\\nMust be 0 or 1.';\n    }\n\n    // Check {EVENT.UPDATE.STATUS} only for trigger-based events.\n    if (params.event_update_status !== '0' && params.event_update_status !== '1' && params.event_source === '0') {\n        throw 'Incorrect \"event_update_status\" parameter given: ' + params.event_update_status + '\\nMust be 0 or 1.';\n    }\n\n    if (params.event_source !== '0' && params.event_recovery_value === '0') {\n        throw 'Recovery operations are supported only for trigger-based actions.';\n    }\n\n    Jira.setParams(jira);\n    Jira.setProxy(params.HTTPProxy);\n    Jira.setTags(params.event_tags_json);\n\n    // Create issue for non trigger-based events.\n    if (params.event_source !== '0' && params.event_recovery_value !== '0') {\n        Jira.createIssue(params.alert_subject, params.alert_message);\n    }\n    // Create issue for trigger-based events.\n    else if (params.event_value === '1' && update.status === '0' && !jira.issue_key.startsWith(jira.project_key)) {\n        var key = Jira.createIssue(params.alert_subject,\n            (Object.keys(fields).length ? params.trigger_description : params.alert_message), fields);\n\n\n        result.tags.__zbx_jira_issuekey = key;\n        result.tags.__zbx_jira_issuelink = params.jira_url +\n            (params.jira_url.endsWith('/') ? '' : '/') + 'browse/' + key;\n    }\n    // Update created issue for trigger-based event.\n    else {\n        if (!jira.issue_key.startsWith(jira.project_key)) {\n            throw 'Incorrect Issue key given: ' + jira.issue_key;\n        }\n        Jira.updateIssue(params.alert_subject, fields,\n            ((params.event_value === '0' && !Object.keys(fields).length)\n                ? params.alert_message : update));\n    }\n\n    return JSON.stringify(result);\n}\ncatch (error) {\n    Zabbix.Log(3, '[ Jira Webhook ] ERROR: ' + error);\n    throw 'Sending failed: ' + error;\n}",
                "process_tags": "YES",
                "show_event_menu": "YES",
                "event_menu_url": "{EVENT.TAGS.__zbx_jira_issuelink}",
                "event_menu_name": "Jira: {EVENT.TAGS.__zbx_jira_issuekey}",
                "message_templates": [
                    {
                        "event_source": "TRIGGERS",
                        "operation_mode": "PROBLEM",
                        "subject": "[{EVENT.STATUS}] {EVENT.NAME}",
                        "message": "Problem started at {EVENT.TIME} on {EVENT.DATE}\nProblem name: {EVENT.NAME}\nHost: {HOST.NAME}\nSeverity: {EVENT.SEVERITY}\nOperational data: {EVENT.OPDATA}\nOriginal problem ID: {EVENT.ID}\n{TRIGGER.URL}"
                    },
                    {
                        "event_source": "TRIGGERS",
                        "operation_mode": "RECOVERY",
                        "subject": "[{EVENT.STATUS}] {EVENT.NAME}",
                        "message": "Problem has been resolved in {EVENT.DURATION} at {EVENT.RECOVERY.TIME} on {EVENT.RECOVERY.DATE}\nProblem name: {EVENT.NAME}\nHost: {HOST.NAME}\nSeverity: {EVENT.SEVERITY}\nOriginal problem ID: {EVENT.ID}\n{TRIGGER.URL}"
                    },
                    {
                        "event_source": "TRIGGERS",
                        "operation_mode": "UPDATE",
                        "subject": "[{EVENT.STATUS}] {EVENT.NAME}",
                        "message": "{USER.FULLNAME} {EVENT.UPDATE.ACTION} problem at {EVENT.UPDATE.DATE} {EVENT.UPDATE.TIME}.\n{EVENT.UPDATE.MESSAGE}\n\nCurrent problem status is {EVENT.STATUS}, acknowledged: {EVENT.ACK.STATUS}."
                    },
                    {
                        "event_source": "DISCOVERY",
                        "operation_mode": "PROBLEM",
                        "subject": "Discovery: {DISCOVERY.DEVICE.STATUS} {DISCOVERY.DEVICE.IPADDRESS}",
                        "message": "Discovery rule: {DISCOVERY.RULE.NAME}\n\nDevice IP: {DISCOVERY.DEVICE.IPADDRESS}\nDevice DNS: {DISCOVERY.DEVICE.DNS}\nDevice status: {DISCOVERY.DEVICE.STATUS}\nDevice uptime: {DISCOVERY.DEVICE.UPTIME}\n\nDevice service name: {DISCOVERY.SERVICE.NAME}\nDevice service port: {DISCOVERY.SERVICE.PORT}\nDevice service status: {DISCOVERY.SERVICE.STATUS}\nDevice service uptime: {DISCOVERY.SERVICE.UPTIME}"
                    },
                    {
                        "event_source": "AUTOREGISTRATION",
                        "operation_mode": "PROBLEM",
                        "subject": "Autoregistration: {HOST.HOST}",
                        "message": "Host name: {HOST.HOST}\nHost IP: {HOST.IP}\nAgent port: {HOST.PORT}"
                    }
                ]
            },
            {
                "name": "Mattermost",
                "type": "WEBHOOK",
                "parameters": {
                    "22": {
                        "name": "alert_message",
                        "value": "{ALERT.MESSAGE}"
                    },
                    "23": {
                        "name": "alert_subject",
                        "value": "{ALERT.SUBJECT}"
                    },
                    "1": {
                        "name": "bot_token",
                        "value": "<YOUR BOT TOKEN>"
                    },
                    "24": {
                        "name": "discovery_host_dns",
                        "value": "{DISCOVERY.DEVICE.DNS}"
                    },
                    "25": {
                        "name": "discovery_host_ip",
                        "value": "{DISCOVERY.DEVICE.IPADDRESS}"
                    },
                    "9": {
                        "name": "event_date",
                        "value": "{EVENT.DATE}"
                    },
                    "13": {
                        "name": "event_id",
                        "value": "{EVENT.ID}"
                    },
                    "6": {
                        "name": "event_nseverity",
                        "value": "{EVENT.NSEVERITY}"
                    },
                    "12": {
                        "name": "event_opdata",
                        "value": "{EVENT.OPDATA}"
                    },
                    "20": {
                        "name": "event_recovery_date",
                        "value": "{EVENT.RECOVERY.DATE}"
                    },
                    "21": {
                        "name": "event_recovery_time",
                        "value": "{EVENT.RECOVERY.TIME}"
                    },
                    "11": {
                        "name": "event_severity",
                        "value": "{EVENT.SEVERITY}"
                    },
                    "26": {
                        "name": "event_source",
                        "value": "{EVENT.SOURCE}"
                    },
                    "5": {
                        "name": "event_tags",
                        "value": "{EVENT.TAGS}"
                    },
                    "10": {
                        "name": "event_time",
                        "value": "{EVENT.TIME}"
                    },
                    "18": {
                        "name": "event_update_date",
                        "value": "{EVENT.UPDATE.DATE}"
                    },
                    "8": {
                        "name": "event_update_status",
                        "value": "{EVENT.UPDATE.STATUS}"
                    },
                    "19": {
                        "name": "event_update_time",
                        "value": "{EVENT.UPDATE.TIME}"
                    },
                    "7": {
                        "name": "event_value",
                        "value": "{EVENT.VALUE}"
                    },
                    "17": {
                        "name": "host_ip",
                        "value": "{HOST.IP}"
                    },
                    "16": {
                        "name": "host_name",
                        "value": "{HOST.HOST}"
                    },
                    "2": {
                        "name": "mattermost_url",
                        "value": "<YOUR MATTERMOST URL>"
                    },
                    "3": {
                        "name": "send_mode",
                        "value": "alarm"
                    },
                    "4": {
                        "name": "send_to",
                        "value": "{ALERT.SENDTO}"
                    },
                    "15": {
                        "name": "trigger_description",
                        "value": "{TRIGGER.DESCRIPTION}"
                    },
                    "14": {
                        "name": "trigger_id",
                        "value": "{TRIGGER.ID}"
                    },
                    "0": {
                        "name": "zabbix_url",
                        "value": "{$ZABBIX.URL}"
                    }
                },
                "status": "DISABLED",
                "attempts": "1",
                "script": "var SEVERITY_COLORS = [\n    '#97AAB3', '#7499FF', '#FFC859',\n    '#FFA059', '#E97659', '#E45959'\n];\n\nvar RESOLVE_COLOR = '#009900';\n\nvar SEND_MODE_HANDLERS = {\n    alarm: handlerAlarm,\n    event: handlerEvent\n};\n\nif (!String.prototype.format) {\n    String.prototype.format = function() {\n        var args = arguments;\n\n        return this.replace(/{(\\d+)}/g, function(match, number) {\n            return number in args\n                ? args[number]\n                : match\n            ;\n        });\n    };\n}\n\nfunction isEventProblem(params) {\n    return params.event_value == 1\n        && params.event_update_status == 0\n    ;\n}\n\nfunction isEventUpdate(params) {\n    return params.event_value == 1\n        && params.event_update_status == 1\n    ;\n}\n\nfunction isEventResolve(params) {\n    return params.event_value == 0;\n}\n\nfunction getPermalink(mattermost_url, team_name, postid) {\n    return '{0}/{1}/pl/{2}'.format(\n        mattermost_url.replace(/\\/+$/, ''),\n        team_name,\n        postid\n    );\n}\n\nfunction getChannel(send_to) {\n    switch (true) {\n        case /.+\\/#.+/.test(send_to):\n            return getChannelByName(send_to);\n\n        case /@.+/.test(send_to):\n            return getDirectChannel(send_to);\n\n        default:\n            return getChannelByID(send_to);\n    }\n}\n\nfunction getChannelByName(send_to) {\n    var team_chan = send_to\n        .trim()\n        .split('/#');\n\n    var resp = JSON.parse(req.Get(\n        Mattermost.channel_byname.format(team_chan[0], team_chan[1]),\n        JSON.stringify(fields)\n    )\n    );\n\n    if (req.Status() != 200) {\n        throw '[{0}] {1}'.format(resp.status_code, resp.message);\n    }\n\n    return resp;\n}\n\nfunction getDirectChannel(send_to) {\n    Zabbix.Log(5, '[ Mattermost Webhook ] Call {0}({1})'.format(\n        arguments.callee.name,\n        JSON.stringify(arguments)\n    ));\n\n    var teamUser = send_to\n            .trim()\n            .split('/@'),\n        bot = getBotUser(),\n        user = getUserByName(teamUser[1]);\n\n    var resp = JSON.parse(req.Post(\n        Mattermost.direct_channel,\n        JSON.stringify([bot.id, user.id])\n    )\n    );\n\n    Zabbix.Log(5, '[ Mattermost Webhook ] Result {0}: {1}'.format(\n        arguments.callee.name,\n        JSON.stringify(resp)\n    ));\n\n    if (req.Status() != 201) {\n        throw '[{0}] {1}'.format(resp.status_code, resp.message);\n    }\n\n    resp.team_name = teamUser[0];\n\n    return resp;\n}\n\nfunction getChannelByID(channelID) {\n    Zabbix.Log(5, '[ Mattermost Webhook ] Call {0}({1})'.format(\n        arguments.callee.name,\n        JSON.stringify(arguments)\n    ));\n\n    var resp = JSON.parse(req.Get(\n        Mattermost.get_channel.format(channelID),\n        JSON.stringify(fields)\n    )\n    );\n\n    Zabbix.Log(5, '[ Mattermost Webhook ] Result {0}: {1}'.format(\n        arguments.callee.name,\n        JSON.stringify(resp)\n    ));\n\n    if (req.Status() != 200) {\n        throw '[{0}] {1}'.format(resp.status_code, resp.message);\n    }\n\n    return resp;\n}\n\nfunction getBotUser() {\n    Zabbix.Log(5, '[ Mattermost Webhook ] Call {0}({1})'.format(\n        arguments.callee.name,\n        JSON.stringify(arguments)\n    ));\n\n    var resp = JSON.parse(req.Get(\n        Mattermost.bot_user,\n        JSON.stringify(fields)\n    )\n    );\n\n    Zabbix.Log(5, '[ Mattermost Webhook ] Result {0}: {1}'.format(\n        arguments.callee.name,\n        JSON.stringify(resp)\n    ));\n\n    if (req.Status() != 200) {\n        throw '[{0}] {1}'.format(resp.status_code, resp.message);\n    }\n\n    return resp;\n}\n\nfunction getUserByName(userName) {\n    Zabbix.Log(5, '[ Mattermost Webhook ] Call {0}({1})'.format(\n        arguments.callee.name,\n        JSON.stringify(arguments)\n    ));\n\n    var resp = JSON.parse(req.Get(\n        Mattermost.user_byname.format(userName),\n        JSON.stringify(fields)\n    )\n    );\n\n    Zabbix.Log(5, '[ Mattermost Webhook ] Result {0}: {1}'.format(\n        arguments.callee.name,\n        JSON.stringify(resp)\n    ));\n\n    if (req.Status() != 200) {\n        throw '[{0}] {1}'.format(resp.status_code, resp.message);\n    }\n\n    return resp;\n}\n\nfunction getTeamByID(teamID) {\n    Zabbix.Log(5, '[ Mattermost Webhook ] Call {0}({1})'.format(\n        arguments.callee.name,\n        JSON.stringify(arguments)\n    ));\n\n    var resp = JSON.parse(req.Get(\n        Mattermost.get_team.format(teamID),\n        JSON.stringify(fields)\n    )\n    );\n\n    Zabbix.Log(5, '[ Mattermost Webhook ] Result {0}: {1}'.format(\n        arguments.callee.name,\n        JSON.stringify(resp)\n    ));\n\n    if (req.Status() != 200) {\n        throw '[{0}] {1}'.format(resp.status_code, resp.message);\n    }\n\n    return resp;\n}\n\nfunction createProblemURL(zabbix_url, triggerid, eventid, event_source) {\n    var problem_url = '';\n    if (event_source === '0') {\n        problem_url = '{0}/tr_events.php?triggerid={1}&eventid={2}'\n            .format(\n                zabbix_url,\n                triggerid,\n                eventid\n            );\n    }\n    else {\n        problem_url = zabbix_url;\n    }\n\n    return problem_url;\n}\n\nfunction getTagValue(event_tags, key) {\n    var pattern = new RegExp('(' + key + ':.+)');\n    var tagValue = event_tags\n        .split(',')\n        .filter(function (v) {\n            return v.match(pattern);\n        })\n        .map(function (v) {\n            return v.split(':')[1];\n        })[0]\n        || 0;\n\n    return tagValue;\n}\n\nfunction handlerAlarm(req, params) {\n    var channel = getChannel(params.send_to);\n    var fields = {\n        channel_id: channel.id,\n        props: {}\n    };\n\n    if (isEventProblem(params)) {\n        var team_name = channel.team_name\n            ? channel.team_name\n            : getTeamByID(channel.team_id).name;\n\n        fields.props.attachments = [\n            createMessage(\n                SEVERITY_COLORS[params.event_nseverity] || 0,\n                params.event_date,\n                params.event_time,\n                createProblemURL(params.zabbix_url, params.trigger_id, params.event_id, params.event_source)\n            )\n        ];\n\n        var resp = JSON.parse(req.Post(\n            Mattermost.post_message,\n            JSON.stringify(fields)\n        )\n        );\n\n        if (req.Status() != 201) {\n            throw '[{0}] {1}'.format(resp.status_code, resp.message);\n        }\n\n        result.tags.__mattermost_post_id = resp.id;\n        result.tags.__mattermost_channel_id = channel.id;\n        result.tags.__mattermost_channel_name = channel.name;\n        result.tags.__mattermost_message_link = getPermalink(\n            params.mattermost_url,\n            team_name,\n            resp.id\n        );\n\n    }\n    else if (isEventUpdate(params)) {\n        fields.root_id = getTagValue(params.event_tags, 'mattermost_post_id');\n\n        if (params.event_source === '0') {}\n        fields.props.attachments = [\n            createMessage(\n                SEVERITY_COLORS[params.event_nseverity] || 0,\n                params.event_update_date,\n                params.event_update_time,\n                createProblemURL(params.zabbix_url, params.trigger_id, params.event_id, params.event_source),\n                true\n            )\n        ];\n\n        resp = JSON.parse(req.Post(\n            Mattermost.post_message, JSON.stringify(fields)\n        )\n        );\n\n        if (req.Status() != 201) {\n            throw '[{0}] {1}'.format(resp.status_code, resp.message);\n        }\n\n    }\n    else if (isEventResolve(params)) {\n        fields.channel_id = getTagValue(params.event_tags, 'mattermost_channel_id');\n        fields.id = getTagValue(params.event_tags, 'mattermost_post_id');\n        fields.props.attachments = [\n            createMessage(\n                RESOLVE_COLOR,\n                params.event_date,\n                params.event_time,\n                createProblemURL(params.zabbix_url, params.trigger_id, params.event_id, params.event_source)\n            )\n        ];\n\n        var post_id = getTagValue(params.event_tags, 'mattermost_post_id');\n\n        resp = JSON.parse(req.Put(\n            Mattermost.chat_update.format(post_id),\n            JSON.stringify(fields)\n        )\n        );\n\n        if (req.Status() != 200) {\n            throw '[{0}] {1}'.format(resp.status_code, resp.message);\n        }\n    }\n}\n\nfunction handlerEvent(req, params) {\n    var channel = getChannel(params.send_to);\n    var fields = {\n        channel_id: channel.id,\n        props: {}\n    };\n\n    if (isEventProblem(params)) {\n        var team_name = channel.team_name\n            ? channel.team_name\n            : getTeamByID(channel.team_id).name;\n\n        fields.props.attachments = [\n            createMessage(\n                SEVERITY_COLORS[params.event_nseverity] || 0,\n                params.event_date,\n                params.event_time,\n                createProblemURL(params.zabbix_url, params.trigger_id, params.event_id, params.event_source)\n            )\n        ];\n\n        var resp = JSON.parse(req.Post(Mattermost.post_message, JSON.stringify(fields)));\n\n        if (req.Status() != 201) {\n            throw '[{0}] {1}'.format(resp.status_code, resp.message);\n        }\n\n        result.tags.__mattermost_channel_name = channel.name;\n        result.tags.__mattermost_message_link = getPermalink(\n            params.mattermost_url,\n            team_name,\n            resp.id\n        );\n\n    }\n    else if (isEventUpdate(params)) {\n        fields.props.attachments = [\n            createMessage(\n                SEVERITY_COLORS[params.event_nseverity] || 0,\n                params.event_update_date,\n                params.event_update_time,\n                createProblemURL(params.zabbix_url, params.trigger_id, params.event_id, params.event_source),\n                false\n            )\n        ];\n\n        resp = JSON.parse(req.Post(Mattermost.post_message, JSON.stringify(fields)));\n\n        if (req.Status() != 201) {\n            throw '[{0}] {1}'.format(resp.status_code, resp.message);\n        }\n\n    }\n    else if (isEventResolve(params)) {\n        fields.props.attachments = [\n            createMessage(\n                RESOLVE_COLOR,\n                params.event_recovery_date,\n                params.event_recovery_time,\n                createProblemURL(params.zabbix_url, params.trigger_id, params.event_id, params.event_source)\n            )\n        ];\n\n        resp = JSON.parse(req.Post(Mattermost.post_message, JSON.stringify(fields)));\n\n        if (req.Status() != 201) {\n            throw '[{0}] {1}'.format(resp.status_code, resp.message);\n        }\n    }\n}\n\nfunction createMessage(\n    event_severity_color,\n    event_date,\n    event_time,\n    problem_url,\n    isShort\n) {\n    var message = {\n        fallbac: params.alert_subject,\n        title: params.alert_subject,\n        color: event_severity_color,\n        title_link: problem_url,\n        footer: problem_url,\n\n        fields: [\n            {\n                title: 'Host',\n                value: '{0} [{1}]'.format(params.host_name, params.host_ip),\n                short: true\n            },\n            {\n                title: 'Event time',\n                value: '{0} {1}'.format(event_date, event_time),\n                short: true\n            }\n        ],\n    };\n\n    \n    if (params.event_source === '0') {\n        message.fields.push(\n            {\n                title: 'Severity',\n                value: params.event_severity,\n                short: true\n            },\n            {\n                title: 'Opdata',\n                value: params.event_opdata,\n                short: true\n            }\n        );\n    }\n\n    if (!isShort && params.event_source === '0') {\n        message.fields.push(\n            {\n                title: 'Event tags',\n                value: '`{0}`'.format(params.event_tags.replace(/__.+?:(.+?,|.+)/g, '') || 'None'),\n                short: true\n            },\n            {\n                title: 'Trigger description',\n                value: params.trigger_description,\n                short: true\n            }\n        );\n    }\n\n    if (params.event_source !== '0' || params.event_update_status === '1') {\n        message.fields.push(\n            {\n                title: 'Details',\n                value: params.alert_message,\n                short: false\n            }\n        );\n    }\n\n    return message;\n}\n\nfunction validateParams(params) {\n    if (typeof params.bot_token !== 'string' || params.bot_token.trim() === '') {\n        throw 'Field \"bot_token\" cannot be empty';\n    }\n\n    if (isNaN(params.event_id)) {\n        throw 'Field \"event_id\" is not a number';\n    }\n\n    if ([0, 1, 2, 3].indexOf(parseInt(params.event_source)) === -1) {\n        throw 'Incorrect \"event_source\" parameter given: \"' + params.event_source + '\".\\nMust be 0-3.';\n    }\n\n    if (params.event_source !== '0') {\n        params.event_nseverity = '0';\n        params.event_severity = 'Not classified';\n        params.event_update_status = '0';\n        params.send_mode = 'event';\n    }\n\n    if (params.event_source === '1' || params.event_source === '2') {\n        params.event_value = '1';\n    }\n\n    if (params.event_source === '1') {\n        params.host_name = params.discovery_host_dns;\n        params.host_ip = params.discovery_host_ip;\n    }\n\n    if ([0, 1, 2, 3, 4, 5].indexOf(parseInt(params.event_nseverity)) === -1) {\n        throw 'Incorrect \"event_nseverity\" parameter given: ' + params.event_nseverity + '\\nMust be 0-5.';\n    }\n\n    if (typeof params.event_severity !== 'string' || params.event_severity.trim() === '') {\n        throw 'Field \"event_severity\" cannot be empty';\n    }\n\n    if (params.event_update_status !== '0' && params.event_update_status !== '1') {\n        throw 'Incorrect \"event_update_status\" parameter given: ' + params.event_update_status + '\\nMust be 0 or 1.';\n    }\n\n    if (params.event_value !== '0' && params.event_value !== '1') {\n        throw 'Incorrect \"event_value\" parameter given: ' + params.event_value + '\\nMust be 0 or 1.';\n    }\n\n    if (typeof params.host_ip !== 'string' || params.host_ip.trim() === '') {\n        throw 'Field \"host_ip\" cannot be empty';\n    }\n\n    if (typeof params.host_name !== 'string' || params.host_name.trim() === '') {\n        throw 'Field \"host_name\" cannot be empty';\n    }\n\n    if (typeof params.mattermost_url !== 'string' || params.mattermost_url.trim() === '') {\n        throw 'Field \"mattermost_url\" cannot be empty';\n    }\n\n    if (!/^(http|https):\\/\\/.+/.test(params.mattermost_url)) {\n        throw 'Field \"mattermost_url\" must contain a schema';\n    }\n\n    if (['alarm', 'event'].indexOf(params.send_mode) === -1) {\n        throw 'Incorrect \"send_mode\" parameter given: ' + params.send_mode + '\\nMust be \"alarm\" or \"event\".';\n    }\n\n    if (typeof params.send_to !== 'string' || params.send_to.trim() === '') {\n        throw 'Field \"send_to\" cannot be empty';\n    }\n\n    if (isNaN(params.trigger_id) && params.event_source === '0') {\n        throw 'field \"trigger_id\" is not a number';\n    }\n\n    if (typeof params.zabbix_url !== 'string' || params.zabbix_url.trim() === '') {\n        throw 'Field \"zabbix_url\" cannot be empty';\n    }\n\n    if (!/^(http|https):\\/\\/.+/.test(params.zabbix_url)) {\n        throw 'Field \"zabbix_url\" must contain a schema';\n    }\n\n}\n\ntry {\n    var params = JSON.parse(value);\n\n    validateParams(params);\n\n    var req = new CurlHttpRequest(),\n        fields = {},\n        result = {tags: {}};\n\n    if (typeof params.HTTPProxy === 'string' && params.HTTPProxy.trim() !== '') {\n        req.SetProxy(params.HTTPProxy);\n    }\n\n    req.AddHeader('Content-Type: application/json; charset=utf-8');\n    req.AddHeader('Authorization: Bearer ' + params.bot_token);\n\n    params.mattermost_url = params.mattermost_url.replace(/\\/+$/, '');\n    params.zabbix_url = params.zabbix_url.replace(/\\/+$/, '');\n\n    var APIEndpoint = params.mattermost_url + '/api/v4/';\n\n    var Mattermost = {\n        post_message: APIEndpoint + 'posts',\n        get_channel: APIEndpoint + 'channels/{0}',\n        get_team: APIEndpoint + 'teams/{0}',\n        chat_update: APIEndpoint + 'posts/{0}',\n        direct_channel: APIEndpoint + 'channels/direct',\n        channel_byname: APIEndpoint + 'teams/name/{0}/channels/name/{1}',\n        user_byname: APIEndpoint + 'users/username/{0}',\n        bot_user: APIEndpoint + 'users/me'\n\n    };\n\n    params.send_mode = params.send_mode.toLowerCase();\n    params.send_mode = params.send_mode in SEND_MODE_HANDLERS\n        ? params.send_mode\n        : 'alarm';\n\n    SEND_MODE_HANDLERS[params.send_mode](req, params);\n\n    if (params.event_source === '0') {\n        return JSON.stringify(result);\n    }\n    else {\n        return 'OK';\n    }\n}\ncatch (error) {\n    Zabbix.Log(4, '[ Mattermost Webhook ] Mattermost notification failed: ' + error);\n    throw 'Mattermost notification failed: ' + error;\n}",
                "process_tags": "YES",
                "show_event_menu": "YES",
                "event_menu_url": "{EVENT.TAGS.__mattermost_message_link}",
                "event_menu_name": "Open in Mattermost: {EVENT.TAGS.__mattermost_channel_name}",
                "message_templates": [
                    {
                        "event_source": "TRIGGERS",
                        "operation_mode": "PROBLEM",
                        "subject": "Problem: {EVENT.NAME}",
                        "message": "Problem started at {EVENT.TIME} on {EVENT.DATE}\nProblem name: {EVENT.NAME}\nHost: {HOST.NAME}\nSeverity: {EVENT.SEVERITY}\nOperational data: {EVENT.OPDATA}\nOriginal problem ID: {EVENT.ID}\n{TRIGGER.URL}"
                    },
                    {
                        "event_source": "TRIGGERS",
                        "operation_mode": "RECOVERY",
                        "subject": "Resolved in {EVENT.DURATION}: {EVENT.NAME}",
                        "message": "Problem has been resolved at {EVENT.RECOVERY.TIME} on {EVENT.RECOVERY.DATE}\nProblem name: {EVENT.NAME}\nProblem duration: {EVENT.DURATION}\nHost: {HOST.NAME}\nSeverity: {EVENT.SEVERITY}\nOriginal problem ID: {EVENT.ID}\n{TRIGGER.URL}"
                    },
                    {
                        "event_source": "TRIGGERS",
                        "operation_mode": "UPDATE",
                        "subject": "Updated problem in {EVENT.AGE}: {EVENT.NAME}",
                        "message": "{USER.FULLNAME} {EVENT.UPDATE.ACTION} problem at {EVENT.UPDATE.DATE} {EVENT.UPDATE.TIME}.\n{EVENT.UPDATE.MESSAGE}\n\nCurrent problem status is {EVENT.STATUS}, age is {EVENT.AGE}, acknowledged: {EVENT.ACK.STATUS}."
                    },
                    {
                        "event_source": "DISCOVERY",
                        "operation_mode": "PROBLEM",
                        "subject": "Discovery: {DISCOVERY.DEVICE.STATUS} {DISCOVERY.DEVICE.IPADDRESS}",
                        "message": "Discovery rule: {DISCOVERY.RULE.NAME}\n\nDevice IP: {DISCOVERY.DEVICE.IPADDRESS}\nDevice DNS: {DISCOVERY.DEVICE.DNS}\nDevice status: {DISCOVERY.DEVICE.STATUS}\nDevice uptime: {DISCOVERY.DEVICE.UPTIME}\n\nDevice service name: {DISCOVERY.SERVICE.NAME}\nDevice service port: {DISCOVERY.SERVICE.PORT}\nDevice service status: {DISCOVERY.SERVICE.STATUS}\nDevice service uptime: {DISCOVERY.SERVICE.UPTIME}"
                    },
                    {
                        "event_source": "AUTOREGISTRATION",
                        "operation_mode": "PROBLEM",
                        "subject": "Autoregistration: {HOST.HOST}",
                        "message": "Host name: {HOST.HOST}\nHost IP: {HOST.IP}\nAgent port: {HOST.PORT}"
                    }
                ]
            },
            {
                "name": "MS Teams",
                "type": "WEBHOOK",
                "parameters": [
                    {
                        "name": "alert_message",
                        "value": "{ALERT.MESSAGE}"
                    },
                    {
                        "name": "alert_subject",
                        "value": "{ALERT.SUBJECT}"
                    },
                    {
                        "name": "event_date",
                        "value": "{EVENT.DATE}"
                    },
                    {
                        "name": "event_id",
                        "value": "{EVENT.ID}"
                    },
                    {
                        "name": "event_nseverity",
                        "value": "{EVENT.NSEVERITY}"
                    },
                    {
                        "name": "event_opdata",
                        "value": "{EVENT.OPDATA}"
                    },
                    {
                        "name": "event_recovery_date",
                        "value": "{EVENT.RECOVERY.DATE}"
                    },
                    {
                        "name": "event_recovery_time",
                        "value": "{EVENT.RECOVERY.TIME}"
                    },
                    {
                        "name": "event_severity",
                        "value": "{EVENT.SEVERITY}"
                    },
                    {
                        "name": "event_source",
                        "value": "{EVENT.SOURCE}"
                    },
                    {
                        "name": "event_status",
                        "value": "{EVENT.STATUS}"
                    },
                    {
                        "name": "event_tags",
                        "value": "{EVENT.TAGS}"
                    },
                    {
                        "name": "event_time",
                        "value": "{EVENT.TIME}"
                    },
                    {
                        "name": "event_update_action",
                        "value": "{EVENT.UPDATE.ACTION}"
                    },
                    {
                        "name": "event_update_date",
                        "value": "{EVENT.UPDATE.DATE}"
                    },
                    {
                        "name": "event_update_message",
                        "value": "{EVENT.UPDATE.MESSAGE}"
                    },
                    {
                        "name": "event_update_status",
                        "value": "{EVENT.UPDATE.STATUS}"
                    },
                    {
                        "name": "event_update_time",
                        "value": "{EVENT.UPDATE.TIME}"
                    },
                    {
                        "name": "event_update_user",
                        "value": "{USER.FULLNAME}"
                    },
                    {
                        "name": "event_value",
                        "value": "{EVENT.VALUE}"
                    },
                    {
                        "name": "host_ip",
                        "value": "{HOST.IP}"
                    },
                    {
                        "name": "host_name",
                        "value": "{HOST.NAME}"
                    },
                    {
                        "name": "teams_endpoint",
                        "value": "<PLACE WEBHOOK URL HERE>"
                    },
                    {
                        "name": "trigger_description",
                        "value": "{TRIGGER.DESCRIPTION}"
                    },
                    {
                        "name": "trigger_id",
                        "value": "{TRIGGER.ID}"
                    },
                    {
                        "name": "use_default_message",
                        "value": "false"
                    },
                    {
                        "name": "zabbix_url",
                        "value": "{$ZABBIX.URL}"
                    }
                ],
                "status": "DISABLED",
                "script": "var SEVERITY_COLORS = [\n    '#97AAB3', // Not classified.\n    '#7499FF', // Information.\n    '#FFC859', // Warning.\n    '#FFA059', // Average.\n    '#E97659', // High.\n    '#E45959', // Disaster.\n    '#009900', // Resolved.\n    '#000000'  // Default.\n];\n\ntry {\n    var params = JSON.parse(value);\n\n    if (typeof params.teams_endpoint !== 'string' || params.teams_endpoint.trim() === '') {\n        throw 'Cannot get teams_endpoint';\n    }\n    else if (!params.teams_endpoint.startsWith('http')) {\n        throw 'Invalid MS Teams webhook URL: ' + params.teams_endpoint;\n    }\n\n    params.zabbix_url = (params.zabbix_url.endsWith('/'))\n        ? params.zabbix_url.slice(0, -1) : params.zabbix_url;\n\n    if ([0, 1, 2, 3].indexOf(parseInt(params.event_source)) === -1) {\n        throw 'Incorrect \"event_source\" parameter given: \"' + params.event_source + '\".\\nMust be 0-3.';\n    }\n\n    // Set \"use_default_message\" to true for non trigger-based events.\n    if (params.event_source !== '0') {\n        params.use_default_message = 'true';\n    }\n\n    // Check {EVENT.VALUE} for trigger-based and internal events.\n    if (params.event_value !== '0' && params.event_value !== '1'\n            && (params.event_source === '0' || params.event_source === '3')) {\n        throw 'Incorrect \"event_value\" parameter given: \"' + params.event_value + '\".\\nMust be 0 or 1.';\n    }\n\n    // Check {EVENT.UPDATE.STATUS} only for trigger-based events.\n    if (params.event_update_status !== '0' && params.event_update_status !== '1' && params.event_source === '0') {\n        throw 'Incorrect \"event_update_status\" parameter given: \"' + params.event_update_status + '\".\\nMust be 0 or 1.';\n    }\n\n    if (params.event_value == 0) {\n        params.event_nseverity = '6';\n    }\n\n    if (!SEVERITY_COLORS[params.event_nseverity]) {\n        params.event_nseverity = '7';\n    }\n\n    var request = new CurlHttpRequest(),\n        facts = [],\n        body = {\n            themeColor: SEVERITY_COLORS[params.event_nseverity].replace('#', ''),\n            summary: 'Zabbix',\n            sections: [\n                {\n                    markdown: 'false',\n                    activityTitle: params.alert_subject,\n                    activitySubtitle: 'On ' + params.host_name + ' [' + params.host_ip + ']',\n                    text: (params.use_default_message.toLowerCase() == 'true')\n                        ? params.alert_message\n                        : params.trigger_description\n                }\n            ],\n            potentialAction: [\n                {\n                    '@type': 'OpenUri',\n                    name: (params.event_source === '0')\n                        ? 'Event Info'\n                        : 'Zabbix Home',\n                    targets: [\n                        {\n                            os: 'default',\n                            uri: (params.event_source === '0')\n                                ? params.zabbix_url + '/tr_events.php?triggerid=' +\n                                    params.trigger_id + '&eventid=' + params.event_id\n                                : params.zabbix_url\n                        }\n                    ]\n                }\n            ]\n        };\n\n    if (params.use_default_message.toLowerCase() !== 'true') {\n        // Problem message.\n        if (params.event_value === '1' && params.event_update_status === '0') {\n            facts.push({\n                name: 'Event time',\n                value: params.event_time + ' ' + params.event_date\n            });\n        }\n        // Update message.\n        else if (params.event_update_status === '1') {\n            body.sections[0].text = params.event_update_user + ' ' + params.event_update_action + '.';\n\n            if (params.event_update_message) {\n                body.sections[0].text += '<br>Message:<br>' + params.event_update_message;\n            }\n\n            facts.push({\n                name: 'Event update time',\n                value: params.event_update_time + ' ' + params.event_update_date\n            });\n        }\n        // Resolved message.\n        else {\n            facts.push({\n                name: 'Recovery time',\n                value: params.event_recovery_time + ' ' + params.event_recovery_date\n            });\n        }\n\n        if (params.event_severity && params.event_severity !== '{EVENT.SEVERITY}') {\n            facts.push({\n                name: 'Severity',\n                value: params.event_severity\n            });\n        }\n\n\n        if (params.event_opdata && params.event_opdata !== '{EVENT.OPDATA}') {\n            facts.push({\n                name: 'Operational data',\n                value: params.event_opdata\n            });\n        }\n\n        if (params.event_tags && params.event_tags !== '{EVENT.TAGS}') {\n            facts.push({\n                name: 'Event tags',\n                value: params.event_tags\n            });\n        }\n\n        Object.keys(params)\n            .forEach(function (key) {\n                if (key.startsWith('fact_') && params[key] !== '') {\n                    facts.push({\n                        name: key.substring(5),\n                        value: params[key]\n                    });\n                }\n                else if (key.startsWith('openUri_') && params[key] !== '' && !params[key].startsWith('{')) {\n                    body.potentialAction.push({\n                        '@type': 'OpenUri',\n                        name: key.substring(8),\n                        targets: [\n                            {\n                                os: 'default',\n                                uri: params[key]\n                            }\n                        ]\n                    });\n                }\n            });\n        body.sections[0].facts = facts;\n    }\n\n    body.sections[0].text = body.sections[0].text.replace(/(?:\\r\\n|\\r|\\n)/g, '<br>');\n\n    request.AddHeader('Content-Type: application/json');\n\n    if (typeof params.HTTPProxy === 'string' && params.HTTPProxy !== '') {\n        request.SetProxy(params.HTTPProxy);\n    }\n\n    Zabbix.Log(4, '[ MS Teams Webhook ] JSON: ' + JSON.stringify(body));\n\n    var response = request.Post(params.teams_endpoint, JSON.stringify(body));\n\n    Zabbix.Log(4, '[ MS Teams Webhook ] Response: ' + response);\n\n    if (response === '1') {\n        return 'OK';\n    }\n    else {\n        Zabbix.Log(4, '[ MS Teams Webhook ] FAILED with response: ' + response);\n        throw response;\n    }\n}\ncatch (error) {\n    Zabbix.Log(3, '[ MS Teams Webhook ] ERROR: ' + error);\n    throw 'Sending failed: ' + error;\n}",
                "message_templates": [
                    {
                        "event_source": "DISCOVERY",
                        "operation_mode": "PROBLEM",
                        "subject": "Discovery: {DISCOVERY.DEVICE.STATUS} {DISCOVERY.DEVICE.IPADDRESS}",
                        "message": "Discovery rule: {DISCOVERY.RULE.NAME}\n\nDevice IP: {DISCOVERY.DEVICE.IPADDRESS}\nDevice DNS: {DISCOVERY.DEVICE.DNS}\nDevice status: {DISCOVERY.DEVICE.STATUS}\nDevice uptime: {DISCOVERY.DEVICE.UPTIME}\n\nDevice service name: {DISCOVERY.SERVICE.NAME}\nDevice service port: {DISCOVERY.SERVICE.PORT}\nDevice service status: {DISCOVERY.SERVICE.STATUS}\nDevice service uptime: {DISCOVERY.SERVICE.UPTIME}"
                    },
                    {
                        "event_source": "AUTOREGISTRATION",
                        "operation_mode": "PROBLEM",
                        "subject": "Autoregistration: {HOST.HOST}",
                        "message": "Host name: {HOST.HOST}\nHost IP: {HOST.IP}\nAgent port: {HOST.PORT}"
                    },
                    {
                        "event_source": "TRIGGERS",
                        "operation_mode": "PROBLEM",
                        "subject": "Problem: {EVENT.NAME}",
                        "message": "Problem started at {EVENT.TIME} on {EVENT.DATE}\nProblem name: {EVENT.NAME}\nHost: {HOST.NAME}\nSeverity: {EVENT.SEVERITY}\nOperational data: {EVENT.OPDATA}\nOriginal problem ID: {EVENT.ID}\n{TRIGGER.URL}"
                    },
                    {
                        "event_source": "TRIGGERS",
                        "operation_mode": "RECOVERY",
                        "subject": "Resolved: {EVENT.NAME}",
                        "message": "Problem has been resolved in {EVENT.DURATION} at {EVENT.RECOVERY.TIME} on {EVENT.RECOVERY.DATE}\nProblem name: {EVENT.NAME}\nHost: {HOST.NAME}\nSeverity: {EVENT.SEVERITY}\nOriginal problem ID: {EVENT.ID}\n{TRIGGER.URL}"
                    },
                    {
                        "event_source": "TRIGGERS",
                        "operation_mode": "UPDATE",
                        "subject": "Updated problem: {EVENT.NAME}",
                        "message": "{USER.FULLNAME} {EVENT.UPDATE.ACTION} problem at {EVENT.UPDATE.DATE} {EVENT.UPDATE.TIME}.\n{EVENT.UPDATE.MESSAGE}\n\nCurrent problem status is {EVENT.STATUS}, acknowledged: {EVENT.ACK.STATUS}."
                    }
                ]
            },
            {
                "name": "Opsgenie",
                "type": "WEBHOOK",
                "parameters": {
                    "1": {
                        "name": "alert_message",
                        "value": "{ALERT.MESSAGE}"
                    },
                    "2": {
                        "name": "alert_subject",
                        "value": "{ALERT.SUBJECT}"
                    },
                    "3": {
                        "name": "event_id",
                        "value": "{EVENT.ID}"
                    },
                    "4": {
                        "name": "event_nseverity",
                        "value": "{EVENT.NSEVERITY}"
                    },
                    "5": {
                        "name": "event_source",
                        "value": "{EVENT.SOURCE}"
                    },
                    "6": {
                        "name": "event_tags_json",
                        "value": "{EVENT.TAGSJSON}"
                    },
                    "7": {
                        "name": "event_update_status",
                        "value": "{EVENT.UPDATE.STATUS}"
                    },
                    "8": {
                        "name": "event_value",
                        "value": "{EVENT.VALUE}"
                    },
                    "9": {
                        "name": "opsgenie_api",
                        "value": "<put your opsgenie api>"
                    },
                    "10": {
                        "name": "opsgenie_tags",
                        "value": ""
                    },
                    "11": {
                        "name": "opsgenie_teams",
                        "value": ""
                    },
                    "12": {
                        "name": "opsgenie_token",
                        "value": "<put your token>"
                    },
                    "13": {
                        "name": "opsgenie_web",
                        "value": "<put your opsgenie web>"
                    },
                    "14": {
                        "name": "severity_average",
                        "value": "P3"
                    },
                    "15": {
                        "name": "severity_default",
                        "value": "P5"
                    },
                    "16": {
                        "name": "severity_disaster",
                        "value": "P1"
                    },
                    "17": {
                        "name": "severity_high",
                        "value": "P2"
                    },
                    "18": {
                        "name": "severity_information",
                        "value": "P5"
                    },
                    "19": {
                        "name": "severity_not_classified",
                        "value": "P5"
                    },
                    "20": {
                        "name": "severity_warning",
                        "value": "P4"
                    },
                    "21": {
                        "name": "trigger_id",
                        "value": "{TRIGGER.ID}"
                    },
                    "0": {
                        "name": "zbxurl",
                        "value": "{$ZABBIX.URL}"
                    },
                    "22": {
                        "name": "zbxuser",
                        "value": "{USER.FULLNAME}"
                    }
                },
                "status": "DISABLED",
                "script": "var Media = {\n    params: {},\n    name: '',\n    labels: [],\n    HTTPProxy: '',\n\n    setParams: function (params) {\n        if (typeof params !== 'object') {\n            return;\n        }\n\n        Media.params = params;\n        Media.params.api += Media.params.api.endsWith('/') ? '' : '/';\n        Media.params.web += Media.params.web.endsWith('/') ? '' : '/';\n    },\n\n    setProxy: function (HTTPProxy) {\n        if (typeof HTTPProxy !== 'undefined' && HTTPProxy.trim() !== '') {\n            Media.HTTPProxy = HTTPProxy;\n        }\n    },\n\n    setTags: function(event_tags_json) {\n        if (typeof event_tags_json !== 'undefined' && event_tags_json !== ''\n                && event_tags_json !== '{EVENT.TAGSJSON}') {\n\n            try {\n                var tags = JSON.parse(event_tags_json),\n                    label;\n\n                tags.forEach(function (tag) {\n                    if (typeof tag.tag === 'string') {\n                        label = (tag.tag + (typeof tag.value !== 'undefined'\n                                && tag.value !== '' ? (':' + tag.value) : '')).replace(/\\s/g, '_');\n                        Media.labels.push(label);\n                    }\n                });\n            }\n            catch (error) {\n                Zabbix.Log(4, '[ ' + Media.name + ' Webhook ] Failed to parse \"event_tags_json\" param');\n            }\n        }\n    },\n\n    request: function (method, query, data, allow_404) {\n        if (typeof(allow_404) === 'undefined') {\n            allow_404 = false;\n        }\n\n        ['api', 'token'].forEach(function (field) {\n            if (typeof Media.params !== 'object' || typeof Media.params[field] === 'undefined'\n                    || Media.params[field] === '') {\n                throw 'Required ' + Media.name + ' param is not set: \"' + field + '\".';\n            }\n        });\n\n        var response,\n            url = Media.params.api + query,\n            request = new CurlHttpRequest();\n\n        request.AddHeader('Content-Type: application/json');\n        request.AddHeader('Authorization: ' + Media.params.token);\n        request.SetProxy(Media.HTTPProxy);\n\n        if (typeof data !== 'undefined') {\n            data = JSON.stringify(data);\n        }\n\n        Zabbix.Log(4, '[ ' + Media.name + ' Webhook ] Sending request: ' +\n            url + ((typeof data === 'string') ? ('\\n' + data) : ''));\n\n        switch (method) {\n            case 'get':\n                response = request.Get(url, data);\n                break;\n\n            case 'post':\n                response = request.Post(url, data);\n                break;\n\n            case 'put':\n                response = request.Put(url, data);\n                break;\n\n            default:\n                throw 'Unsupported HTTP request method: ' + method;\n        }\n\n        Zabbix.Log(4, '[ ' + Media.name + ' Webhook ] Received response with status code ' +\n            request.Status() + '\\n' + response);\n\n        if (response !== null) {\n            try {\n                response = JSON.parse(response);\n            }\n            catch (error) {\n                Zabbix.Log(4, '[ ' + Media.name + ' Webhook ] Failed to parse response.');\n                response = null;\n            }\n        }\n\n        if ((request.Status() < 200 || request.Status() >= 300)\n                && (!allow_404 || request.Status() !== 404)) {\n            var message = 'Request failed with status code ' + request.Status();\n\n            if (response !== null) {\n                if (typeof response.errors === 'object' && Object.keys(response.errors).length > 0) {\n                    message += ': ' + JSON.stringify(response.errors);\n                }\n                else if (typeof response.errorMessages === 'object' && Object.keys(response.errorMessages).length > 0) {\n                    message += ': ' + JSON.stringify(response.errorMessages);\n                }\n                else if (typeof response.message === 'string') {\n                    message += ': ' + response.message;\n                }\n            }\n\n            throw message + ' Check debug log for more information.';\n        }\n\n        return {\n            status: request.Status(),\n            response: response\n        };\n    },\n\n    getAlertId: function (requestId) {\n        do {\n            resp = Media.request('get', 'requests/' + requestId, undefined, true);\n        }\n        while (typeof resp.response !== 'object' || typeof resp.response.data === 'undefined'\n                || resp.response.data.success === false);\n\n        if (typeof resp.response !== 'object' || typeof resp.response.data === 'undefined') {\n            throw 'Cannot get ' + Media.name + ' issue ID. Check debug log for more information.';\n        }\n\n        return resp;\n    }\n};\n\ntry {\n    var result = {tags: {}},\n        params = JSON.parse(value),\n        media = {},\n        fields = {},\n        resp = {},\n        responders = [],\n        tags = [],\n        required_params = [\n            'alert_subject',\n            'alert_message',\n            'event_id',\n            'event_source',\n            'event_value',\n            'event_update_status',\n            'opsgenie_api',\n            'opsgenie_web',\n            'opsgenie_token'\n        ],\n        severities = [\n            'not_classified',\n            'information',\n            'warning',\n            'average',\n            'high',\n            'disaster',\n            'resolved',\n            'default'\n        ],\n        priority;\n\n    Object.keys(params)\n        .forEach(function (key) {\n            if (required_params.indexOf(key) !== -1 && params[key].trim() === '') {\n                throw 'Parameter \"' + key + '\" cannot be empty.';\n            }\n            if (key.startsWith('opsgenie_')) {\n                media[key.substring(9)] = params[key];\n            }\n        });\n\n    // Possible values of event_source:\n    // 0 - Trigger, 1 - Discovery, 2 - Autoregistration, 3 - Internal.\n    if ([0, 1, 2, 3].indexOf(parseInt(params.event_source)) === -1) {\n        throw 'Incorrect \"event_source\" parameter given: \"' + params.event_source + '\".\\nMust be 0-3.';\n    }\n\n    // Check event_value for trigger-based and internal events.\n    // Possible values: 1 for problem, 0 for recovering\n    if (params.event_value !== '0' && params.event_value !== '1'\n        && (params.event_source === '0' || params.event_source === '3')) {\n        throw 'Incorrect \"event_value\" parameter given: ' + params.event_value + '\\nMust be 0 or 1.';\n    }\n\n    // Check event_update_status only for trigger-based events.\n    // Possible values: 0 - Webhook was called because of problem/recovery event, 1 - Update operation.\n    if (params.event_source === '0' && params.event_update_status !== '0' && params.event_update_status !== '1') {\n        throw 'Incorrect \"event_update_status\" parameter given: ' + params.event_update_status + '\\nMust be 0 or 1.';\n    }\n\n    // Check event_id for a numeric value.\n    if (isNaN(parseInt(params.event_id)) || params.event_id < 1) {\n        throw 'Incorrect \"event_id\" parameter given: ' + params.event_id + '\\nMust be a positive number.';\n    }\n\n    if ((params.event_source === '1' || params.event_source === '2')  && params.event_value === '0') {\n        throw 'Recovery operations are supported only for Trigger and Internal actions.';\n    }\n\n    if ([0, 1, 2, 3, 4, 5].indexOf(parseInt(params.event_nseverity)) === -1) {\n        params.event_nseverity = '7';\n    }\n\n    if (params.event_value === '0') {\n        params.event_nseverity = '6';\n    }\n\n    priority = params['severity_' + severities[params.event_nseverity]];\n    params.zbxurl = params.zbxurl + (params.zbxurl.endsWith('/') ? '' : '/');\n\n    Media.name = 'Opsgenie';\n    Media.setParams(media);\n    Media.params.token = 'GenieKey ' + Media.params.token;\n    Media.setProxy(params.HTTPProxy);\n    Media.setTags(params.event_tags_json); // Set Media.labels\n\n    // Create an issue.\n    // Numeric value of the event that triggered an action (1 for problem, 0 for recovering).\n    // Numeric value of of the problem update status. Possible values:\n    // 0 - Webhook was called because of problem/recovery event, 1 - Update operation.\n    if ((params.event_source == 0 && params.event_value == 1 && params.event_update_status == 0)\n            || (params.event_source == 3 && params.event_value == 1)\n            || params.event_source == 1 || params.event_source == 2) {\n        fields.message = params.alert_subject;\n        fields.alias = params.event_id;\n        fields.description = params.alert_message;\n        fields.priority = priority;\n        fields.source = 'Zabbix';\n\n        if (params.event_source === '0') {\n            fields.details = {\n                'Zabbix server': params.zbxurl,\n                Problem: params.zbxurl + 'tr_events.php?triggerid=' + params.trigger_id + '&eventid=' + params.event_id\n            };\n        }\n        else {\n            fields.details = {'Zabbix server': params.zbxurl};\n        }\n\n        if (typeof params.opsgenie_teams === 'string') {\n            responders = params.opsgenie_teams.split(',');\n            fields.responders = responders.map(function(team) {\n                return {type: 'team', name: team.trim()};\n            });\n        }\n\n        fields.tags = Media.labels;\n        if (typeof params.opsgenie_tags === 'string') {\n            tags = params.opsgenie_tags.split(',');\n            tags.forEach(function(item) {\n                fields.tags.push(item.trim());\n            });\n        }\n\n        resp = Media.request('post', '', fields);\n        if (typeof resp.response !== 'object' || typeof resp.response.result === 'undefined') {\n            throw 'Cannot create ' + Media.name + ' issue. Check debug log for more information.';\n        }\n\n        if (resp.status === 202) {\n            resp = Media.getAlertId(resp.response.requestId);\n            if (params.event_source == 0 && params.event_value == 1 && params.event_update_status == 0) {\n                result.tags.__zbx_ops_issuekey = resp.response.data.alertId;\n                result.tags.__zbx_ops_issuelink = Media.params.web + 'alert/detail/' + resp.response.data.alertId;\n            }\n        }\n        else {\n            throw Media.name + ' response code is unexpected. Check debug log for more information.';\n        }\n    }\n    // Update a created issue.\n    else {\n        fields.user = (params.event_value != 0) ? params.zbxuser : '';\n        fields.note = params.alert_message;\n\n        resp = Media.request('post', params.event_id + '/notes?identifierType=alias', fields);\n        if (typeof resp.response !== 'object' || typeof resp.response.result === 'undefined') {\n            throw 'Cannot update ' + Media.name + ' issue. Check debug log for more information.';\n        }\n\n        if (resp.status === 202) {\n            resp = Media.getAlertId(resp.response.requestId);\n        }\n        else {\n            throw Media.name + ' response code is unexpected. Check debug log for more information.';\n        }\n    }\n\n    return JSON.stringify(result);\n}\ncatch (error) {\n    Zabbix.Log(3, '[ ' + Media.name + ' Webhook ] ERROR: ' + error);\n    throw 'Sending failed: ' + error;\n}",
                "process_tags": "YES",
                "show_event_menu": "YES",
                "event_menu_url": "{EVENT.TAGS.__zbx_ops_issuelink}",
                "event_menu_name": "Opsgenie: {EVENT.TAGS.__zbx_ops_issuekey}",
                "description": "Please refer to https://docs.opsgenie.com/docs/alert-api and https://www.zabbix.com/documentation/5.2/manual/config/notifications/media/webhook#example_scripts.\n  \nSet global macro {$ZABBIX.URL} with your Zabbix server URL.\nAdd dedicated user with media type \"Opsgenie\".\nChange the values of the variables opsgenie_api (https://api.opsgenie.com/v2/alerts or https://api.eu.opsgenie.com/v2/alerts),\nopsgenie_web (for example, https://myzabbix.app.opsgenie.com), opsgenie_token.",
                "message_templates": [
                    {
                        "event_source": "TRIGGERS",
                        "operation_mode": "PROBLEM",
                        "subject": "Problem: {EVENT.NAME}",
                        "message": "Problem started at {EVENT.TIME} on {EVENT.DATE}\nProblem name: {EVENT.NAME}\nHost: {HOST.NAME}\nSeverity: {EVENT.SEVERITY}\nOperational data: {EVENT.OPDATA}\nOriginal problem ID: {EVENT.ID}\n{TRIGGER.URL}"
                    },
                    {
                        "event_source": "TRIGGERS",
                        "operation_mode": "UPDATE",
                        "subject": "Updated problem in {EVENT.AGE}: {EVENT.NAME}",
                        "message": "{USER.FULLNAME} {EVENT.UPDATE.ACTION} problem at {EVENT.UPDATE.DATE} {EVENT.UPDATE.TIME}.\n{EVENT.UPDATE.MESSAGE}\n\nCurrent problem status is {EVENT.STATUS}, age is {EVENT.AGE}, acknowledged: {EVENT.ACK.STATUS}."
                    },
                    {
                        "event_source": "DISCOVERY",
                        "operation_mode": "PROBLEM",
                        "subject": "Discovery: {DISCOVERY.DEVICE.STATUS} {DISCOVERY.DEVICE.IPADDRESS}",
                        "message": "Discovery rule: {DISCOVERY.RULE.NAME}\n\nDevice IP: {DISCOVERY.DEVICE.IPADDRESS}\nDevice DNS: {DISCOVERY.DEVICE.DNS}\nDevice status: {DISCOVERY.DEVICE.STATUS}\nDevice uptime: {DISCOVERY.DEVICE.UPTIME}\n\nDevice service name: {DISCOVERY.SERVICE.NAME}\nDevice service port: {DISCOVERY.SERVICE.PORT}\nDevice service status: {DISCOVERY.SERVICE.STATUS}\nDevice service uptime: {DISCOVERY.SERVICE.UPTIME}"
                    },
                    {
                        "event_source": "AUTOREGISTRATION",
                        "operation_mode": "PROBLEM",
                        "subject": "Autoregistration: {HOST.HOST}",
                        "message": "Host name: {HOST.HOST}\nHost IP: {HOST.IP}\nAgent port: {HOST.PORT}"
                    },
                    {
                        "event_source": "TRIGGERS",
                        "operation_mode": "RECOVERY",
                        "subject": "Resolved in {EVENT.DURATION}: {EVENT.NAME}",
                        "message": "Problem has been resolved at {EVENT.RECOVERY.TIME} on {EVENT.RECOVERY.DATE}\nProblem name: {EVENT.NAME}\nProblem duration: {EVENT.DURATION}\nHost: {HOST.NAME}\nSeverity: {EVENT.SEVERITY}\nOriginal problem ID: {EVENT.ID}\n{TRIGGER.URL}"
                    }
                ]
            },
            {
                "name": "OTRS",
                "type": "WEBHOOK",
                "parameters": [
                    {
                        "name": "alert_message",
                        "value": "{ALERT.MESSAGE}"
                    },
                    {
                        "name": "alert_subject",
                        "value": "{ALERT.SUBJECT}"
                    },
                    {
                        "name": "event_id",
                        "value": "{EVENT.ID}"
                    },
                    {
                        "name": "event_nseverity",
                        "value": "{EVENT.NSEVERITY}"
                    },
                    {
                        "name": "event_source",
                        "value": "{EVENT.SOURCE}"
                    },
                    {
                        "name": "event_update_message",
                        "value": "{EVENT.UPDATE.MESSAGE}"
                    },
                    {
                        "name": "event_update_status",
                        "value": "{EVENT.UPDATE.STATUS}"
                    },
                    {
                        "name": "event_value",
                        "value": "{EVENT.VALUE}"
                    },
                    {
                        "name": "otrs_auth_password",
                        "value": "<PUT YOUR USER PASSWORD>"
                    },
                    {
                        "name": "otrs_auth_user",
                        "value": "<PUT YOUR USER NAME>"
                    },
                    {
                        "name": "otrs_customer",
                        "value": "<PUT YOUR CUSTOMER EMAIL>"
                    },
                    {
                        "name": "otrs_default_priority_id",
                        "value": "3"
                    },
                    {
                        "name": "otrs_queue",
                        "value": "<PUT YOUR QUEUE NAME>"
                    },
                    {
                        "name": "otrs_ticket_id",
                        "value": "{EVENT.TAGS.__zbx_otrs_ticket_id}"
                    },
                    {
                        "name": "otrs_ticket_state",
                        "value": "new"
                    },
                    {
                        "name": "otrs_time_unit",
                        "value": "0"
                    },
                    {
                        "name": "otrs_url",
                        "value": "<PUT YOUR OTRS URL>"
                    },
                    {
                        "name": "trigger_id",
                        "value": "{TRIGGER.ID}"
                    },
                    {
                        "name": "zabbix_url",
                        "value": "{$ZABBIX.URL}"
                    }
                ],
                "status": "DISABLED",
                "script": "var OTRS = {\n    params: {},\n    entrypoint: 'nph-genericinterface.pl/Webservice/ZabbixTicketConnector/Ticket',\n\n    setParams: function (params) {\n        if (typeof params !== 'object') {\n            return;\n        }\n\n        OTRS.params = params;\n        if (typeof OTRS.params.url === 'string') {\n            if (!OTRS.params.url.endsWith('/')) {\n                OTRS.params.url += '/';\n            }\n        }\n    },\n\n    addDynamicFields: function (data, fields) {\n        if (typeof fields === 'object' && Object.keys(fields).length) {\n            data.DynamicField = [];\n\n            Object.keys(fields)\n                .forEach(function(field) {\n                    if (field !== undefined) {\n                        if (fields[field].match(/^\\d{4}[.-]\\d{2}[.-]\\d{2}$/)) {\n                            fields[field] = fields[field].replace(/\\./g, '-');\n                        }\n\n                        data.DynamicField.push({Name: field, Value: fields[field]});\n                    }\n                });\n        }\n\n        return data;\n    },\n\n    request: function (method, query, data) {\n        ['url', 'auth_user', 'auth_password', 'queue',\n            'customer', 'ticket_state', 'default_priority_id', 'time_unit'].forEach(function (field) {\n            if (typeof OTRS.params !== 'object' || typeof OTRS.params[field] === 'undefined'\n                || OTRS.params[field] === '' ) {\n                throw 'Required param is not set: \"' + field + '\".';\n            }\n        });\n\n        var response,\n            request = new CurlHttpRequest(),\n            url = OTRS.params.url + query +\n                '?UserLogin=' + encodeURIComponent(OTRS.params.auth_user) +\n                '&Password=' + encodeURIComponent(OTRS.params.auth_password);\n\n        if (typeof OTRS.HTTPProxy !== 'undefined' && OTRS.HTTPProxy.trim() !== '') {\n            request.SetProxy(OTRS.HTTPProxy);\n        }\n\n        request.AddHeader('Content-Type: application/json');\n\n        if (typeof data !== 'undefined') {\n            data = JSON.stringify(data);\n        }\n\n        Zabbix.Log(4, '[ OTRS Webhook ] Sending request: ' +\n            url + ((typeof data === 'string') ? (' ' + data) : ''));\n\n        switch (method) {\n            case 'get':\n                response = request.Get(url, data);\n                break;\n\n            case 'post':\n                response = request.Post(url, data);\n                break;\n\n            case 'put':\n                response = request.Put(url, data);\n                break;\n\n            default:\n                throw 'Unsupported HTTP request method: ' + method;\n        }\n\n        Zabbix.Log(4, '[ OTRS Webhook ] Received response with status code ' + request.Status() + ': ' + response);\n\n        if (request.Status() < 200 || request.Status() >= 300) {\n            var message = 'Request failed with status code ' + request.Status();\n\n            message += ': ' + response;\n            throw message + ' Check debug log for more information.';\n        }\n\n        if (response !== null) {\n            try {\n                response = JSON.parse(response);\n            }\n            catch (error) {\n                Zabbix.Log(4, '[ OTRS Webhook ] Failed to parse response received from OTRS');\n                response = null;\n            }\n        }\n\n        if (typeof response.Error !== 'undefined'\n            && Object.keys(response.Error).length > 0) {\n            message = 'Request failed: ' + JSON.stringify(response.Error);\n        }\n\n\n        return {\n            status: request.Status(),\n            response: response\n        };\n    },\n\n    createTicket: function(subject, message, priority, fields) {\n        var result,\n            data = {\n                Ticket: {\n                    Title: subject,\n                    Queue: OTRS.params.queue,\n                    State: OTRS.params.ticket_state,\n                    PriorityID: priority || OTRS.params.default_priority_id,\n                    CustomerUser: OTRS.params.customer\n                },\n                Article: {\n                    Subject: subject,\n                    Body: message,\n                    TimeUnit: OTRS.params.time_unit,\n                    ContentType: 'text/plain; charset=utf8'\n                }\n            };\n\n        result = OTRS.request('post', OTRS.entrypoint, OTRS.addDynamicFields(data, fields));\n\n        if (typeof result.response !== 'object'\n            || typeof result.response.TicketID === 'undefined'\n            || result.status != 200) {\n            throw 'Cannot create OTRS ticket. Check debug log for more information.';\n        }\n\n        return result.response.TicketID;\n    },\n\n    updateTicket: function(subject, message) {\n        var result,\n            data = {\n                Article: {\n                    Subject: subject,\n                    Body: message || '',\n                    TimeUnit: OTRS.params.time_unit,\n                    ContentType: 'text/plain; charset=utf8'\n                }\n            };\n\n        result = OTRS.request('put', OTRS.entrypoint + '/' + encodeURIComponent(OTRS.params.ticket_id), data);\n\n        if (typeof result.response !== 'object'\n            || typeof result.response.TicketID === 'undefined'\n            || result.status != 200) {\n            throw 'Cannot update OTRS ticket. Check debug log for more information.';\n        }\n    }\n};\n\ntry {\n    var params = JSON.parse(value),\n        params_otrs = {},\n        params_fields = {},\n        params_update = {},\n        result = {tags: {}},\n        required_params = [\n            'alert_subject', 'event_source',\n            'event_value',  'event_update_status'\n        ],\n        severities = [\n            {name: 'not_classified', color: '#97AAB3'},\n            {name: 'information', color: '#7499FF'},\n            {name: 'warning', color: '#FFC859'},\n            {name: 'average', color: '#FFA059'},\n            {name: 'high', color: '#E97659'},\n            {name: 'disaster', color: '#E45959'},\n            {name: 'resolved', color: '#009900'},\n            {name: null, color: '#000000'}\n        ],\n        priority;\n\n    Object.keys(params)\n        .forEach(function (key) {\n            if (key.startsWith('otrs_')) {\n                params_otrs[key.substring(5)] = params[key];\n            }\n            else if (key.startsWith('dynamicfield_')) {\n                params_fields[key.substring(13)] = params[key];\n            }\n            else if (key.startsWith('event_update_')) {\n                params_update[key.substring(13)] = params[key];\n            }\n            else if (required_params.indexOf(key) !== -1 && params[key].trim() === '') {\n                throw 'Parameter \"' + key + '\" cannot be empty.';\n            }\n        });\n\n    if ([0, 1, 2, 3].indexOf(parseInt(params.event_source)) === -1) {\n        throw 'Incorrect \"event_source\" parameter given: ' + params.event_source + '\\nMust be 0-3.';\n    }\n\n    // Check {EVENT.VALUE} for trigger-based and internal events.\n    if (params.event_value !== '0' && params.event_value !== '1'\n        && (params.event_source === '0' || params.event_source === '3')) {\n        throw 'Incorrect \"event_value\" parameter given: ' + params.event_value + '\\nMust be 0 or 1.';\n    }\n\n    // Check {EVENT.UPDATE.STATUS} only for trigger-based events.\n    if (params.event_source === '0' && params.event_update_status !== '0' && params.event_update_status !== '1') {\n        throw 'Incorrect \"event_update_status\" parameter given: ' + params.event_update_status + '\\nMust be 0 or 1.';\n    }\n\n    if (params.event_source !== '0' && params.event_value === '0') {\n        throw 'Recovery operations are supported only for trigger-based actions.';\n    }\n\n    if (params.event_source === '0'\n        && ((params.event_value === '1' && params.event_update_status === '1')\n            || (params.event_value === '0'\n                && (params.event_update_status === '0' || params.event_update_status === '1')))\n        && (isNaN(parseInt(params.otrs_ticket_id)) || parseInt(params.otrs_ticket_id) < 1 )) {\n        throw 'Incorrect \"otrs_ticket_id\" parameter given: ' + params.otrs_ticket_id +\n            '\\nMust be positive integer.';\n    }\n\n    if ([0, 1, 2, 3, 4, 5].indexOf(parseInt(params.event_nseverity)) === -1) {\n        params.event_nseverity = '7';\n    }\n\n    if (params.event_value === '0') {\n        params.event_nseverity = '6';\n    }\n\n    priority = params['severity_' + severities[params.event_nseverity].name];\n    priority = priority && priority.trim() || severities[7].name;\n\n    OTRS.setParams(params_otrs);\n    OTRS.HTTPProxy = params.HTTPProxy;\n\n    // Create ticket for non trigger-based events.\n    if (params.event_source !== '0'\n        && params.event_value !== '0') {\n        OTRS.createTicket(params.alert_subject, params.alert_message, priority);\n    }\n    // Create ticket for trigger-based events.\n    else if (params.event_value === '1' && params_update.status === '0') {\n        var ticket_id = OTRS.createTicket(params.alert_subject,\n            params.alert_subject + '\\n' + params.alert_message + '\\n' +\n            params.zabbix_url + (params.zabbix_url.endsWith('/') ? '' : '/') +\n            'tr_events.php?triggerid=' + params.trigger_id + '&eventid=' + params.event_id + '\\n',\n            priority,\n            params_fields);\n\n        result.tags.__zbx_otrs_ticket_id = ticket_id;\n        result.tags.__zbx_otrs_ticketlink = params.otrs_url +\n            (params.otrs_url.endsWith('/') ? '' : '/') + 'index.pl?Action=AgentTicketZoom;TicketID=' + ticket_id;\n    }\n    // Update created ticket for trigger-based event.\n    else {\n        OTRS.updateTicket(params.alert_subject, params.alert_message);\n    }\n\n    return JSON.stringify(result);\n}\ncatch (error) {\n    Zabbix.Log(3, '[ OTRS Webhook ] ERROR: ' + error);\n    throw 'Sending failed: ' + error;\n}",
                "process_tags": "YES",
                "show_event_menu": "YES",
                "event_menu_url": "{EVENT.TAGS.__zbx_otrs_ticketlink}",
                "event_menu_name": "OTRS: ticket #{EVENT.TAGS.__zbx_otrs_ticket_id}",
                "message_templates": [
                    {
                        "event_source": "TRIGGERS",
                        "operation_mode": "PROBLEM",
                        "subject": "Problem: {EVENT.NAME}",
                        "message": "Problem started at {EVENT.TIME} on {EVENT.DATE}\nProblem name: {EVENT.NAME}\nHost: {HOST.NAME}\nSeverity: {EVENT.SEVERITY}\nOperational data: {EVENT.OPDATA}\nOriginal problem ID: {EVENT.ID}\n{TRIGGER.URL}"
                    },
                    {
                        "event_source": "TRIGGERS",
                        "operation_mode": "RECOVERY",
                        "subject": "Resolved: {EVENT.NAME}",
                        "message": "Problem has been resolved in {EVENT.DURATION} at {EVENT.RECOVERY.TIME} on {EVENT.RECOVERY.DATE}\nProblem name: {EVENT.NAME}\nHost: {HOST.NAME}\nSeverity: {EVENT.SEVERITY}\nOriginal problem ID: {EVENT.ID}\n{TRIGGER.URL}"
                    },
                    {
                        "event_source": "TRIGGERS",
                        "operation_mode": "UPDATE",
                        "subject": "Updated problem: {EVENT.NAME}",
                        "message": "{USER.FULLNAME} {EVENT.UPDATE.ACTION} problem at {EVENT.UPDATE.DATE} {EVENT.UPDATE.TIME}.\n{EVENT.UPDATE.MESSAGE}\n\nCurrent problem status is {EVENT.STATUS}, acknowledged: {EVENT.ACK.STATUS}."
                    },
                    {
                        "event_source": "DISCOVERY",
                        "operation_mode": "PROBLEM",
                        "subject": "Discovery: {DISCOVERY.DEVICE.STATUS} {DISCOVERY.DEVICE.IPADDRESS}",
                        "message": "Discovery rule: {DISCOVERY.RULE.NAME}\n\nDevice IP: {DISCOVERY.DEVICE.IPADDRESS}\nDevice DNS: {DISCOVERY.DEVICE.DNS}\nDevice status: {DISCOVERY.DEVICE.STATUS}\nDevice uptime: {DISCOVERY.DEVICE.UPTIME}\n\nDevice service name: {DISCOVERY.SERVICE.NAME}\nDevice service port: {DISCOVERY.SERVICE.PORT}\nDevice service status: {DISCOVERY.SERVICE.STATUS}\nDevice service uptime: {DISCOVERY.SERVICE.UPTIME}"
                    },
                    {
                        "event_source": "AUTOREGISTRATION",
                        "operation_mode": "PROBLEM",
                        "subject": "Autoregistration: {HOST.HOST}",
                        "message": "Host name: {HOST.HOST}\nHost IP: {HOST.IP}\nAgent port: {HOST.PORT}"
                    }
                ]
            },
            {
                "name": "PagerDuty",
                "type": "WEBHOOK",
                "parameters": {
                    "16": {
                        "name": "alert_message",
                        "value": "{ALERT.MESSAGE}"
                    },
                    "12": {
                        "name": "eventack",
                        "value": "{EVENT.ACK.STATUS}"
                    },
                    "10": {
                        "name": "eventdate",
                        "value": "{EVENT.DATE}"
                    },
                    "1": {
                        "name": "eventid",
                        "value": "{EVENT.ID}"
                    },
                    "2": {
                        "name": "eventname",
                        "value": "{ALERT.SUBJECT}"
                    },
                    "8": {
                        "name": "eventtags",
                        "value": "{EVENT.TAGS}"
                    },
                    "11": {
                        "name": "eventtime",
                        "value": "{EVENT.TIME}"
                    },
                    "13": {
                        "name": "eventupdate",
                        "value": "{EVENT.UPDATE.STATUS}"
                    },
                    "14": {
                        "name": "eventvalue",
                        "value": "{EVENT.VALUE}"
                    },
                    "17": {
                        "name": "event_source",
                        "value": "{EVENT.SOURCE}"
                    },
                    "4": {
                        "name": "hostip",
                        "value": "{HOST.IP}"
                    },
                    "3": {
                        "name": "hostname",
                        "value": "{HOST.NAME}"
                    },
                    "5": {
                        "name": "severity",
                        "value": "{EVENT.NSEVERITY}"
                    },
                    "0": {
                        "name": "token",
                        "value": "<put your key>"
                    },
                    "6": {
                        "name": "triggerdesc",
                        "value": "{TRIGGER.DESCRIPTION}"
                    },
                    "9": {
                        "name": "triggerid",
                        "value": "{TRIGGER.ID}"
                    },
                    "7": {
                        "name": "triggeropdata",
                        "value": "{EVENT.OPDATA}"
                    },
                    "15": {
                        "name": "url",
                        "value": "{$ZABBIX.URL}"
                    }
                },
                "status": "DISABLED",
                "script": "try {\n\n    var params = JSON.parse(value),\n        req = new CurlHttpRequest(),\n        fields = {},\n        resp = '';\n\n    // Correspondence between the PagerDuty and Zabbix severity level\n    var severityMapping = [\n        'info',    // Not classified\n        'info',    // Information\n        'warning', // Warning\n        'warning', // Average\n        'error',   // High\n        'critical' // Disaster\n    ];\n\n    if (!severityMapping[params.severity]) {\n        params.severity = '0';\n    }\n\n    if (typeof params.HTTPProxy === 'string' && params.HTTPProxy.trim() !== '') {\n        req.SetProxy(params.HTTPProxy);\n    }\n\n    if (isNaN(parseInt(params.eventid)) || params.eventid < 1) {\n        throw 'incorrect value for variable \"eventid\". The value must be a positive number.';\n    }\n    if (params.eventname.length < 1) {\n        throw 'incorrect value for variable \"eventname\". The value must be a non-empty string.';\n    }\n    if (isNaN(parseInt(params.severity)) || (params.severity < 0 && params.severity > 5)) {\n        throw 'incorrect value for variable \"severity\". The value must be a number 0..5.';\n    }\n\n    if ([0, 1, 2, 3].indexOf(parseInt(params.event_source)) === -1) {\n        throw 'Incorrect \"event_source\" parameter given: \"' + params.event_source + '\".\\nMust be 0-3.';\n    }\n    // Check {EVENT.VALUE} for trigger-based and internal events.\n    if (params.eventvalue !== '0' && params.eventvalue !== '1'\n        && (params.event_source === '0' || params.event_source === '3')) {\n        throw 'Incorrect \"eventvalue\" parameter given: \"' + params.eventvalue + '\".\\nMust be 0 or 1.';\n    }\n\n    if (params.event_source === '0') {\n        if (params.hostname.length < 1) {\n            throw 'incorrect value for variable \"hostname\". The value must be a non-empty string.';\n        }\n        if (isNaN(parseInt(params.triggerid)) || params.triggerid < 1) {\n            throw 'incorrect value for variable \"triggerid\". The value must be a positive number.';\n        }\n        if (params.eventack != 'Yes' && params.eventack != 'No') {\n            throw 'incorrect value for variable \"eventack\". The value must be Yes or No.';\n        }\n        if (isNaN(parseInt(params.eventupdate)) || (params.eventupdate < 0 || params.eventupdate > 1)) {\n            throw 'incorrect value for variable \"eventupdate\". The value must be 0 or 1.';\n        }\n    }\n\n\n\n    req.AddHeader('Content-Type: application/json');\n\n    fields.routing_key = params.token;\n    fields.dedup_key = params.eventid;\n\n    if (((params.eventvalue == 1) && (params.eventupdate == 0)) || params.event_source !== '0') {\n        fields.event_action = 'trigger';\n        fields.payload = {\n            summary: params.eventname,\n            source: (params.event_source === '1') ? 'Discovery' : params.hostname + ' : ' + params.hostip,\n            severity: severityMapping[params.severity],\n        };\n        \n        if (params.event_source === '0') {\n            fields.payload.custom_details = {\n                'Event date': params.eventdate,\n                'Event time': params.eventtime,\n                'Trigger description': params.triggerdesc,\n                'Trigger opdata': params.triggeropdata,\n                'Event tags': params.eventtags,\n                'Event host': params.hostname,\n                'Event host ip': params.hostip\n            };\n            fields.links = [{\n                href: params.url + '/tr_events.php?triggerid=' + params.triggerid + '&eventid=' + params.eventid,\n                text: 'Event link'\n            }];\n        }\n        else {\n            fields.payload.custom_details = {\n                'Alert message': params.alert_message\n            };\n        }\n\n        fields.client = 'Zabbix';\n        fields.client_url = params.url;\n    }\n    else if ((params.eventvalue == 1) && (params.eventupdate == 1) && (params.eventack == 'Yes'))\n        fields.event_action = 'acknowledge';\n    else if (params.eventvalue == 0)\n        fields.event_action = 'resolve';\n    else\n        throw 'incorrect values. Update message without ack will not be sent.';\n\n    Zabbix.Log(4, '[PagerDuty Webhook] Sending request:' + JSON.stringify(fields));\n    resp = req.Post('https://events.pagerduty.com/v2/enqueue',\n        JSON.stringify(fields)\n    );\n    Zabbix.Log(4, '[PagerDuty Webhook] Receiving response:' + resp);\n\n    try {\n        resp = JSON.parse(resp);\n    }\n    catch (error) {\n        throw 'incorrect response. PagerDuty returned a non-JSON object.';\n    }\n\n    if (req.Status() != 202) {\n        if (typeof resp === 'object' && typeof resp.errors === 'object' && typeof resp.errors[0] === 'string') {\n            throw resp.errors[0];\n        }\n        else {\n            throw 'Unknown error.';\n        }\n    }\n\n    if (resp.status != 'success') {\n        throw 'Unknown error.';\n    }\n\n    return 'OK';\n}\ncatch (error) {\n    Zabbix.Log(3, '[PagerDuty Webhook] Notification failed : ' + error);\n    throw 'PagerDuty notification failed : ' + error;\n}",
                "description": "Please refer to https://v2.developer.pagerduty.com/docs/send-an-event-events-api-v2 and https://www.zabbix.com/documentation/5.2/manual/config/notifications/media/webhook#example_scripts.\n  \nSet global macro {$ZABBIX.URL} with your Zabbix server URL.\nAdd a dedicated user with the media type \"PagerDuty\" and place the integration key in the \"token\" parameter to integrate into the service.",
                "message_templates": [
                    {
                        "event_source": "TRIGGERS",
                        "operation_mode": "PROBLEM",
                        "subject": "Problem: {EVENT.NAME}",
                        "message": "Problem started at {EVENT.TIME} on {EVENT.DATE}\nProblem name: {EVENT.NAME}\nHost: {HOST.NAME}\nSeverity: {EVENT.SEVERITY}\nOperational data: {EVENT.OPDATA}\nOriginal problem ID: {EVENT.ID}\n{TRIGGER.URL}"
                    },
                    {
                        "event_source": "TRIGGERS",
                        "operation_mode": "RECOVERY",
                        "subject": "Resolved in {EVENT.DURATION}: {EVENT.NAME}",
                        "message": "Problem has been resolved at {EVENT.RECOVERY.TIME} on {EVENT.RECOVERY.DATE}\nProblem name: {EVENT.NAME}\nProblem duration: {EVENT.DURATION}\nHost: {HOST.NAME}\nSeverity: {EVENT.SEVERITY}\nOriginal problem ID: {EVENT.ID}\n{TRIGGER.URL}"
                    },
                    {
                        "event_source": "TRIGGERS",
                        "operation_mode": "UPDATE",
                        "subject": "Updated problem in {EVENT.AGE}: {EVENT.NAME}",
                        "message": "{USER.FULLNAME} {EVENT.UPDATE.ACTION} problem at {EVENT.UPDATE.DATE} {EVENT.UPDATE.TIME}.\n{EVENT.UPDATE.MESSAGE}\n\nCurrent problem status is {EVENT.STATUS}, age is {EVENT.AGE}, acknowledged: {EVENT.ACK.STATUS}."
                    },
                    {
                        "event_source": "DISCOVERY",
                        "operation_mode": "PROBLEM",
                        "subject": "Discovery: {DISCOVERY.DEVICE.STATUS} {DISCOVERY.DEVICE.IPADDRESS}",
                        "message": "Discovery rule: {DISCOVERY.RULE.NAME}\n\nDevice IP: {DISCOVERY.DEVICE.IPADDRESS}\nDevice DNS: {DISCOVERY.DEVICE.DNS}\nDevice status: {DISCOVERY.DEVICE.STATUS}\nDevice uptime: {DISCOVERY.DEVICE.UPTIME}\n\nDevice service name: {DISCOVERY.SERVICE.NAME}\nDevice service port: {DISCOVERY.SERVICE.PORT}\nDevice service status: {DISCOVERY.SERVICE.STATUS}\nDevice service uptime: {DISCOVERY.SERVICE.UPTIME}"
                    },
                    {
                        "event_source": "AUTOREGISTRATION",
                        "operation_mode": "PROBLEM",
                        "subject": "Autoregistration: {HOST.HOST}",
                        "message": "Host name: {HOST.HOST}\nHost IP: {HOST.IP}\nAgent port: {HOST.PORT}"
                    }
                ]
            },
            {
                "name": "Pushover",
                "type": "WEBHOOK",
                "parameters": {
                    "8": {
                        "name": "endpoint",
                        "value": "https://api.pushover.net/1/messages.json"
                    },
                    "6": {
                        "name": "eventid",
                        "value": "{EVENT.ID}"
                    },
                    "11": {
                        "name": "event_nseverity",
                        "value": "{EVENT.NSEVERITY}"
                    },
                    "12": {
                        "name": "event_source",
                        "value": "{EVENT.SOURCE}"
                    },
                    "13": {
                        "name": "event_value",
                        "value": "{EVENT.VALUE}"
                    },
                    "10": {
                        "name": "expire",
                        "value": "1200"
                    },
                    "2": {
                        "name": "message",
                        "value": "{ALERT.MESSAGE}"
                    },
                    "14": {
                        "name": "priority_average",
                        "value": "0"
                    },
                    "15": {
                        "name": "priority_default",
                        "value": "0"
                    },
                    "16": {
                        "name": "priority_disaster",
                        "value": "0"
                    },
                    "17": {
                        "name": "priority_high",
                        "value": "0"
                    },
                    "18": {
                        "name": "priority_information",
                        "value": "0"
                    },
                    "19": {
                        "name": "priority_not_classified",
                        "value": "0"
                    },
                    "20": {
                        "name": "priority_warning",
                        "value": "0"
                    },
                    "9": {
                        "name": "retry",
                        "value": "60"
                    },
                    "3": {
                        "name": "title",
                        "value": "{ALERT.SUBJECT}"
                    },
                    "0": {
                        "name": "token",
                        "value": "<PUSHOVER TOKEN HERE>"
                    },
                    "7": {
                        "name": "triggerid",
                        "value": "{TRIGGER.ID}"
                    },
                    "4": {
                        "name": "url",
                        "value": "{$ZABBIX.URL}"
                    },
                    "5": {
                        "name": "url_title",
                        "value": "Zabbix"
                    },
                    "1": {
                        "name": "user",
                        "value": "{ALERT.SENDTO}"
                    }
                },
                "status": "DISABLED",
                "max_sessions": "0",
                "script": "try {\n    var params = JSON.parse(value),\n        request = new CurlHttpRequest(),\n        data,\n        response,\n        severities = [\n            {name: 'not_classified', color: '#97AAB3'},\n            {name: 'information', color: '#7499FF'},\n            {name: 'warning', color: '#FFC859'},\n            {name: 'average', color: '#FFA059'},\n            {name: 'high', color: '#E97659'},\n            {name: 'disaster', color: '#E45959'},\n            {name: 'resolved', color: '#009900'},\n            {name: 'default', color: '#000000'}\n        ],\n        priority;\n\n    if (typeof params.HTTPProxy === 'string' && params.HTTPProxy.trim() !== '') {\n        request.SetProxy(params.HTTPProxy);\n    }\n\n    if ([0, 1, 2, 3].indexOf(parseInt(params.event_source)) === -1) {\n        throw 'Incorrect \"event_source\" parameter given: \"' + params.event_source + '\".\\nMust be 0-3.';\n    }\n\n    if (params.event_value !== '0' && params.event_value !== '1'\n        && (params.event_source === '0' || params.event_source === '3')) {\n        throw 'Incorrect \"event_value\" parameter given: ' + params.event_value + '\\nMust be 0 or 1.';\n    }\n\n    if ([0, 1, 2, 3, 4, 5].indexOf(parseInt(params.event_nseverity)) === -1) {\n        params.event_nseverity = '7';\n    }\n\n    if (params.event_value === '0') {\n        params.event_nseverity = '6';\n    }\n\n    priority = params['priority_' + severities[params.event_nseverity].name] || params.priority_default;\n\n    if (isNaN(priority) || priority < -2 || priority > 2) {\n        throw '\"priority\" should be -2..2';\n    }\n\n    if (params.event_source === '0' && isNaN(params.triggerid)) {\n        throw 'field \"triggerid\" is not a number';\n    }\n\n    if (isNaN(params.eventid)) {\n        throw 'field \"eventid\" is not a number';\n    }\n\n    if (typeof params.message !== 'string' || params.message.trim() === '') {\n        throw 'field \"message\" cannot be empty';\n    }\n\n    data = {\n        token: params.token,\n        user: params.user,\n        title: params.title,\n        message: params.message,\n        url: (params.event_source === '0') \n            ? params.url + '/tr_events.php?triggerid=' + params.triggerid + '&eventid=' + params.eventid\n            : params.url,\n        url_title: params.url_title,\n        priority: priority\n    };\n\n    if (priority == 2) {\n        if (isNaN(params.retry) || params.retry < 30) {\n            throw 'field \"retry\" should be a number with value of at least 30 if \"priority\" is set to 2';\n        }\n\n        if (isNaN(params.expire) || params.expire > 10800) {\n            throw 'field \"expire\" should be a number with value of at most 10800 if \"priority\" is set to 2';\n        }\n\n        data.retry = params.retry;\n        data.expire = params.expire;\n    }\n\n    data = JSON.stringify(data);\n    Zabbix.Log(4, '[ Pushover Webhook ] Sending request: ' + params.endpoint + '\\n' + data);\n\n    request.AddHeader('Content-Type: application/json');\n    response = request.Post(params.endpoint, data);\n\n    Zabbix.Log(4, '[ Pushover Webhook ] Received response with status code ' + request.Status() + '\\n' + response);\n\n    if (response !== null) {\n        try {\n            response = JSON.parse(response);\n        }\n        catch (error) {\n            Zabbix.Log(4, '[ Pushover Webhook ] Failed to parse response received from Pushover');\n            response = null;\n        }\n    }\n\n    if (request.Status() != 200 || response === null || typeof response !== 'object' || response.status !== 1) {\n        if (response !== null && typeof response === 'object' && typeof response.errors === 'object'\n                && typeof response.errors[0] === 'string') {\n            throw response.errors[0];\n        }\n        else {\n            throw 'Unknown error. Check debug log for more information.';\n        }\n    }\n\n    return 'OK';\n}\ncatch (error) {\n    Zabbix.Log(4, '[ Pushover Webhook ] Pushover notification failed: ' + error);\n    throw 'Pushover notification failed: ' + error;\n}",
                "description": "Please refer to setup guide here: https://git.zabbix.com/projects/ZBX/repos/zabbix/browse/templates/media/pushover\n\nSet token parameter with to your Pushover application key.\nWhen assigning Pushover media to the Zabbix user - add user key into send to field.",
                "message_templates": [
                    {
                        "event_source": "TRIGGERS",
                        "operation_mode": "PROBLEM",
                        "subject": "Problem: {EVENT.NAME}",
                        "message": "Problem started at {EVENT.TIME} on {EVENT.DATE}\nProblem name: {EVENT.NAME}\nHost: {HOST.NAME}\nSeverity: {EVENT.SEVERITY}\nOperational data: {EVENT.OPDATA}\nOriginal problem ID: {EVENT.ID}\n{TRIGGER.URL}"
                    },
                    {
                        "event_source": "TRIGGERS",
                        "operation_mode": "RECOVERY",
                        "subject": "Resolved in {EVENT.DURATION}: {EVENT.NAME}",
                        "message": "Problem has been resolved at {EVENT.RECOVERY.TIME} on {EVENT.RECOVERY.DATE}\nProblem name: {EVENT.NAME}\nProblem duration: {EVENT.DURATION}\nHost: {HOST.NAME}\nSeverity: {EVENT.SEVERITY}\nOriginal problem ID: {EVENT.ID}\n{TRIGGER.URL}"
                    },
                    {
                        "event_source": "TRIGGERS",
                        "operation_mode": "UPDATE",
                        "subject": "Updated problem in {EVENT.AGE}: {EVENT.NAME}",
                        "message": "{USER.FULLNAME} {EVENT.UPDATE.ACTION} problem at {EVENT.UPDATE.DATE} {EVENT.UPDATE.TIME}.\n{EVENT.UPDATE.MESSAGE}\n\nCurrent problem status is {EVENT.STATUS}, age is {EVENT.AGE}, acknowledged: {EVENT.ACK.STATUS}."
                    },
                    {
                        "event_source": "DISCOVERY",
                        "operation_mode": "PROBLEM",
                        "subject": "Discovery: {DISCOVERY.DEVICE.STATUS} {DISCOVERY.DEVICE.IPADDRESS}",
                        "message": "Discovery rule: {DISCOVERY.RULE.NAME}\n\nDevice IP: {DISCOVERY.DEVICE.IPADDRESS}\nDevice DNS: {DISCOVERY.DEVICE.DNS}\nDevice status: {DISCOVERY.DEVICE.STATUS}\nDevice uptime: {DISCOVERY.DEVICE.UPTIME}\n\nDevice service name: {DISCOVERY.SERVICE.NAME}\nDevice service port: {DISCOVERY.SERVICE.PORT}\nDevice service status: {DISCOVERY.SERVICE.STATUS}\nDevice service uptime: {DISCOVERY.SERVICE.UPTIME}"
                    },
                    {
                        "event_source": "AUTOREGISTRATION",
                        "operation_mode": "PROBLEM",
                        "subject": "Autoregistration: {HOST.HOST}",
                        "message": "Host name: {HOST.HOST}\nHost IP: {HOST.IP}\nAgent port: {HOST.PORT}"
                    }
                ]
            },
            {
                "name": "Redmine",
                "type": "WEBHOOK",
                "parameters": [
                    {
                        "name": "alert_message",
                        "value": "{ALERT.MESSAGE}"
                    },
                    {
                        "name": "alert_subject",
                        "value": "{ALERT.SUBJECT}"
                    },
                    {
                        "name": "event_id",
                        "value": "{EVENT.ID}"
                    },
                    {
                        "name": "event_nseverity",
                        "value": "{EVENT.NSEVERITY}"
                    },
                    {
                        "name": "event_source",
                        "value": "{EVENT.SOURCE}"
                    },
                    {
                        "name": "event_update_message",
                        "value": "{EVENT.UPDATE.MESSAGE}"
                    },
                    {
                        "name": "event_update_status",
                        "value": "{EVENT.UPDATE.STATUS}"
                    },
                    {
                        "name": "event_value",
                        "value": "{EVENT.VALUE}"
                    },
                    {
                        "name": "redmine_access_key",
                        "value": "<PUT YOUR ACCESS KEY>"
                    },
                    {
                        "name": "redmine_issue_key",
                        "value": "{EVENT.TAGS.__zbx_redmine_issue_id}"
                    },
                    {
                        "name": "redmine_project",
                        "value": "<PUT YOUR PROJECT ID OR NAME>"
                    },
                    {
                        "name": "redmine_tracker_id",
                        "value": "<PUT YOUR TRACKER ID>"
                    },
                    {
                        "name": "redmine_url",
                        "value": "<PUT YOUR REDMINE URL>"
                    },
                    {
                        "name": "trigger_id",
                        "value": "{TRIGGER.ID}"
                    },
                    {
                        "name": "zabbix_url",
                        "value": "{$ZABBIX.URL}"
                    }
                ],
                "status": "DISABLED",
                "script": "var Redmine = {\n    params: {},\n\n    setParams: function (params) {\n        if (typeof params !== 'object') {\n            return;\n        }\n\n        Redmine.params = params;\n        if (typeof Redmine.params.url === 'string') {\n            if (!Redmine.params.url.endsWith('/')) {\n                Redmine.params.url += '/';\n            }\n        }\n    },\n\n    addCustomFields: function (data, fields) {\n        if (typeof fields === 'object' && Object.keys(fields).length) {\n            var schema = Redmine.getSchema();\n\n            if (schema) {\n                data.issue.custom_fields = [];\n\n                Object.keys(fields)\n                    .forEach(function(field) {\n                        for (var idx in schema.custom_fields) {\n                            if (schema.custom_fields[idx].id != field) {\n                                continue;\n                            }\n\n                            var field_value;\n\n                            switch (schema.custom_fields[idx].field_format) {\n                                case 'string':\n                                    field_value = fields[field];\n                                    break;\n\n                                case 'int':\n                                    field_value = parseInt(fields[field]);\n                                    break;\n\n                                case 'float':\n                                    field_value = parseFloat(fields[field]);\n                                    break;\n\n                                case 'date':\n                                    if (fields[field].match(/^\\d{4}[.-]\\d{2}[.-]\\d{2}$/)) {\n                                        field_value = fields[field].replace(/\\./g, '-');\n                                    }\n                                    break;\n                            }\n\n                            if (field_value !== undefined) {\n                                data.issue.custom_fields.push({id: field, value: field_value});\n                            }\n                        }\n                    });\n            }\n            else {\n                Zabbix.Log(4, '[ Redmine Webhook ] Failed to retrieve field schema.');\n            }\n        }\n\n        return data;\n    },\n\n    request: function (method, query, data) {\n        ['url', 'access_key'].forEach(function (field) {\n            if (typeof Redmine.params !== 'object' || typeof Redmine.params[field] === 'undefined'\n                || Redmine.params[field] === '' ) {\n                throw 'Required param is not set: \"' + field + '\".';\n            }\n        });\n\n        var response,\n            url = Redmine.params.url + query,\n            request = new CurlHttpRequest();\n\n        if (typeof Redmine.HTTPProxy === 'string' && Redmine.HTTPProxy.trim() !== '') {\n            request.SetProxy(Redmine.HTTPProxy);\n        }\n\n        request.AddHeader('Content-Type: application/json');\n        request.AddHeader('X-Redmine-API-Key: ' + Redmine.params.access_key);\n\n        if (typeof data !== 'undefined') {\n            data = JSON.stringify(data);\n        }\n\n        Zabbix.Log(4, '[ Redmine Webhook ] Sending request: ' +\n            url + ((typeof data === 'string') ? (' ' + data) : ''));\n\n        switch (method) {\n            case 'get':\n                response = request.Get(url, data);\n                break;\n\n            case 'post':\n                response = request.Post(url, data);\n                break;\n\n            case 'put':\n                response = request.Put(url, data);\n                break;\n\n            default:\n                throw 'Unsupported HTTP request method: ' + method;\n        }\n\n        Zabbix.Log(4, '[ Redmine Webhook ] Received response with status code ' + request.Status() + ': ' + response);\n\n        if (response !== null) {\n            try {\n                response = JSON.parse(response);\n            }\n            catch (error) {\n                Zabbix.Log(4, '[ Redmine Webhook ] Failed to parse response received from Redmine');\n                response = null;\n            }\n        }\n\n        if (request.Status() < 200 || request.Status() >= 300) {\n            var message = 'Request failed with status code ' + request.Status();\n\n            if (response !== null && typeof response.errors !== 'undefined'\n                && Object.keys(response.errors).length > 0) {\n                message += ': ' + JSON.stringify(response.errors);\n            }\n            else if (response !== null && typeof response.errorMessages !== 'undefined'\n                && Object.keys(response.errorMessages).length > 0) {\n                message += ': ' + JSON.stringify(response.errorMessages);\n            }\n\n            throw message + ' Check debug log for more information.';\n        }\n\n        return {\n            status: request.Status(),\n            response: response\n        };\n    },\n\n    getProjectID: function(name) {\n        var result = Redmine.request('get', 'projects.json'),\n            project_id;\n\n        if (result.response) {\n            var projects = result.response.projects || [];\n\n            for (var i in projects) {\n                if (projects[i].name === name) {\n                    project_id = projects[i].id;\n                    break;\n                }\n            }\n        }\n        else {\n            Zabbix.Log(4, '[ Redmine Webhook ] Failed to retrieve project data.');\n        }\n\n        if (typeof project_id === 'undefined') {\n            throw 'Cannot find project with name: ' + name;\n        }\n\n        return project_id;\n    },\n\n    getSchema: function() {\n        var result = Redmine.request('get', 'custom_fields.json');\n\n        return result.response;\n    },\n\n    createIssue: function(subject, description, priority, fields) {\n        var project_id = /^\\d+$/.test(Redmine.params.project)\n                ? Redmine.params.project\n                : Redmine.getProjectID(Redmine.params.project),\n            data = {\n                issue: {\n                    project_id: project_id,\n                    tracker_id: Redmine.params.tracker_id,\n                    subject: subject,\n                    description: description\n                }\n            },\n            result;\n\n        if (priority) {\n            data.issue.priority_id = priority;\n        }\n\n        result = Redmine.request('post', 'issues.json', Redmine.addCustomFields(data, fields));\n\n        if (typeof result.response !== 'object'\n            || typeof result.response.issue.id === 'undefined'\n            || result.status != 201) {\n            throw 'Cannot create Redmine issue. Check debug log for more information.';\n        }\n\n        return result.response.issue.id;\n    },\n\n    updateIssue: function(note, fields) {\n        var data = {\n            issue: {\n                notes: note || ''\n            }\n        };\n\n        Redmine.request('put', 'issues/' + Redmine.params.issue_key + '.json', Redmine.addCustomFields(data, fields));\n    }\n};\n\ntry {\n    var params = JSON.parse(value),\n        params_redmine = {},\n        params_fields = {},\n        params_update = {},\n        result = {tags: {}},\n        required_params = [\n            'alert_subject', 'tracker_id', 'project',\n            'event_source', 'event_value',  'event_update_status'\n        ],\n        severities = [\n            {name: 'not_classified', color: '#97AAB3'},\n            {name: 'information', color: '#7499FF'},\n            {name: 'warning', color: '#FFC859'},\n            {name: 'average', color: '#FFA059'},\n            {name: 'high', color: '#E97659'},\n            {name: 'disaster', color: '#E45959'},\n            {name: 'resolved', color: '#009900'},\n            {name: null, color: '#000000'}\n        ],\n        priority;\n\n    Object.keys(params)\n        .forEach(function (key) {\n            if (key.startsWith('redmine_')) {\n                params_redmine[key.substring(8)] = params[key];\n            }\n            else if (key.startsWith('customfield_')) {\n                params_fields[key.substring(12)] = params[key];\n            }\n            else if (key.startsWith('event_update_')) {\n                params_update[key.substring(13)] = params[key];\n            }\n            else if (required_params.indexOf(key) !== -1 && params[key].trim() === '') {\n                throw 'Parameter \"' + key + '\" cannot be empty.';\n            }\n        });\n\n    if ([0, 1, 2, 3].indexOf(parseInt(params.event_source)) === -1) {\n        throw 'Incorrect \"event_source\" parameter given: ' + params.event_source + '\\nMust be 0-3.';\n    }\n\n    // Check {EVENT.VALUE} for trigger-based and internal events.\n    if (params.event_value !== '0' && params.event_value !== '1'\n        && (params.event_source === '0' || params.event_source === '3')) {\n        throw 'Incorrect \"event_value\" parameter given: ' + params.event_value + '\\nMust be 0 or 1.';\n    }\n\n    // Check {EVENT.UPDATE.STATUS} only for trigger-based events.\n    if (params.event_source === '0' && params.event_update_status !== '0' && params.event_update_status !== '1') {\n        throw 'Incorrect \"event_update_status\" parameter given: ' + params.event_update_status + '\\nMust be 0 or 1.';\n    }\n\n    if (params.event_source !== '0' && params.event_value === '0') {\n        throw 'Recovery operations are supported only for trigger-based actions.';\n    }\n\n    if (params.event_source === '0'\n        && ((params.event_value === '1' && params.event_update_status === '1')\n            || (params.event_value === '0'\n                && (params.event_update_status === '0' || params.event_update_status === '1')))\n        && (isNaN(parseInt(params.redmine_issue_key)) || parseInt(params.redmine_issue_key) < 1 )) {\n        throw 'Incorrect \"redmine_issue_key\" parameter given: ' + params.redmine_issue_key +\n            '\\nMust be positive integer.';\n    }\n\n    if ([0, 1, 2, 3, 4, 5].indexOf(parseInt(params.event_nseverity)) === -1) {\n        params.event_nseverity = '7';\n    }\n\n    if (params.event_value === '0') {\n        params.event_nseverity = '6';\n    }\n\n    priority = params['severity_' + severities[params.event_nseverity].name];\n    priority = priority && priority.trim() || severities[7].name;\n\n    Redmine.setParams(params_redmine);\n    Redmine.HTTPProxy = params.HTTPProxy;\n\n    // Create issue for non trigger-based events.\n    if (params.event_source !== '0'\n        && params.event_value !== '0') {\n        Redmine.createIssue(params.alert_subject, params.alert_message, priority);\n    }\n    // Create issue for trigger-based events.\n    else if (params.event_value === '1' && params_update.status === '0') {\n        var issue_id = Redmine.createIssue(params.alert_subject,\n            params.alert_subject + '\\n' + params.alert_message + '\\n' +\n            params.zabbix_url + (params.zabbix_url.endsWith('/') ? '' : '/') +\n            'tr_events.php?triggerid=' + params.trigger_id + '&eventid=' + params.event_id + '\\n',\n            priority,\n            params_fields);\n\n        result.tags.__zbx_redmine_issue_id = issue_id;\n        result.tags.__zbx_redmine_issuelink = params.redmine_url +\n            (params.redmine_url.endsWith('/') ? '' : '/') + 'issues/' + issue_id;\n    }\n    // Update created issue for trigger-based event.\n    else {\n        Redmine.updateIssue(params.alert_subject + '\\n' + params.alert_message, params_fields);\n    }\n\n    return JSON.stringify(result);\n}\ncatch (error) {\n    Zabbix.Log(3, '[ Redmine Webhook ] ERROR: ' + error);\n    throw 'Sending failed: ' + error;\n}",
                "process_tags": "YES",
                "show_event_menu": "YES",
                "event_menu_url": "{EVENT.TAGS.__zbx_redmine_issuelink}",
                "event_menu_name": "Redmine: issue #{EVENT.TAGS.__zbx_redmine_issue_id}",
                "message_templates": [
                    {
                        "event_source": "TRIGGERS",
                        "operation_mode": "PROBLEM",
                        "subject": "Problem: {EVENT.NAME}",
                        "message": "Problem started at {EVENT.TIME} on {EVENT.DATE}\nProblem name: {EVENT.NAME}\nHost: {HOST.NAME}\nSeverity: {EVENT.SEVERITY}\nOperational data: {EVENT.OPDATA}\nOriginal problem ID: {EVENT.ID}\n{TRIGGER.URL}"
                    },
                    {
                        "event_source": "TRIGGERS",
                        "operation_mode": "RECOVERY",
                        "subject": "Resolved: {EVENT.NAME}",
                        "message": "Problem has been resolved in {EVENT.DURATION} at {EVENT.RECOVERY.TIME} on {EVENT.RECOVERY.DATE}\nProblem name: {EVENT.NAME}\nHost: {HOST.NAME}\nSeverity: {EVENT.SEVERITY}\nOriginal problem ID: {EVENT.ID}\n{TRIGGER.URL}"
                    },
                    {
                        "event_source": "TRIGGERS",
                        "operation_mode": "UPDATE",
                        "subject": "Updated problem: {EVENT.NAME}",
                        "message": "{USER.FULLNAME} {EVENT.UPDATE.ACTION} problem at {EVENT.UPDATE.DATE} {EVENT.UPDATE.TIME}.\n{EVENT.UPDATE.MESSAGE}\n\nCurrent problem status is {EVENT.STATUS}, acknowledged: {EVENT.ACK.STATUS}."
                    },
                    {
                        "event_source": "DISCOVERY",
                        "operation_mode": "PROBLEM",
                        "subject": "Discovery: {DISCOVERY.DEVICE.STATUS} {DISCOVERY.DEVICE.IPADDRESS}",
                        "message": "Discovery rule: {DISCOVERY.RULE.NAME}\n\nDevice IP: {DISCOVERY.DEVICE.IPADDRESS}\nDevice DNS: {DISCOVERY.DEVICE.DNS}\nDevice status: {DISCOVERY.DEVICE.STATUS}\nDevice uptime: {DISCOVERY.DEVICE.UPTIME}\n\nDevice service name: {DISCOVERY.SERVICE.NAME}\nDevice service port: {DISCOVERY.SERVICE.PORT}\nDevice service status: {DISCOVERY.SERVICE.STATUS}\nDevice service uptime: {DISCOVERY.SERVICE.UPTIME}"
                    },
                    {
                        "event_source": "AUTOREGISTRATION",
                        "operation_mode": "PROBLEM",
                        "subject": "Autoregistration: {HOST.HOST}",
                        "message": "Host name: {HOST.HOST}\nHost IP: {HOST.IP}\nAgent port: {HOST.PORT}"
                    }
                ]
            },
            {
                "name": "Rocket.Chat",
                "type": "WEBHOOK",
                "parameters": [
                    {
                        "name": "alert_message",
                        "value": "{ALERT.MESSAGE}"
                    },
                    {
                        "name": "alert_subject",
                        "value": "{ALERT.SUBJECT}"
                    },
                    {
                        "name": "event_nseverity",
                        "value": "{EVENT.NSEVERITY}"
                    },
                    {
                        "name": "event_source",
                        "value": "{EVENT.SOURCE}"
                    },
                    {
                        "name": "event_update_action",
                        "value": "{EVENT.UPDATE.ACTION}"
                    },
                    {
                        "name": "event_update_message",
                        "value": "{EVENT.UPDATE.MESSAGE}"
                    },
                    {
                        "name": "event_update_status",
                        "value": "{EVENT.UPDATE.STATUS}"
                    },
                    {
                        "name": "event_update_user",
                        "value": "{USER.FULLNAME}"
                    },
                    {
                        "name": "event_value",
                        "value": "{EVENT.VALUE}"
                    },
                    {
                        "name": "field_1_full:Host",
                        "value": "{HOST.NAME} [{HOST.IP}]"
                    },
                    {
                        "name": "field_2_short:Severity",
                        "value": "{EVENT.SEVERITY}"
                    },
                    {
                        "name": "field_3_short:Event time",
                        "value": "{EVENT.DATE} {EVENT.TIME}"
                    },
                    {
                        "name": "field_3_short_r:Recovery time",
                        "value": "{EVENT.RECOVERY.DATE} {EVENT.RECOVERY.TIME}"
                    },
                    {
                        "name": "field_4_short_r:Event duration",
                        "value": "{EVENT.DURATION}"
                    },
                    {
                        "name": "field_5_short:Operational data",
                        "value": "{EVENT.OPDATA}"
                    },
                    {
                        "name": "field_999_full_p:Trigger description",
                        "value": "{TRIGGER.DESCRIPTION}"
                    },
                    {
                        "name": "rc_api_url",
                        "value": "api/v1/"
                    },
                    {
                        "name": "rc_msg_id",
                        "value": "{EVENT.TAGS.__zbx_rc_id}"
                    },
                    {
                        "name": "rc_room_id",
                        "value": "{EVENT.TAGS.__zbx_rc_rid}"
                    },
                    {
                        "name": "rc_send_to",
                        "value": "{ALERT.SENDTO}"
                    },
                    {
                        "name": "rc_title_link",
                        "value": "{$ZABBIX.URL}/tr_events.php?triggerid={TRIGGER.ID}&eventid={EVENT.ID}"
                    },
                    {
                        "name": "rc_url",
                        "value": "<PLACE YOUR INSTANCE URL HERE>"
                    },
                    {
                        "name": "rc_user_id",
                        "value": "<PLACE USER ID HERE>"
                    },
                    {
                        "name": "rc_user_token",
                        "value": "<PLACE TOKEN HERE>"
                    },
                    {
                        "name": "use_default_message",
                        "value": "false"
                    }
                ],
                "status": "DISABLED",
                "script": "var RocketChat = {\n    params: {},\n\n    setParams: function (params) {\n        if (typeof params !== 'object') {\n            return;\n        }\n\n        RocketChat.params = params;\n        if (RocketChat.params.url && RocketChat.params.api_url) {\n            if (!RocketChat.params.url.endsWith('/')) {\n                RocketChat.params.url += '/';\n            }\n            if (!RocketChat.params.api_url.endsWith('/')) {\n                RocketChat.params.api_url += '/';\n            }\n            if (RocketChat.params.api_url.startsWith('/')) {\n                RocketChat.params.api_url = RocketChat.params.api_url.substring(1);\n            }\n\n            RocketChat.params.url += RocketChat.params.api_url;\n        }\n    },\n\n    setProxy: function (HTTPProxy) {\n        RocketChat.HTTPProxy = HTTPProxy;\n    },\n\n    addFields: function (fields) {\n        var data = [];\n\n        if (typeof fields === 'object' && Object.keys(fields).length) {\n            Object.keys(fields)\n                .forEach(function(field) {\n                    if (fields[field] === '') {\n                        Zabbix.Log(4, '[ RocketChat Webhook ] Field \"' + field +\n                            '\" can\\'t be empty. The field ignored.');\n                    }\n                    else {\n                        try {\n                            var parts = field.split(':'),\n                                prefix = parts[0].split('_');\n\n                            if (typeof prefix[2] === 'undefined'\n                                    || (prefix[2] === 'p' && params.event_value === '1')\n                                    || (prefix[2] === 'r' && params.event_value === '0')) {\n                                data.push({\n                                    title: field.substring(field.indexOf(':') + 1),\n                                    value: fields[field],\n                                    short: prefix[1] === 'short'\n                                });\n                            }\n                        }\n                        catch (error) {\n                            Zabbix.Log(4, '[ RocketChat Webhook ] Can\\'t parse field \"' + field +\n                                '\". The field ignored.');\n                        }\n                    }\n                });\n        }\n\n        return data;\n    },\n\n    request: function (method, query, data) {\n        ['url', 'api_url', 'user_id', 'user_token', 'send_to'].forEach(function (field) {\n            if (typeof RocketChat.params !== 'object' || typeof RocketChat.params[field] === 'undefined'\n                    || RocketChat.params[field] === '' ) {\n                throw 'Required parameter is not set: \"' + field + '\".';\n            }\n        });\n\n        var response,\n            url = RocketChat.params.url + query,\n            request = new CurlHttpRequest();\n\n        request.AddHeader('Content-Type: application/json');\n        request.AddHeader('X-Auth-Token:' + RocketChat.params.user_token);\n        request.AddHeader('X-User-Id:' + RocketChat.params.user_id);\n\n        if (typeof RocketChat.HTTPProxy !== 'undefined' && RocketChat.HTTPProxy !== '') {\n            request.SetProxy(RocketChat.HTTPProxy);\n        }\n\n        if (typeof data !== 'undefined') {\n            data = JSON.stringify(data);\n        }\n\n        Zabbix.Log(4, '[ RocketChat Webhook ] Sending request: ' + url +\n            ((typeof data === 'string') ? ('\\n' + data) : ''));\n\n        switch (method) {\n            case 'get':\n                response = request.Get(url, data);\n                break;\n\n            case 'post':\n                response = request.Post(url, data);\n                break;\n\n            default:\n                throw 'Unsupported HTTP request method: ' + method;\n        }\n\n        Zabbix.Log(4, '[ RocketChat Webhook ] Received response with status code ' +\n            request.Status() + '\\n' + response);\n\n        if (response !== null) {\n            try {\n                response = JSON.parse(response);\n            }\n            catch (error) {\n                Zabbix.Log(4, '[ RocketChat Webhook ] Failed to parse response received from RocketChat');\n                response = null;\n            }\n        }\n\n        if (request.Status() < 200 || request.Status() >= 300) {\n            var message = 'Request failed with status code ' + request.Status();\n\n            if (response !== null && typeof response.message !== 'undefined') {\n                message += ': ' + JSON.stringify(response.message);\n            }\n            else if (response !== null && typeof response.error !== 'undefined') {\n                message += ': ' + JSON.stringify(response.error);\n            }\n\n            throw message + '. Check debug log for more information.';\n        }\n\n        return {\n            status: request.Status(),\n            response: response\n        };\n    },\n\n    postMessage: function(use_default_message, message, fields) {\n        var data = {\n            channel: RocketChat.params.send_to,\n            attachments: [{\n                collapsed: false,\n                color: RocketChat.params.color,\n                title: params.alert_subject\n            }]\n        };\n\n        if (RocketChat.params.title_link) {\n            data.attachments[0].title_link = RocketChat.params.title_link;\n        }\n\n        if (use_default_message) {\n            data.attachments[0].text = message;\n        }\n        else {\n            data.attachments[0].fields = RocketChat.addFields(fields);\n        }\n\n        var result = RocketChat.request('post', 'chat.postMessage', data);\n\n        if (typeof result.response !== 'object' || typeof result.response.message._id === 'undefined') {\n            throw 'Cannot send RocketChat message. Check debug log for more information.';\n        }\n\n        return {\n            id: result.response.message._id,\n            rid: result.response.message.rid,\n            channel: result.response.channel\n        };\n    },\n\n    sendMessage: function(update, fields) {\n\n        var data = {\n            message: {\n                rid: RocketChat.params.room_id,\n                tmid: RocketChat.params.msg_id,\n                tshow: true\n            }\n        };\n\n        if (update.status === '0') {\n            data.message.attachments = [{\n                collapsed: false,\n                color: RocketChat.params.color,\n                title: params.alert_subject,\n                title_link: RocketChat.params.title_link,\n                fields: RocketChat.addFields(fields)\n            }];\n        }\n        else {\n            data.message.alias = update.user;\n            data.message.msg = update.action;\n            if (update.message) {\n                data.message.attachments = [{\n                    color: RocketChat.params.color,\n                    text: update.message\n                }];\n            }\n        }\n\n        RocketChat.request('post', 'chat.sendMessage', data);\n    },\n\n    getMessageLink: function(rid, id) {\n        var room = RocketChat.request('get', 'rooms.info?roomId=' + encodeURIComponent(rid)),\n            link = params.rc_url +\n                (params.rc_url.endsWith('/') ? '' : '/');\n\n        switch (room.response.room.t) {\n            case 'c':\n                link += 'channel/' + room.response.room.name + '?msg=' + id;\n                break;\n\n            case 'p':\n                link += 'group/' + room.response.room.name + '?msg=' + id;\n                break;\n\n            case 'd':\n                link += 'direct/' + rid + '?msg=' + id;\n                break;\n\n            default:\n                Zabbix.Log(4, '[ RocketChat Webhook ] Can\\'t get room type. Link to message will not be added.');\n        }\n\n        return link;\n    }\n};\n\ntry {\n    var params = JSON.parse(value),\n        response,\n        fields = {},\n        rc = {},\n        update = {},\n        result = {tags: {}},\n        required_params = ['alert_subject', 'alert_message', 'event_source', 'event_value'],\n        severities = [\n            {name: 'not_classified', color: '#97AAB3'},\n            {name: 'information', color: '#7499FF'},\n            {name: 'warning', color: '#FFC859'},\n            {name: 'average', color: '#FFA059'},\n            {name: 'high', color: '#E97659'},\n            {name: 'disaster', color: '#E45959'},\n            {name: 'resolved', color: '#009900'},\n            {name: 'default', color: '#000000'}\n        ];\n\n    Object.keys(params)\n        .forEach(function (key) {\n            if (key.startsWith('rc_')) {\n                rc[key.substring(3)] = params[key];\n            }\n            else if (key.startsWith('field_')) {\n                fields[key.substring(6)] = params[key];\n            }\n            else if (key.startsWith('event_update_')) {\n                update[key.substring(13)] = params[key];\n            }\n            else if (required_params.indexOf(key) !== -1 && params[key] === '') {\n                throw 'Parameter \"' + key + '\" can\\'t be empty.';\n            }\n        });\n\n    if ([0, 1, 2, 3].indexOf(parseInt(params.event_source)) === -1) {\n        throw 'Incorrect \"event_source\" parameter given: ' + params.event_source + '\\nMust be 0-3.';\n    }\n\n    // Forcing parameters for non trigger-based events.\n    if (params.event_source !== '0') {\n        params.use_default_message = 'true';\n        params.event_nseverity = '0';\n        params.rc_title_link = false;\n    }\n\n    // Check {EVENT.VALUE} for trigger-based and internal events.\n    if (params.event_value !== '0' && params.event_value !== '1'\n            && (params.event_source === '0' || params.event_source === '3')) {\n        throw 'Incorrect \"event_value\" parameter given: ' + params.event_value + '\\nMust be 0 or 1.';\n    }\n\n    // Check {EVENT.UPDATE.STATUS} only for trigger-based events.\n    if (params.event_update_status !== '0' && params.event_update_status !== '1' && params.event_source === '0') {\n        throw 'Incorrect \"event_update_status\" parameter given: ' + params.event_update_status + '\\nMust be 0 or 1.';\n    }\n\n    if ([0, 1, 2, 3, 4, 5].indexOf(parseInt(params.event_nseverity)) === -1) {\n        params.event_nseverity = '7';\n    }\n\n    if (params.event_value === '0') {\n        params.event_nseverity = '6';\n    }\n\n    RocketChat.setParams(rc);\n    RocketChat.setProxy(params.HTTPProxy);\n    RocketChat.params.color = severities[params.event_nseverity].color;\n\n    // Send default message if use_default_message === true.\n    if (params.use_default_message.toLowerCase() === 'true') {\n        response = RocketChat.postMessage(true, params.alert_message);\n        result.tags.__zbx_rc_id = response.id;\n        result.tags.__zbx_rc_rid = response.rid;\n        result.tags.__zbx_rc_msg_url = RocketChat.getMessageLink(response.rid, response.id);\n    }\n    // Send message for trigger-based events.\n    else if (params.event_value === '1' && update.status === '0') {\n        response = RocketChat.postMessage(false, params.alert_message, fields);\n        result.tags.__zbx_rc_id = response.id;\n        result.tags.__zbx_rc_rid = response.rid;\n        result.tags.__zbx_rc_msg_url = RocketChat.getMessageLink(response.rid, response.id);\n    }\n    // Send thread message for trigger-based event.\n    else {\n        RocketChat.sendMessage(update, fields);\n    }\n\n    return JSON.stringify(result);\n}\ncatch (error) {\n    Zabbix.Log(3, '[ RocketChat Webhook ] ERROR: ' + error);\n    throw 'Sending failed: ' + error;\n}",
                "process_tags": "YES",
                "show_event_menu": "YES",
                "event_menu_url": "{EVENT.TAGS.__zbx_rc_msg_url}",
                "event_menu_name": "Rocket.Chat",
                "message_templates": [
                    {
                        "event_source": "TRIGGERS",
                        "operation_mode": "PROBLEM",
                        "subject": "[{EVENT.STATUS}] {EVENT.NAME}",
                        "message": "Problem started at {EVENT.TIME} on {EVENT.DATE}\nProblem name: {EVENT.NAME}\nHost: {HOST.NAME}\nSeverity: {EVENT.SEVERITY}\nOperational data: {EVENT.OPDATA}\nOriginal problem ID: {EVENT.ID}\n{TRIGGER.URL}"
                    },
                    {
                        "event_source": "TRIGGERS",
                        "operation_mode": "RECOVERY",
                        "subject": "[{EVENT.STATUS}] {EVENT.NAME}",
                        "message": "Problem has been resolved in {EVENT.DURATION} at {EVENT.RECOVERY.TIME} on {EVENT.RECOVERY.DATE}\nProblem name: {EVENT.NAME}\nHost: {HOST.NAME}\nSeverity: {EVENT.SEVERITY}\nOriginal problem ID: {EVENT.ID}\n{TRIGGER.URL}"
                    },
                    {
                        "event_source": "TRIGGERS",
                        "operation_mode": "UPDATE",
                        "subject": "[{EVENT.STATUS}] {EVENT.NAME}",
                        "message": "{USER.FULLNAME} {EVENT.UPDATE.ACTION} problem at {EVENT.UPDATE.DATE} {EVENT.UPDATE.TIME}.\n{EVENT.UPDATE.MESSAGE}\n\nCurrent problem status is {EVENT.STATUS}, acknowledged: {EVENT.ACK.STATUS}."
                    },
                    {
                        "event_source": "DISCOVERY",
                        "operation_mode": "PROBLEM",
                        "subject": "Discovery: {DISCOVERY.DEVICE.STATUS} {DISCOVERY.DEVICE.IPADDRESS}",
                        "message": "Discovery rule: {DISCOVERY.RULE.NAME}\n\nDevice IP: {DISCOVERY.DEVICE.IPADDRESS}\nDevice DNS: {DISCOVERY.DEVICE.DNS}\nDevice status: {DISCOVERY.DEVICE.STATUS}\nDevice uptime: {DISCOVERY.DEVICE.UPTIME}\n\nDevice service name: {DISCOVERY.SERVICE.NAME}\nDevice service port: {DISCOVERY.SERVICE.PORT}\nDevice service status: {DISCOVERY.SERVICE.STATUS}\nDevice service uptime: {DISCOVERY.SERVICE.UPTIME}"
                    },
                    {
                        "event_source": "AUTOREGISTRATION",
                        "operation_mode": "PROBLEM",
                        "subject": "Autoregistration: {HOST.HOST}",
                        "message": "Host name: {HOST.HOST}\nHost IP: {HOST.IP}\nAgent port: {HOST.PORT}"
                    }
                ]
            },
            {
                "name": "ServiceNow",
                "type": "WEBHOOK",
                "parameters": [
                    {
                        "name": "alert_message",
                        "value": "{ALERT.MESSAGE}"
                    },
                    {
                        "name": "alert_subject",
                        "value": "{ALERT.SUBJECT}"
                    },
                    {
                        "name": "event_nseverity",
                        "value": "{EVENT.NSEVERITY}"
                    },
                    {
                        "name": "event_recovery_value",
                        "value": "{EVENT.RECOVERY.VALUE}"
                    },
                    {
                        "name": "event_source",
                        "value": "{EVENT.SOURCE}"
                    },
                    {
                        "name": "event_update_status",
                        "value": "{EVENT.UPDATE.STATUS}"
                    },
                    {
                        "name": "event_value",
                        "value": "{EVENT.VALUE}"
                    },
                    {
                        "name": "servicenow_password",
                        "value": "<PLACE PASSWORD HERE>"
                    },
                    {
                        "name": "servicenow_sys_id",
                        "value": "{EVENT.TAGS.__zbx_servicenow_sys_id}"
                    },
                    {
                        "name": "servicenow_url",
                        "value": "{ALERT.SENDTO}"
                    },
                    {
                        "name": "servicenow_user",
                        "value": "<PLACE USERNAME HERE>"
                    },
                    {
                        "name": "urgency_for_average",
                        "value": "2"
                    },
                    {
                        "name": "urgency_for_disaster",
                        "value": "1"
                    },
                    {
                        "name": "urgency_for_high",
                        "value": "2"
                    },
                    {
                        "name": "urgency_for_information",
                        "value": "3"
                    },
                    {
                        "name": "urgency_for_not_classified",
                        "value": "3"
                    },
                    {
                        "name": "urgency_for_warning",
                        "value": "3"
                    }
                ],
                "status": "DISABLED",
                "script": "var ServiceNow = {\n    params: {},\n\n    setParams: function (params) {\n        if (typeof params !== 'object') {\n            return;\n        }\n\n        ServiceNow.params = params;\n        if (typeof ServiceNow.params.url === 'string') {\n            if (!ServiceNow.params.url.endsWith('/')) {\n                ServiceNow.params.url += '/';\n            }\n\n            ServiceNow.params.url += 'api/now/table/incident';\n        }\n    },\n\n    setProxy: function (HTTPProxy) {\n        ServiceNow.HTTPProxy = HTTPProxy;\n    },\n\n    setFields: function (data, fields) {\n        if (typeof fields === 'object' && Object.keys(fields).length) {\n            Object.keys(fields)\n                .forEach(function(field) {\n                    data[field] = (fields[field].match(/^\\d{4}\\.\\d{2}\\.\\d{2}$/) !== null)\n                        ? fields[field].replace(/\\./g, '-')\n                        : fields[field];\n                });\n        }\n    },\n\n    request: function (method, data) {\n        ['url', 'user', 'password'].forEach(function (field) {\n            if (typeof ServiceNow.params !== 'object' || typeof ServiceNow.params[field] === 'undefined'\n                || ServiceNow.params[field] === '' ) {\n                throw 'Required ServiceNow param is not set: \"' + field + '\".';\n            }\n        });\n\n        var response,\n            url = ServiceNow.params.url,\n            request = new CurlHttpRequest();\n\n        request.AddHeader('Content-Type: application/json');\n        request.AddHeader('Authorization: Basic ' + btoa(ServiceNow.params.user + ':' + ServiceNow.params.password));\n\n        if (typeof ServiceNow.HTTPProxy !== 'undefined' && ServiceNow.HTTPProxy !== '') {\n            request.SetProxy(ServiceNow.HTTPProxy);\n        }\n\n        if (typeof data !== 'undefined') {\n            data = JSON.stringify(data);\n        }\n\n        Zabbix.Log(4, '[ ServiceNow Webhook ] Sending request: ' + url + ((typeof data === 'string')\n            ? ('\\n' + data)\n            : ''));\n\n        switch (method) {\n            case 'get':\n                response = request.Get(url, data);\n                break;\n\n            case 'post':\n                response = request.Post(url, data);\n                break;\n\n            case 'put':\n                response = request.Put(url, data);\n                break;\n\n            default:\n                throw 'Unsupported HTTP request method: ' + method;\n        }\n\n        Zabbix.Log(4, '[ ServiceNow Webhook ] Received response with status code ' +\n            request.Status() + '\\n' + response);\n\n        if (response !== null) {\n            try {\n                response = JSON.parse(response);\n            }\n            catch (error) {\n                Zabbix.Log(4, '[ ServiceNow Webhook ] Failed to parse response received from ServiceNow');\n                response = null;\n            }\n        }\n\n        if (request.Status() < 200 || request.Status() >= 300) {\n            var message = 'Request failed with status code ' + request.Status();\n\n            if (response !== null && typeof response.error.message !== 'undefined'\n                && Object.keys(response.error).length > 0) {\n                message += ': ' + JSON.stringify(response.error.message);\n            }\n\n            throw message + ' Check debug log for more information.';\n        }\n        else if (typeof response.result !== 'object' || typeof response.result.sys_id === 'undefined') {\n            throw 'Cannot create ServiceNow incident. Check debug log for more information.';\n        }\n\n        return response.result;\n    }\n};\n\ntry {\n    var params = JSON.parse(value),\n        fields = {},\n        servicenow = {},\n        data = {},\n        result = {tags: {}},\n        required_params = [\n            'alert_subject', 'alert_message', 'event_source', 'event_value',\n            'event_update_status', 'event_recovery_value', 'event_nseverity'\n        ],\n        severities = [\n            {name: 'not_classified', color: '#97AAB3'},\n            {name: 'information', color: '#7499FF'},\n            {name: 'warning', color: '#FFC859'},\n            {name: 'average', color: '#FFA059'},\n            {name: 'high', color: '#E97659'},\n            {name: 'disaster', color: '#E45959'},\n            {name: 'resolved', color: '#009900'},\n            {name: 'default', color: '#000000'}\n        ],\n        method = 'post',\n        process_tags = true;\n\n    Object.keys(params)\n        .forEach(function (key) {\n            if (key.startsWith('servicenow_')) {\n                servicenow[key.substring(11)] = params[key];\n            }\n            else if (key.startsWith('u_')) {\n                fields[key] = params[key];\n            }\n            else if (required_params.indexOf(key) !== -1 && params[key] === '') {\n                throw 'Parameter \"' + key + '\" can\\'t be empty.';\n            }\n        });\n\n    if ([0, 1, 2, 3].indexOf(parseInt(params.event_source)) === -1) {\n        throw 'Incorrect \"event_source\" parameter given: ' + params.event_source + '\\nMust be 0-3.';\n    }\n\n    if ([0, 1, 2, 3, 4, 5].indexOf(parseInt(params.event_nseverity)) === -1) {\n        params.event_nseverity = '7';\n    }\n\n    // Check {EVENT.VALUE} for trigger-based and internal events.\n    if (params.event_value !== '0' && params.event_value !== '1'\n        && (params.event_source === '0' || params.event_source === '3')) {\n        throw 'Incorrect \"event_value\" parameter given: ' + params.event_value + '\\nMust be 0 or 1.';\n    }\n\n    // Check {EVENT.UPDATE.STATUS} only for trigger-based events.\n    if (params.event_update_status !== '0' && params.event_update_status !== '1' && params.event_source === '0') {\n        throw 'Incorrect \"event_update_status\" parameter given: ' + params.event_update_status + '\\nMust be 0 or 1.';\n    }\n\n    if (params.event_source !== '0' && params.event_recovery_value === '0') {\n        throw 'Recovery operations are supported only for trigger-based actions.';\n    }\n\n    data.short_description = params.alert_subject;\n    data.description = params.alert_message;\n\n    if (typeof params['urgency_for_' + severities[params.event_nseverity].name] !== 'undefined') {\n        data.urgency = params['urgency_for_' + severities[params.event_nseverity].name];\n    }\n\n    ServiceNow.setParams(servicenow);\n    ServiceNow.setProxy(params.HTTPProxy);\n    ServiceNow.setFields(data, fields);\n\n    if (params.event_source === '0' && (params.event_value === '0' || params.event_update_status === '1')) {\n        process_tags = false;\n        method = 'put';\n        delete data.description;\n        delete data.urgency;\n        ServiceNow.params.url += '/' + params.servicenow_sys_id;\n        data.comments = params.alert_message;\n    }\n\n    var response = ServiceNow.request(method, data);\n\n    if (process_tags) {\n        result.tags.__zbx_servicenow_sys_id = response.sys_id;\n        result.tags.__zbx_servicenow_link = params.servicenow_url +\n            (params.servicenow_url.endsWith('/') ? '' : '/') + 'incident.do?sys_id=' + response.sys_id;\n        result.tags.__zbx_servicenow_number = response.number;\n    }\n\n    return JSON.stringify(result);\n}\ncatch (error) {\n    Zabbix.Log(3, '[ ServiceNow Webhook ] ERROR: ' + error);\n    throw 'Sending failed: ' + error;\n}",
                "process_tags": "YES",
                "show_event_menu": "YES",
                "event_menu_url": "{EVENT.TAGS.__zbx_servicenow_link}",
                "event_menu_name": "ServiceNow: {EVENT.TAGS.__zbx_servicenow_number}",
                "message_templates": [
                    {
                        "event_source": "TRIGGERS",
                        "operation_mode": "PROBLEM",
                        "subject": "[{EVENT.STATUS}] {EVENT.NAME}",
                        "message": "Problem started at {EVENT.TIME} on {EVENT.DATE}\nProblem name: {EVENT.NAME}\nHost: {HOST.NAME}\nSeverity: {EVENT.SEVERITY}\nOperational data: {EVENT.OPDATA}\nOriginal problem ID: {EVENT.ID}\n{TRIGGER.URL}"
                    },
                    {
                        "event_source": "TRIGGERS",
                        "operation_mode": "RECOVERY",
                        "subject": "[{EVENT.STATUS}] {EVENT.NAME}",
                        "message": "Problem has been resolved in {EVENT.DURATION} at {EVENT.RECOVERY.TIME} on {EVENT.RECOVERY.DATE}\nProblem name: {EVENT.NAME}\nHost: {HOST.NAME}\nSeverity: {EVENT.SEVERITY}\nOriginal problem ID: {EVENT.ID}\n{TRIGGER.URL}"
                    },
                    {
                        "event_source": "TRIGGERS",
                        "operation_mode": "UPDATE",
                        "subject": "[{EVENT.STATUS}] {EVENT.NAME}",
                        "message": "{USER.FULLNAME} {EVENT.UPDATE.ACTION} problem at {EVENT.UPDATE.DATE} {EVENT.UPDATE.TIME}.\n{EVENT.UPDATE.MESSAGE}\n\nCurrent problem status is {EVENT.STATUS}, acknowledged: {EVENT.ACK.STATUS}."
                    },
                    {
                        "event_source": "DISCOVERY",
                        "operation_mode": "PROBLEM",
                        "subject": "Discovery: {DISCOVERY.DEVICE.STATUS} {DISCOVERY.DEVICE.IPADDRESS}",
                        "message": "Discovery rule: {DISCOVERY.RULE.NAME}\n\nDevice IP: {DISCOVERY.DEVICE.IPADDRESS}\nDevice DNS: {DISCOVERY.DEVICE.DNS}\nDevice status: {DISCOVERY.DEVICE.STATUS}\nDevice uptime: {DISCOVERY.DEVICE.UPTIME}\n\nDevice service name: {DISCOVERY.SERVICE.NAME}\nDevice service port: {DISCOVERY.SERVICE.PORT}\nDevice service status: {DISCOVERY.SERVICE.STATUS}\nDevice service uptime: {DISCOVERY.SERVICE.UPTIME}"
                    },
                    {
                        "event_source": "AUTOREGISTRATION",
                        "operation_mode": "PROBLEM",
                        "subject": "Autoregistration: {HOST.HOST}",
                        "message": "Host name: {HOST.HOST}\nHost IP: {HOST.IP}\nAgent port: {HOST.PORT}"
                    }
                ]
            },
            {
                "name": "SIGNL4",
                "type": "WEBHOOK",
                "parameters": {
                    "5": {
                        "name": "Event_Ack_Status",
                        "value": "{EVENT.ACK.STATUS}"
                    },
                    "6": {
                        "name": "Event_Date_Time",
                        "value": "{EVENT.DATE} {EVENT.TIME}"
                    },
                    "7": {
                        "name": "Event_ID",
                        "value": "{EVENT.ID}"
                    },
                    "8": {
                        "name": "Event_Update_Action",
                        "value": "{EVENT.UPDATE.ACTION}"
                    },
                    "9": {
                        "name": "Event_Update_Status",
                        "value": "{EVENT.UPDATE.STATUS}"
                    },
                    "4": {
                        "name": "Hostname",
                        "value": "{HOST.NAME}"
                    },
                    "10": {
                        "name": "Host_IP",
                        "value": "{HOST.IP}"
                    },
                    "2": {
                        "name": "Message",
                        "value": "{ALERT.MESSAGE}"
                    },
                    "3": {
                        "name": "Severity",
                        "value": "{EVENT.SEVERITY}"
                    },
                    "1": {
                        "name": "Subject",
                        "value": "{ALERT.SUBJECT}"
                    },
                    "0": {
                        "name": "teamsecret",
                        "value": "{ALERT.SENDTO}"
                    },
                    "11": {
                        "name": "Trigger_ID",
                        "value": "{TRIGGER.ID}"
                    },
                    "12": {
                        "name": "Trigger_Status",
                        "value": "{TRIGGER.STATUS}"
                    },
                    "13": {
                        "name": "User",
                        "value": "{USER.FULLNAME}"
                    },
                    "14": {
                        "name": "Zabbix_URL",
                        "value": "{$ZABBIX.URL}"
                    }
                },
                "status": "DISABLED",
                "script": "// SIGNL4 Webhook\ntry {\n    var response,\n        payload,\n        params = JSON.parse(value),\n        endpoint = 'https://connect.signl4.com/webhook/',\n        request = new CurlHttpRequest();\n\n    if (typeof params.HTTPProxy === 'string' && params.HTTPProxy.trim() !== '') {\n        request.SetProxy(params.HTTPProxy);\n    }\n\n    if (typeof params.teamsecret === 'string' && params.teamsecret.trim() !== '') {\n        endpoint += params.teamsecret;\n        delete params.teamsecret;\n    }\n    else {\n        throw 'The team secret of your SIGNL4 team cannot be empty.';\n    }\n\n    if (typeof params.Severity === 'string' && params.Severity === '{EVENT.SEVERITY}') {\n        params.Severity = 'Not classified';\n    }\n\nif (typeof params.User === 'string' && params.User === '{USER.FULLNAME}') {\n        params.User = '';\n    }\n\nif (typeof params.Event_Update_Action === 'string' && params.Event_Update_Action === '{EVENT.UPDATE.ACTION}') {\n        params.Event_Update_Action = '';\n    }\n\n// Assemble X-S4-ExternalID for two-way integration\n// Format: \"ZabbixEventID: 222 ZabbixURL: https://your-zabbix-server/zabbix/\"\nparams['X-S4-ExternalID'] = 'ZabbixEventID: ' + params.Event_ID;\nif (typeof params.Zabbix_URL === 'string' && params.Zabbix_URL.indexOf('http') == 0) {\n// Make sure the URL ends with '/'\nif (params.Zabbix_URL.charAt(params.Zabbix_URL.length - 1) != '/') {\nparams.Zabbix_URL = params.Zabbix_URL + '/';\n}\n\nparams['X-S4-ExternalID'] = params['X-S4-ExternalID'] + ' ZabbixURL: ' +  params.Zabbix_URL;\n\n// Add Link parameter\nparams['Link'] = params.Zabbix_URL + \"tr_events.php?triggerid=\"+params.Trigger_ID + \"&eventid=\" + params.Event_ID;\n}\n\n// Check if this is a new problem or a recovery\nif (params.Trigger_Status == 'OK') {\nparams['X-S4-Status'] = 'resolved';\n}\nelse {\nparams['X-S4-Status'] = 'new';\n}\n\n    payload = JSON.stringify(params);\n    Zabbix.Log(4, '[ SIGNL4 Webhook ] Sending request: ' + payload);\n\n    request.AddHeader('Content-Type: application/json');\n    response = request.Post(endpoint, 'payload=' + payload);\n\n    Zabbix.Log(4, '[ SIGNL4 Webhook ] Received response with status code ' +\n            request.Status() + '\\n' + response\n    );\n\n    if (request.Status() !== 201) {\n        throw 'Request failed with status code ' + request.Status() +\n                '. Check debug log for more information.';\n    }\n\n    return 'OK';\n}\ncatch (error) {\n    Zabbix.Log(4, '[ SIGNL4 Webhook ] ERROR: ' + error);\n\n    throw 'Sending failed: ' + error;\n}",
                "description": "SIGNL4 is a mobile alert notification app for powerful alerting, alert management and mobile assignment of work items. It offers alerting via app push, SMS and voice calls including escalations, tracking, and duty scheduling.\n\nGet the app at https://www.signl4.com.\n\nFind out more including an integration video here: https://www.signl4.com/blog/portfolio_item/zabbix-mobile-alert-notification-duty-schedule-escalation/",
                "message_templates": [
                    {
                        "event_source": "TRIGGERS",
                        "operation_mode": "PROBLEM",
                        "subject": "Problem: {EVENT.NAME}",
                        "message": "Problem started at {EVENT.TIME} on {EVENT.DATE}\nProblem name: {EVENT.NAME}\nHost: {HOST.NAME}\nSeverity: {EVENT.SEVERITY}\nOperational data: {EVENT.OPDATA}\nOriginal problem ID: {EVENT.ID}\n{TRIGGER.URL}"
                    },
                    {
                        "event_source": "TRIGGERS",
                        "operation_mode": "RECOVERY",
                        "subject": "Resolved: {EVENT.NAME}",
                        "message": "Problem has been resolved in {EVENT.DURATION} at {EVENT.RECOVERY.TIME} on {EVENT.RECOVERY.DATE}\nProblem name: {EVENT.NAME}\nHost: {HOST.NAME}\nSeverity: {EVENT.SEVERITY}\nOriginal problem ID: {EVENT.ID}\n{TRIGGER.URL}"
                    },
                    {
                        "event_source": "TRIGGERS",
                        "operation_mode": "UPDATE",
                        "subject": "Updated problem: {EVENT.NAME}",
                        "message": "{USER.FULLNAME} {EVENT.UPDATE.ACTION} problem at {EVENT.UPDATE.DATE} {EVENT.UPDATE.TIME}.\n{EVENT.UPDATE.MESSAGE}\n\nCurrent problem status is {EVENT.STATUS}, acknowledged: {EVENT.ACK.STATUS}."
                    },
                    {
                        "event_source": "DISCOVERY",
                        "operation_mode": "PROBLEM",
                        "subject": "Discovery: {DISCOVERY.DEVICE.STATUS} {DISCOVERY.DEVICE.IPADDRESS}",
                        "message": "Discovery rule: {DISCOVERY.RULE.NAME}\n\nDevice IP: {DISCOVERY.DEVICE.IPADDRESS}\nDevice DNS: {DISCOVERY.DEVICE.DNS}\nDevice status: {DISCOVERY.DEVICE.STATUS}\nDevice uptime: {DISCOVERY.DEVICE.UPTIME}\n\nDevice service name: {DISCOVERY.SERVICE.NAME}\nDevice service port: {DISCOVERY.SERVICE.PORT}\nDevice service status: {DISCOVERY.SERVICE.STATUS}\nDevice service uptime: {DISCOVERY.SERVICE.UPTIME}"
                    },
                    {
                        "event_source": "AUTOREGISTRATION",
                        "operation_mode": "PROBLEM",
                        "subject": "Autoregistration: {HOST.HOST}",
                        "message": "Host name: {HOST.HOST}\nHost IP: {HOST.IP}\nAgent port: {HOST.PORT}"
                    }
                ]
            },
            {
                "name": "Slack",
                "type": "WEBHOOK",
                "parameters": {
                    "21": {
                        "name": "alert_message",
                        "value": "{ALERT.MESSAGE}"
                    },
                    "22": {
                        "name": "alert_subject",
                        "value": "{ALERT.SUBJECT}"
                    },
                    "1": {
                        "name": "bot_token",
                        "value": "<PLACE YOUR KEY HERE>"
                    },
                    "2": {
                        "name": "channel",
                        "value": "{ALERT.SENDTO}"
                    },
                    "27": {
                        "name": "channel_id",
                        "value": "{EVENT.TAGS.__channel_id}"
                    },
                    "23": {
                        "name": "discovery_host_dns",
                        "value": "{DISCOVERY.DEVICE.DNS}"
                    },
                    "24": {
                        "name": "discovery_host_ip",
                        "value": "{DISCOVERY.DEVICE.IPADDRESS}"
                    },
                    "9": {
                        "name": "event_date",
                        "value": "{EVENT.DATE}"
                    },
                    "13": {
                        "name": "event_id",
                        "value": "{EVENT.ID}"
                    },
                    "6": {
                        "name": "event_nseverity",
                        "value": "{EVENT.NSEVERITY}"
                    },
                    "12": {
                        "name": "event_opdata",
                        "value": "{EVENT.OPDATA}"
                    },
                    "19": {
                        "name": "event_recovery_date",
                        "value": "{EVENT.RECOVERY.DATE}"
                    },
                    "20": {
                        "name": "event_recovery_time",
                        "value": "{EVENT.RECOVERY.TIME}"
                    },
                    "11": {
                        "name": "event_severity",
                        "value": "{EVENT.SEVERITY}"
                    },
                    "25": {
                        "name": "event_source",
                        "value": "{EVENT.SOURCE}"
                    },
                    "5": {
                        "name": "event_tags",
                        "value": "{EVENT.TAGS}"
                    },
                    "10": {
                        "name": "event_time",
                        "value": "{EVENT.TIME}"
                    },
                    "17": {
                        "name": "event_update_date",
                        "value": "{EVENT.UPDATE.DATE}"
                    },
                    "8": {
                        "name": "event_update_status",
                        "value": "{EVENT.UPDATE.STATUS}"
                    },
                    "18": {
                        "name": "event_update_time",
                        "value": "{EVENT.UPDATE.TIME}"
                    },
                    "7": {
                        "name": "event_value",
                        "value": "{EVENT.VALUE}"
                    },
                    "26": {
                        "name": "host_conn",
                        "value": "{HOST.CONN}"
                    },
                    "16": {
                        "name": "host_name",
                        "value": "{HOST.HOST}"
                    },
                    "28": {
                        "name": "message_ts",
                        "value": "{EVENT.TAGS.__message_ts}"
                    },
                    "4": {
                        "name": "slack_as_user",
                        "value": "true"
                    },
                    "3": {
                        "name": "slack_mode",
                        "value": "alarm"
                    },
                    "15": {
                        "name": "trigger_description",
                        "value": "{TRIGGER.DESCRIPTION}"
                    },
                    "14": {
                        "name": "trigger_id",
                        "value": "{TRIGGER.ID}"
                    },
                    "0": {
                        "name": "zabbix_url",
                        "value": "{$ZABBIX.URL}"
                    }
                },
                "status": "DISABLED",
                "script": "var SEVERITY_COLORS = [\n    '#97AAB3', '#7499FF', '#FFC859',\n    '#FFA059', '#E97659', '#E45959'\n];\n\nvar RESOLVE_COLOR = '#009900';\n\nvar SLACK_MODE_HANDLERS = {\n    alarm: handlerAlarm,\n    event: handlerEvent\n};\n\n\nif (!String.prototype.format) {\n    String.prototype.format = function() {\n        var args = arguments;\n\n        return this.replace(/{(\\d+)}/g, function(match, number) {\n            return number in args\n                ? args[number]\n                : match\n            ;\n        });\n    };\n}\n\nfunction isEventProblem(params) {\n    return params.event_value == 1\n        && params.event_update_status == 0\n    ;\n}\n\nfunction isEventUpdate(params) {\n    return params.event_value == 1\n        && params.event_update_status == 1\n    ;\n}\n\nfunction isEventResolve(params) {\n    return params.event_value == 0;\n}\n\nfunction getPermalink(channelId, messageTimestamp) {\n    var req = new CurlHttpRequest();\n\n    if (typeof params.HTTPProxy === 'string' && params.HTTPProxy.trim() !== '') {\n        req.SetProxy(params.HTTPProxy);\n    }\n\n    req.AddHeader('Content-Type: application/x-www-form-urlencoded; charset=utf-8');\n    req.AddHeader('Authorization: Bearer ' + params.bot_token);\n\n    var query = '{0}?channel={1}&message_ts={2}'.format(\n            Slack.getPermalink,\n            encodeURIComponent(channelId),\n            encodeURIComponent(messageTimestamp)),\n        resp = JSON.parse(req.Get(query));\n\n    if (req.Status() != 200 || !resp.ok || resp.ok === 'false') {\n        throw 'message was created, but getting message link was failed with reason \"' + resp.error + '\"';\n    }\n\n    return resp.permalink;\n}\n\nfunction createProblemURL(zabbix_url, triggerid, eventid, event_source) {\n    var problem_url = '';\n    if (event_source === '0') {\n        problem_url = '{0}/tr_events.php?triggerid={1}&eventid={2}'\n            .format(\n                zabbix_url,\n                triggerid,\n                eventid\n            );\n    }\n    else {\n        problem_url = zabbix_url;\n    }\n\n    return problem_url;\n}\n\nfunction handlerAlarm(params) {\n    var fields = {\n        channel: params.channel,\n        as_user: params.slack_as_user,\n    };\n\n    if (isEventProblem(params)) {\n        fields.attachments = [\n            createMessage(\n                SEVERITY_COLORS[params.event_nseverity] || 0,\n                params.event_date,\n                params.event_time,\n                createProblemURL(params.zabbix_url, params.trigger_id, params.event_id, params.event_source)\n            )\n        ];\n\n        var resp = JSON.parse(req.Post(Slack.postMessage, JSON.stringify(fields)));\n\n        if (req.Status() != 200 || !resp.ok || resp.ok === 'false') {\n            throw resp.error;\n        }\n\n        result.tags.__message_ts = resp.ts;\n        result.tags.__channel_id = resp.channel;\n        result.tags.__channel_name = params.channel;\n        result.tags.__message_link = getPermalink(resp.channel, resp.ts);\n    }\n    else if (isEventUpdate(params)) {\n        fields.thread_ts = params.message_ts;\n        fields.attachments = [\n            createMessage(\n                SEVERITY_COLORS[params.event_nseverity] || 0,\n                params.event_update_date,\n                params.event_update_time,\n                createProblemURL(params.zabbix_url, params.trigger_id, params.event_id, params.event_source),\n                true\n            )\n        ];\n\n        resp = JSON.parse(req.Post(Slack.postMessage, JSON.stringify(fields)));\n        if (req.Status() != 200 || !resp.ok || resp.ok === 'false') {\n            throw resp.error;\n        }\n\n    }\n    else if (isEventResolve(params)) {\n        fields.channel = params.channel_id;\n        fields.text = '';\n        fields.ts = params.message_ts;\n        fields.attachments = [\n            createMessage(\n                RESOLVE_COLOR,\n                params.event_date,\n                params.event_time,\n                createProblemURL(params.zabbix_url, params.trigger_id, params.event_id, params.event_source)\n            )\n        ];\n\n        resp = JSON.parse(req.Post(Slack.chatUpdate, JSON.stringify(fields)));\n        if (req.Status() != 200 || !resp.ok || resp.ok === 'false') {\n            throw resp.error;\n        }\n    }\n}\n\nfunction handlerEvent(params) {\n    var fields = {\n        channel: params.channel,\n        as_user: params.slack_as_user\n    };\n\n    if (isEventProblem(params)) {\n        fields.attachments = [\n            createMessage(\n                SEVERITY_COLORS[params.event_nseverity] || 0,\n                params.event_date,\n                params.event_time,\n                createProblemURL(params.zabbix_url, params.trigger_id, params.event_id, params.event_source)\n            )\n        ];\n\n        var resp = JSON.parse(req.Post(Slack.postMessage, JSON.stringify(fields)));\n\n        if (req.Status() != 200 || !resp.ok || resp.ok === 'false') {\n            throw resp.error;\n        }\n\n        result.tags.__channel_name = params.channel;\n        result.tags.__message_link = getPermalink(resp.channel, resp.ts);\n\n    }\n    else if (isEventUpdate(params)) {\n        fields.attachments = [\n            createMessage(\n                SEVERITY_COLORS[params.event_nseverity] || 0,\n                params.event_update_date,\n                params.event_update_time,\n                createProblemURL(params.zabbix_url, params.trigger_id, params.event_id, params.event_source),\n                false\n            )\n        ];\n\n        resp = JSON.parse(req.Post(Slack.postMessage, JSON.stringify(fields)));\n\n        if (req.Status() != 200 || !resp.ok || resp.ok === 'false') {\n            throw resp.error;\n        }\n\n    }\n    else if (isEventResolve(params)) {\n        fields.attachments = [\n            createMessage(\n                RESOLVE_COLOR,\n                params.event_recovery_date,\n                params.event_recovery_time,\n                createProblemURL(params.zabbix_url, params.trigger_id, params.event_id, params.event_source)\n            )\n        ];\n\n        resp = JSON.parse(req.Post(Slack.postMessage, JSON.stringify(fields)));\n\n        if (req.Status() != 200 || !resp.ok || resp.ok === 'false') {\n            throw resp.error;\n        }\n    }\n}\n\nfunction createMessage(\n    event_severity_color,\n    event_date,\n    event_time,\n    problem_url,\n    isShort,\n    messageText\n) {\n    var message = {\n        fallback: params.alert_subject,\n        title: params.alert_subject,\n        color: event_severity_color,\n        title_link: problem_url,\n        pretext: messageText || '',\n\n        fields: [\n            {\n                title: 'Host',\n                value: '{0} [{1}]'.format(params.host_name, params.host_conn),\n                short: true\n            },\n            {\n                title: 'Event time',\n                value: '{0} {1}'.format(event_date, event_time),\n                short: true\n            }\n        ],\n    };\n\n    if (params.event_source === '0') {\n        message.fields.push(\n            {\n                title: 'Severity',\n                value: params.event_severity,\n                short: true\n            },\n            {\n                title: 'Opdata',\n                value: params.event_opdata,\n                short: true\n            }\n        );\n    }\n\n    if (!isShort  && params.event_source === '0') {\n        message['actions'] = [\n            {\n                type: 'button',\n                text: 'Open in Zabbix',\n                url: problem_url\n            }\n        ];\n\n        message.fields.push(\n            {\n                title: 'Event tags',\n                value: params.event_tags.replace(/__.+?:(.+?,|.+)/g, '') || 'None',\n                short: true\n            },\n            {\n                title: 'Trigger description',\n                value: params.trigger_description,\n                short: true\n            }\n        );\n    }\n\n    if (params.event_source !== '0' || params.event_update_status === '1') {\n        message.fields.push(\n            {\n                title: 'Details',\n                value: params.alert_message,\n                short: false\n            }\n        );\n    }\n\n    return message;\n}\n\nfunction validateParams(params) {\n    if (typeof params.bot_token !== 'string' || params.bot_token.trim() === '') {\n        throw 'Field \"bot_token\" cannot be empty';\n    }\n\n    if (typeof params.channel !== 'string' || params.channel.trim() === '') {\n        throw 'Field \"channel\" cannot be empty';\n    }\n\n    if (isNaN(params.event_id)) {\n        throw 'Field \"event_id\" is not a number';\n    }\n\n    if ([0, 1, 2, 3].indexOf(parseInt(params.event_source)) === -1) {\n        throw 'Incorrect \"event_source\" parameter given: \"' + params.event_source + '\".\\nMust be 0-3.';\n    }\n\n    if (params.event_source !== '0') {\n        params.event_nseverity = '0';\n        params.event_severity = 'Not classified';\n        params.event_update_status = '0';\n        params.slack_mode = 'event';\n    }\n\n    if (params.event_source === '1' || params.event_source === '2') {\n        params.event_value = '1';\n    }\n\n    if (params.event_source === '1') {\n        params.host_name = params.discovery_host_dns;\n        params.host_ip = params.discovery_host_ip;\n    }\n\n    if (!~[0, 1, 2, 3, 4, 5].indexOf(parseInt(params.event_nseverity))) {\n        throw 'Incorrect \"event_nseverity\" parameter given: ' + params.event_nseverity + '\\nMust be 0-5.';\n    }\n\n    if (typeof params.event_severity !== 'string' || params.event_severity.trim() === '') {\n        throw 'Field \"event_severity\" cannot be empty';\n    }\n\n    if (params.event_update_status !== '0' && params.event_update_status !== '1') {\n        throw 'Incorrect \"event_update_status\" parameter given: ' + params.event_update_status + '\\nMust be 0 or 1.';\n    }\n\n    if (params.event_value !== '0' && params.event_value !== '1') {\n        throw 'Incorrect \"event_value\" parameter given: ' + params.event_value + '\\nMust be 0 or 1.';\n    }\n\n    if (typeof params.host_conn !== 'string' || params.host_conn.trim() === '') {\n        throw 'Field \"host_conn\" cannot be empty';\n    }\n\n    if (typeof params.host_name !== 'string' || params.host_name.trim() === '') {\n        throw 'Field \"host_name\" cannot be empty';\n    }\n\n    if (!~['true', 'false'].indexOf(params.slack_as_user.toLowerCase())) {\n        throw 'Incorrect \"slack_as_user\" parameter given: ' + params.slack_as_user + '\\nMust be \"true\" or \"false\".';\n    }\n\n    if (!~['alarm', 'event'].indexOf(params.slack_mode)) {\n        throw 'Incorrect \"slack_mode\" parameter given: ' + params.slack_mode + '\\nMust be \"alarm\" or \"event\".';\n    }\n\n    if (isNaN(params.trigger_id) && params.event_source === '0') {\n        throw 'field \"trigger_id\" is not a number';\n    }\n\n    if (typeof params.zabbix_url !== 'string' || params.zabbix_url.trim() === '') {\n        throw 'Field \"zabbix_url\" cannot be empty';\n    }\n\n    if (!/^(http|https):\\/\\/.+/.test(params.zabbix_url)) {\n        throw 'Field \"zabbix_url\" must contain a schema';\n    }\n}\n\ntry {\n    var params = JSON.parse(value);\n\n    validateParams(params);\n\n    var req = new CurlHttpRequest(),\n        result = {tags: {}};\n\n    if (typeof params.HTTPProxy === 'string' && params.HTTPProxy.trim() !== '') {\n        req.SetProxy(params.HTTPProxy);\n    }\n\n    req.AddHeader('Content-Type: application/json; charset=utf-8');\n    req.AddHeader('Authorization: Bearer ' + params.bot_token);\n\n    var slack_endpoint = 'https://slack.com/api/';\n\n    var Slack = {\n        postMessage: slack_endpoint + 'chat.postMessage',\n        getPermalink: slack_endpoint + 'chat.getPermalink',\n        chatUpdate: slack_endpoint + 'chat.update'\n    };\n\n    params.slack_mode = params.slack_mode.toLowerCase();\n    params.slack_mode = params.slack_mode in SLACK_MODE_HANDLERS\n        ? params.slack_mode\n        : 'alarm';\n\n    SLACK_MODE_HANDLERS[params.slack_mode](params);\n\n    if (params.event_source === '0') {\n        return JSON.stringify(result);\n    }\n    else {\n        return 'OK';\n    }\n}\ncatch (error) {\n    Zabbix.Log(4, '[ Slack Webhook ] Slack notification failed : ' + error);\n    throw 'Slack notification failed : ' + error;\n}",
                "process_tags": "YES",
                "show_event_menu": "YES",
                "event_menu_url": "{EVENT.TAGS.__message_link}",
                "event_menu_name": "Open in Slack: {EVENT.TAGS.__channel_name}",
                "message_templates": [
                    {
                        "event_source": "TRIGGERS",
                        "operation_mode": "PROBLEM",
                        "subject": "Problem: {EVENT.NAME}",
                        "message": "Problem started at {EVENT.TIME} on {EVENT.DATE}\nProblem name: {EVENT.NAME}\nHost: {HOST.NAME}\nSeverity: {EVENT.SEVERITY}\nOperational data: {EVENT.OPDATA}\nOriginal problem ID: {EVENT.ID}\n{TRIGGER.URL}"
                    },
                    {
                        "event_source": "TRIGGERS",
                        "operation_mode": "RECOVERY",
                        "subject": "Resolved in {EVENT.DURATION}: {EVENT.NAME}",
                        "message": "Problem has been resolved at {EVENT.RECOVERY.TIME} on {EVENT.RECOVERY.DATE}\nProblem name: {EVENT.NAME}\nProblem duration: {EVENT.DURATION}\nHost: {HOST.NAME}\nSeverity: {EVENT.SEVERITY}\nOriginal problem ID: {EVENT.ID}\n{TRIGGER.URL}"
                    },
                    {
                        "event_source": "TRIGGERS",
                        "operation_mode": "UPDATE",
                        "subject": "Updated problem in {EVENT.AGE}: {EVENT.NAME}",
                        "message": "{USER.FULLNAME} {EVENT.UPDATE.ACTION} problem at {EVENT.UPDATE.DATE} {EVENT.UPDATE.TIME}.\n{EVENT.UPDATE.MESSAGE}\n\nCurrent problem status is {EVENT.STATUS}, age is {EVENT.AGE}, acknowledged: {EVENT.ACK.STATUS}."
                    },
                    {
                        "event_source": "DISCOVERY",
                        "operation_mode": "PROBLEM",
                        "subject": "Discovery: {DISCOVERY.DEVICE.STATUS} {DISCOVERY.DEVICE.IPADDRESS}",
                        "message": "Discovery rule: {DISCOVERY.RULE.NAME}\n\nDevice IP: {DISCOVERY.DEVICE.IPADDRESS}\nDevice DNS: {DISCOVERY.DEVICE.DNS}\nDevice status: {DISCOVERY.DEVICE.STATUS}\nDevice uptime: {DISCOVERY.DEVICE.UPTIME}\n\nDevice service name: {DISCOVERY.SERVICE.NAME}\nDevice service port: {DISCOVERY.SERVICE.PORT}\nDevice service status: {DISCOVERY.SERVICE.STATUS}\nDevice service uptime: {DISCOVERY.SERVICE.UPTIME}"
                    },
                    {
                        "event_source": "AUTOREGISTRATION",
                        "operation_mode": "PROBLEM",
                        "subject": "Autoregistration: {HOST.HOST}",
                        "message": "Host name: {HOST.HOST}\nHost IP: {HOST.IP}\nAgent port: {HOST.PORT}"
                    }
                ]
            },
            {
                "name": "SMS",
                "type": "SMS",
                "gsm_modem": "/dev/ttyS0",
                "status": "DISABLED",
                "message_templates": [
                    {
                        "event_source": "TRIGGERS",
                        "operation_mode": "PROBLEM",
                        "message": "{EVENT.SEVERITY}: {EVENT.NAME}\nHost: {HOST.NAME}\n{EVENT.DATE} {EVENT.TIME}"
                    },
                    {
                        "event_source": "TRIGGERS",
                        "operation_mode": "RECOVERY",
                        "message": "Resolved in {EVENT.DURATION}: {EVENT.NAME}\nHost: {HOST.NAME}\n{EVENT.DATE} {EVENT.TIME}"
                    },
                    {
                        "event_source": "TRIGGERS",
                        "operation_mode": "UPDATE",
                        "message": "{USER.FULLNAME} {EVENT.UPDATE.ACTION} problem in {EVENT.AGE} at {EVENT.UPDATE.DATE} {EVENT.UPDATE.TIME}"
                    },
                    {
                        "event_source": "DISCOVERY",
                        "operation_mode": "PROBLEM",
                        "message": "Discovery: {DISCOVERY.DEVICE.STATUS} {DISCOVERY.DEVICE.IPADDRESS}"
                    },
                    {
                        "event_source": "AUTOREGISTRATION",
                        "operation_mode": "PROBLEM",
                        "message": "Autoregistration: {HOST.HOST}\nHost IP: {HOST.IP}\nAgent port: {HOST.PORT}"
                    }
                ]
            },
            {
                "name": "SolarWinds Service Desk",
                "type": "WEBHOOK",
                "parameters": [
                    {
                        "name": "alert_message",
                        "value": "{ALERT.MESSAGE}"
                    },
                    {
                        "name": "alert_subject",
                        "value": "{ALERT.SUBJECT}"
                    },
                    {
                        "name": "event_nseverity",
                        "value": "{EVENT.NSEVERITY}"
                    },
                    {
                        "name": "event_recovery_value",
                        "value": "{EVENT.RECOVERY.VALUE}"
                    },
                    {
                        "name": "event_source",
                        "value": "{EVENT.SOURCE}"
                    },
                    {
                        "name": "event_update_status",
                        "value": "{EVENT.UPDATE.STATUS}"
                    },
                    {
                        "name": "event_value",
                        "value": "{EVENT.VALUE}"
                    },
                    {
                        "name": "priority_average",
                        "value": "Medium"
                    },
                    {
                        "name": "priority_default",
                        "value": "Low"
                    },
                    {
                        "name": "priority_disaster",
                        "value": "Critical"
                    },
                    {
                        "name": "priority_high",
                        "value": "High"
                    },
                    {
                        "name": "samanage_incident_id",
                        "value": "{EVENT.TAGS.__zbx_solarwinds_inc_id}"
                    },
                    {
                        "name": "samanage_token",
                        "value": "<PUT YOUR TOKEN HERE>"
                    },
                    {
                        "name": "samanage_url",
                        "value": "<PUT YOUR INSTANCE URL HERE>"
                    }
                ],
                "status": "DISABLED",
                "script": "var SolarWinds = {\n    params: {},\n\n    setParams: function (params) {\n        if (typeof params !== 'object') {\n            return;\n        }\n\n        SolarWinds.params = params;\n        SolarWinds.params.endpoint = 'https://api.samanage.com/';\n    },\n\n    setProxy: function (HTTPProxy) {\n        SolarWinds.HTTPProxy = HTTPProxy;\n    },\n\n    addCustomFields: function (data, fields) {\n        if (typeof data.incident === 'object' && typeof fields === 'object' && Object.keys(fields).length) {\n            if (typeof fields.sw_fields === 'object' && Object.keys(fields.sw_fields).length) {\n                Object.keys(fields.sw_fields)\n                    .forEach(function(field) {\n                        try {\n                            data.incident[field] = JSON.parse(fields.sw_fields[field]);\n                        }\n                        catch (error) {\n                            data.incident[field] = fields.sw_fields[field];\n                        }\n                    });\n            }\n\n            if (typeof fields.sw_customfields === 'object' && Object.keys(fields.sw_customfields).length) {\n                data.incident.custom_fields_values = {custom_fields_value: []};\n                Object.keys(fields.sw_customfields)\n                    .forEach(function(field) {\n                        data.incident.custom_fields_values.custom_fields_value.push({\n                            name: field,\n                            value: fields.sw_customfields[field]\n                        });\n                    });\n            }\n        }\n\n        return data;\n    },\n\n    request: function (method, query, data) {\n        ['token'].forEach(function (field) {\n            if (typeof SolarWinds.params !== 'object' || typeof SolarWinds.params[field] === 'undefined'\n                || SolarWinds.params[field] === '' ) {\n                throw 'Required SolarWinds param is not set: \"' + field + '\".';\n            }\n        });\n\n        var response,\n            url = SolarWinds.params.endpoint + query,\n            request = new CurlHttpRequest();\n\n        request.AddHeader('Content-Type: application/json');\n        request.AddHeader('X-Samanage-Authorization: Bearer ' + SolarWinds.params.token);\n        request.AddHeader('Accept: application/vnd.samanage.v2.1+json');\n\n        if (typeof SolarWinds.HTTPProxy !== 'undefined' && SolarWinds.HTTPProxy !== '') {\n            request.SetProxy(SolarWinds.HTTPProxy);\n        }\n\n        if (typeof data !== 'undefined') {\n            data = JSON.stringify(data);\n        }\n\n        Zabbix.Log(4, '[ SolarWinds SD Webhook ] Sending request: ' + url + ((typeof data === 'string')\n            ? ('\\n' + data)\n            : ''));\n\n        switch (method) {\n            case 'get':\n                response = request.Get(url, data);\n                break;\n\n            case 'post':\n                response = request.Post(url, data);\n                break;\n\n            case 'put':\n                response = request.Put(url, data);\n                break;\n\n            default:\n                throw 'Unsupported HTTP request method: ' + method;\n        }\n\n        Zabbix.Log(4, '[ SolarWinds SD Webhook ] Received response with status code ' + request.Status() +\n            '\\n' + response);\n\n        if (response !== null) {\n            try {\n                response = JSON.parse(response);\n            }\n            catch (error) {\n                Zabbix.Log(4, '[ SolarWinds SD Webhook ] Failed to parse response received from SolarWinds');\n                response = null;\n            }\n        }\n\n        if (request.Status() < 200 || request.Status() >= 300) {\n            var message = 'Request failed with status code ' + request.Status();\n\n            if (response !== null && typeof response.error !== 'undefined'\n                && Object.keys(response.error).length > 0) {\n                message += ': ' + JSON.stringify(response.error);\n            }\n            else if (response !== null && typeof response === 'object'\n                && Object.keys(response).length > 0) {\n                Object.keys(response)\n                    .forEach(function(field) {\n                        message += '\\n' + field + ': ' + response[field][0];\n                    });\n            }\n\n            throw message + ' Check debug log for more information.';\n        }\n\n        return {\n            status: request.Status(),\n            response: response\n        };\n    },\n\n    createIncident: function(name, description, fields) {\n        var data = {\n            incident: {\n                name: name,\n                description: description,\n                priority: SolarWinds.params.priority\n            }\n        };\n\n        var result = SolarWinds.request('post', 'incidents.json', SolarWinds.addCustomFields(data, fields));\n\n        if (typeof result.response !== 'object' || typeof result.response.id === 'undefined') {\n            throw 'Cannot create SolarWinds incident. Check debug log for more information.';\n        }\n\n        return result.response.id;\n    },\n\n    updateIncident: function(name, fields, message) {\n        var data = {\n            incident: {\n                name: name,\n                priority: SolarWinds.params.priority\n            }\n        };\n\n        SolarWinds.request(\n            'put',\n            'incidents/' + SolarWinds.params.incident_id + '.json',\n            SolarWinds.addCustomFields(data, fields));\n\n        SolarWinds.commenIncident(message);\n    },\n\n    commenIncident: function(message) {\n        var data = {\n            comment: {\n                body: message\n            }\n        };\n\n        SolarWinds.request('post', 'incidents/' + SolarWinds.params.incident_id + '/comments.json', data);\n    }\n};\n\ntry {\n    var params = JSON.parse(value),\n        fields = {},\n        samanage = {},\n        result = {tags: {}},\n        required_params = ['alert_subject', 'event_recovery_value', 'event_source', 'event_value', 'priority_default'],\n        severities = [\n            {name: 'not_classified'},\n            {name: 'information'},\n            {name: 'warning'},\n            {name: 'average'},\n            {name: 'high'},\n            {name: 'disaster'},\n            {name: 'resolved'},\n            {name: 'default'}\n        ];\n\n    fields.sw_fields = {};\n    fields.sw_customfields = {};\n\n    Object.keys(params)\n        .forEach(function (key) {\n            if (key.startsWith('samanage_')) {\n                samanage[key.substring(9)] = params[key];\n            }\n            else if (key.startsWith('sw_field_')) {\n                fields.sw_fields[key.substring(9)] = params[key];\n            }\n            else if (key.startsWith('sw_customfield_')) {\n                fields.sw_customfields[key.substring(15)] = params[key];\n            }\n            else if (required_params.indexOf(key) !== -1 && params[key] === '') {\n                throw 'Parameter \"' + key + '\" can\\'t be empty.';\n            }\n        });\n\n    if ([0, 1, 2, 3].indexOf(parseInt(params.event_source)) === -1) {\n        throw 'Incorrect \"event_source\" parameter given: ' + params.event_source + '\\nMust be 0-3.';\n    }\n\n    // Check {EVENT.VALUE} for trigger-based and internal events.\n    if (params.event_value !== '0' && params.event_value !== '1'\n        && (params.event_source === '0' || params.event_source === '3')) {\n        throw 'Incorrect \"event_value\" parameter given: ' + params.event_value + '\\nMust be 0 or 1.';\n    }\n\n    // Check {EVENT.UPDATE.STATUS} only for trigger-based events.\n    if (params.event_update_status !== '0' && params.event_update_status !== '1' && params.event_source === '0') {\n        throw 'Incorrect \"event_update_status\" parameter given: ' + params.event_update_status + '\\nMust be 0 or 1.';\n    }\n\n    if (params.event_source !== '0' && params.event_recovery_value === '0') {\n        throw 'Recovery operations are supported only for trigger-based actions.';\n    }\n\n    if ([0, 1, 2, 3, 4, 5].indexOf(parseInt(params.event_nseverity)) === -1) {\n        params.event_nseverity = '7';\n    }\n\n    if (params.event_value === '0') {\n        params.event_nseverity = '6';\n    }\n\n    samanage.priority = params['priority_' + severities[params.event_nseverity].name] || params.priority_default;\n\n    SolarWinds.setParams(samanage);\n    SolarWinds.setProxy(params.HTTPProxy);\n\n    // Create incident for non trigger-based events.\n    if (params.event_source !== '0' && params.event_recovery_value !== '0') {\n        SolarWinds.createIncident(params.alert_subject, params.alert_message);\n    }\n    // Create incident for trigger-based events.\n    else if (params.event_value === '1' && params.event_update_status === '0'\n            && samanage.incident_id === '{EVENT.TAGS.__zbx_solarwinds_inc_id}') {\n        var key = SolarWinds.createIncident(params.alert_subject, params.alert_message, fields);\n\n\n        result.tags.__zbx_solarwinds_inc_id = key;\n        result.tags.__zbx_solarwinds_inc_link = params.samanage_url +\n            (params.samanage_url.endsWith('/') ? '' : '/') + 'incidents/' + key;\n    }\n    // Update created incident for trigger-based event.\n    else {\n        if (samanage.incident_id === '{EVENT.TAGS.__zbx_solarwinds_inc_id}' || samanage.incident_id === '') {\n            throw 'Incorrect incident key given: ' + samanage.incident_id;\n        }\n        if (!params.alert_message) {\n            throw 'Parameter \"alert_message\" can\\'t be empty.';\n        }\n        SolarWinds.updateIncident(params.alert_subject, fields, params.alert_message);\n    }\n\n    if (params.event_source === '0') {\n        return JSON.stringify(result);\n    }\n    else {\n        return 'OK';\n    }\n}\ncatch (error) {\n    Zabbix.Log(3, '[ SolarWinds SD Webhook ] ERROR: ' + error);\n    throw 'Sending failed: ' + error;\n}",
                "process_tags": "YES",
                "show_event_menu": "YES",
                "event_menu_url": "{EVENT.TAGS.__zbx_solarwinds_inc_link}",
                "event_menu_name": "SolarWinds incident ID: {EVENT.TAGS.__zbx_solarwinds_inc_id}",
                "message_templates": [
                    {
                        "event_source": "TRIGGERS",
                        "operation_mode": "PROBLEM",
                        "subject": "[{EVENT.STATUS}] {EVENT.NAME}",
                        "message": "Problem started at {EVENT.TIME} on {EVENT.DATE}\nProblem name: {EVENT.NAME}\nHost: {HOST.NAME}\nSeverity: {EVENT.SEVERITY}\nOperational data: {EVENT.OPDATA}\nOriginal problem ID: {EVENT.ID}\n\nTrigger description: {TRIGGER.DESCRIPTION}"
                    },
                    {
                        "event_source": "TRIGGERS",
                        "operation_mode": "RECOVERY",
                        "subject": "[{EVENT.STATUS}] {EVENT.NAME}",
                        "message": "Problem has been resolved in {EVENT.DURATION} at {EVENT.RECOVERY.TIME} on {EVENT.RECOVERY.DATE}\nProblem name: {EVENT.NAME}\nHost: {HOST.NAME}\nSeverity: {EVENT.SEVERITY}\nOriginal problem ID: {EVENT.ID}\n{TRIGGER.URL}"
                    },
                    {
                        "event_source": "TRIGGERS",
                        "operation_mode": "UPDATE",
                        "subject": "[{EVENT.STATUS}] {EVENT.NAME}",
                        "message": "{USER.FULLNAME} {EVENT.UPDATE.ACTION} problem at {EVENT.UPDATE.DATE} {EVENT.UPDATE.TIME}.\n{EVENT.UPDATE.MESSAGE}\n\nCurrent problem status is {EVENT.STATUS}, acknowledged: {EVENT.ACK.STATUS}."
                    },
                    {
                        "event_source": "DISCOVERY",
                        "operation_mode": "PROBLEM",
                        "subject": "Discovery: {DISCOVERY.DEVICE.STATUS} {DISCOVERY.DEVICE.IPADDRESS}",
                        "message": "Discovery rule: {DISCOVERY.RULE.NAME}\n\nDevice IP: {DISCOVERY.DEVICE.IPADDRESS}\nDevice DNS: {DISCOVERY.DEVICE.DNS}\nDevice status: {DISCOVERY.DEVICE.STATUS}\nDevice uptime: {DISCOVERY.DEVICE.UPTIME}\n\nDevice service name: {DISCOVERY.SERVICE.NAME}\nDevice service port: {DISCOVERY.SERVICE.PORT}\nDevice service status: {DISCOVERY.SERVICE.STATUS}\nDevice service uptime: {DISCOVERY.SERVICE.UPTIME}"
                    },
                    {
                        "event_source": "AUTOREGISTRATION",
                        "operation_mode": "PROBLEM",
                        "subject": "Autoregistration: {HOST.HOST}",
                        "message": "Host name: {HOST.HOST}\nHost IP: {HOST.IP}\nAgent port: {HOST.PORT}"
                    }
                ]
            },
            {
                "name": "SysAid",
                "type": "WEBHOOK",
                "parameters": [
                    {
                        "name": "alert_message",
                        "value": "{ALERT.MESSAGE}"
                    },
                    {
                        "name": "alert_subject",
                        "value": "{ALERT.SUBJECT}"
                    },
                    {
                        "name": "event_id",
                        "value": "{EVENT.ID}"
                    },
                    {
                        "name": "event_nseverity",
                        "value": "{EVENT.NSEVERITY}"
                    },
                    {
                        "name": "event_source",
                        "value": "{EVENT.SOURCE}"
                    },
                    {
                        "name": "event_update_message",
                        "value": "{EVENT.UPDATE.MESSAGE}"
                    },
                    {
                        "name": "event_update_status",
                        "value": "{EVENT.UPDATE.STATUS}"
                    },
                    {
                        "name": "event_value",
                        "value": "{EVENT.VALUE}"
                    },
                    {
                        "name": "sysaid_auth_password",
                        "value": "<PUT YOUR USER PASSWORD>"
                    },
                    {
                        "name": "sysaid_auth_user",
                        "value": "<PUT YOUR USER NAME>"
                    },
                    {
                        "name": "sysaid_category_level_1",
                        "value": "<PUT YOUR CATEGORY>"
                    },
                    {
                        "name": "sysaid_category_level_2",
                        "value": "<PUT YOUR SUB-CATEGORY>"
                    },
                    {
                        "name": "sysaid_category_level_3",
                        "value": "<PUT YOUR THIRD LEVEL CATEGORY>"
                    },
                    {
                        "name": "sysaid_default_priority_id",
                        "value": "1"
                    },
                    {
                        "name": "sysaid_incident_id",
                        "value": "{EVENT.TAGS.__zbx_sysaid_incident_id}"
                    },
                    {
                        "name": "sysaid_incident_state",
                        "value": "1"
                    },
                    {
                        "name": "sysaid_template_id",
                        "value": "<PUT YOUR TEMPLATE ID>"
                    },
                    {
                        "name": "sysaid_urgency_id",
                        "value": "<PUT YOUR URGENCY ID>"
                    },
                    {
                        "name": "sysaid_url",
                        "value": "<PUT YOUR SYSAID URL>"
                    },
                    {
                        "name": "trigger_id",
                        "value": "{TRIGGER.ID}"
                    },
                    {
                        "name": "zabbix_url",
                        "value": "{$ZABBIX.URL}"
                    }
                ],
                "status": "DISABLED",
                "script": "var SysAid = {\n    params: {},\n\n    setParams: function (params) {\n        var required = ['url', 'auth_user', 'auth_password', 'category_level_1', 'category_level_2',\n            'category_level_3', 'incident_id', 'template_id', 'urgency_id', 'incident_state',\n            'default_priority_id'\n        ];\n\n        required.forEach(function (field) {\n            if (typeof params !== 'object' || typeof params[field] === 'undefined' || params[field] === '') {\n                throw 'Required param is not set: \"' + field + '\".';\n            }\n        });\n\n        SysAid.params = params;\n        if (typeof SysAid.params.url === 'string' && !SysAid.params.url.endsWith('/')) {\n            SysAid.params.url += '/';\n        }\n    },\n\n    login: function () {\n        var result = SysAid.request('post', 'api/v1/login', {\n            user_name: SysAid.params.auth_user,\n            password: SysAid.params.auth_password\n        });\n\n        return result.response.user.id;\n    },\n\n    request: function (method, query, data) {\n        var response,\n            request = SysAid.req || (SysAid.req = new CurlHttpRequest()),\n            url = SysAid.params.url + query;\n\n        if (typeof SysAid.HTTPProxy !== 'undefined' && SysAid.HTTPProxy.trim() !== '') {\n            request.SetProxy(SysAid.HTTPProxy);\n        }\n\n        if (typeof data !== 'undefined') {\n            data = JSON.stringify(data);\n        }\n\n        Zabbix.Log(4, '[ SysAid Webhook ] Sending request: ' +\n            url + ((typeof data === 'string') ? (' ' + data) : ''));\n\n        switch (method) {\n            case 'get':\n                response = request.Get(url, data);\n                break;\n\n            case 'post':\n                response = request.Post(url, data);\n                break;\n\n            case 'put':\n                response = request.Put(url, data);\n                break;\n\n            default:\n                throw 'Unsupported HTTP request method: ' + method;\n        }\n\n        Zabbix.Log(4, '[ SysAid Webhook ] Received response with status code ' + request.Status() + ': ' + response);\n\n        if (request.Status() !== 200) {\n            var message = 'Request failed with status code ' + request.Status();\n\n            message += ': ' + response;\n            throw message + ' Check debug log for more information.';\n        }\n\n        if (response !== null) {\n            try {\n                response = JSON.parse(response);\n            }\n            catch (error) {\n                Zabbix.Log(4, '[ SysAid Webhook ] Failed to parse response received from SysAid');\n                response = null;\n            }\n        }\n\n        if (response === null || (typeof response.Error !== 'undefined' && Object.keys(response.Error).length > 0)) {\n            throw 'Request failed: ' + JSON.stringify(response.Error);\n        }\n\n        return {\n            status: request.Status(),\n            response: response\n        };\n    },\n\n    createIncident: function(subject, message, priority) {\n        var result = SysAid.request('post', 'api/v1/sr/?template=' + encodeURIComponent(SysAid.params.template_id), {\n            info: [\n                {\n                    key: 'problem_type',\n                    value: [\n                        SysAid.params.category_level_1,\n                        SysAid.params.category_level_2,\n                        SysAid.params.category_level_3\n                    ].join('_')\n                },\n                {\n                    key: 'title',\n                    value: subject\n                },\n                {\n                    key: 'description',\n                    value: message\n                },\n                {\n                    key: 'status',\n                    value: '1'\n                },\n                {\n                    key: 'urgency',\n                    value: SysAid.params.urgency_id\n                },\n                {\n                    key: 'priority',\n                    value: priority || SysAid.params.default_priority_id,\n                }\n            ]\n        });\n\n        if (result.response.id === 'undefined') {\n            throw 'Cannot create SysAid incident. Check debug log for more information.';\n        }\n\n        return result.response.id;\n    },\n\n    updateTicket: function(note) {\n        var date = new Date().getTime();\n\n        SysAid.request('put', 'api/v1/sr/' + encodeURIComponent(SysAid.params.incident_id), {\n            id: SysAid.params.incident_id,\n            info: [\n                {\n                    key: 'update_time',\n                    value: date\n                },\n                {\n                    key: 'notes',\n                    value: [\n                        {\n                            userName: 'Zabbix',\n                            createDate: date,\n                            text: note\n                        }\n                    ]\n                }\n            ]\n        });\n    }\n};\n\ntry {\n    var params = JSON.parse(value),\n        params_sysaid = {},\n        params_update = {},\n        result = {tags: {}},\n        required_params = ['alert_subject', 'event_source', 'event_value',  'event_update_status'],\n        severities = [\n            {name: 'not_classified', color: '#97AAB3'},\n            {name: 'information', color: '#7499FF'},\n            {name: 'warning', color: '#FFC859'},\n            {name: 'average', color: '#FFA059'},\n            {name: 'high', color: '#E97659'},\n            {name: 'disaster', color: '#E45959'},\n            {name: 'resolved', color: '#009900'},\n            {name: null, color: '#000000'}\n        ],\n        priority;\n\n    Object.keys(params)\n        .forEach(function (key) {\n            if (key.startsWith('sysaid_')) {\n                params_sysaid[key.substring(7)] = params[key];\n            }\n            else if (key.startsWith('event_update_')) {\n                params_update[key.substring(13)] = params[key];\n            }\n            else if (required_params.indexOf(key) !== -1 && params[key].trim() === '') {\n                throw 'Parameter \"' + key + '\" cannot be empty.';\n            }\n        });\n\n    if ([0, 1, 2, 3].indexOf(parseInt(params.event_source)) === -1) {\n        throw 'Incorrect \"event_source\" parameter given: ' + params.event_source + '\\nMust be 0-3.';\n    }\n\n    // Check {EVENT.VALUE} for trigger-based and internal events.\n    if (params.event_value !== '0' && params.event_value !== '1'\n        && (params.event_source === '0' || params.event_source === '3')) {\n        throw 'Incorrect \"event_value\" parameter given: ' + params.event_value + '\\nMust be 0 or 1.';\n    }\n\n    // Check {EVENT.UPDATE.STATUS} only for trigger-based events.\n    if (params.event_source === '0' && params.event_update_status !== '0' && params.event_update_status !== '1') {\n        throw 'Incorrect \"event_update_status\" parameter given: ' + params.event_update_status + '\\nMust be 0 or 1.';\n    }\n\n    if (params.event_source !== '0' && params.event_value === '0') {\n        throw 'Recovery operations are supported only for trigger-based actions.';\n    }\n\n    if (params.event_source === '0' && ((params.event_value === '1' && params.event_update_status === '1')\n            || (params.event_value === '0' && (params.event_update_status === '0' || params.event_update_status === '1')))\n            && (isNaN(parseInt(params.sysaid_incident_id)) || parseInt(params.sysaid_incident_id) < 1 )) {\n        throw 'Incorrect \"sysaid_incident_id\" parameter given: ' + params.sysaid_incident_id + '\\nMust be positive integer.';\n    }\n\n    if ([0, 1, 2, 3, 4, 5].indexOf(parseInt(params.event_nseverity)) === -1) {\n        params.event_nseverity = '7';\n    }\n\n    if (params.event_value === '0') {\n        params.event_nseverity = '6';\n    }\n\n    priority = params['severity_' + severities[params.event_nseverity].name];\n    priority = priority && priority.trim() || severities[7].name;\n\n    SysAid.setParams(params_sysaid);\n    SysAid.HTTPProxy = params.HTTPProxy;\n    SysAid.login();\n\n    if (params.event_source !== '0' && params.event_value !== '0') {\n        // Create ticket for non trigger-based events.\n        SysAid.createIncident(params.alert_subject, params.alert_message, priority);\n    }\n    else if (params.event_value === '1' && params_update.status === '0') {\n        // Create ticket for trigger-based events.\n        var incident_id = SysAid.createIncident(params.alert_subject, params.alert_subject + '\\n' + params.alert_message +\n                '\\n' + params.zabbix_url + (params.zabbix_url.endsWith('/') ? '' : '/') + 'tr_events.php?triggerid=' +\n                params.trigger_id + '&eventid=' + params.event_id + '\\n', priority\n        );\n\n        result.tags.__zbx_sysaid_incident_id = incident_id;\n        result.tags.__zbx_sysaid_incidentlink = params.sysaid_url +\n            (params.sysaid_url.endsWith('/') ? '' : '/') + 'SREdit.jsp?id=' + incident_id + '&fromId=IncidentsList';\n    }\n    else {\n        // Update created ticket for trigger-based event.\n        SysAid.updateTicket(params.alert_subject + '\\n' + params.alert_message);\n    }\n\n    return JSON.stringify(result);\n}\ncatch (error) {\n    Zabbix.Log(3, '[ SysAid Webhook ] ERROR: ' + error);\n    throw 'Sending failed: ' + error;\n}",
                "process_tags": "YES",
                "show_event_menu": "YES",
                "event_menu_url": "{EVENT.TAGS.__zbx_sysaid_incidentlink}",
                "event_menu_name": "SysAid: incident #{EVENT.TAGS.__zbx_sysaid_incident_id}",
                "message_templates": [
                    {
                        "event_source": "TRIGGERS",
                        "operation_mode": "PROBLEM",
                        "subject": "Problem: {EVENT.NAME}",
                        "message": "Problem started at {EVENT.TIME} on {EVENT.DATE}\nProblem name: {EVENT.NAME}\nHost: {HOST.NAME}\nSeverity: {EVENT.SEVERITY}\nOperational data: {EVENT.OPDATA}\nOriginal problem ID: {EVENT.ID}\n{TRIGGER.URL}"
                    },
                    {
                        "event_source": "TRIGGERS",
                        "operation_mode": "RECOVERY",
                        "subject": "Resolved: {EVENT.NAME}",
                        "message": "Problem has been resolved in {EVENT.DURATION} at {EVENT.RECOVERY.TIME} on {EVENT.RECOVERY.DATE}\nProblem name: {EVENT.NAME}\nHost: {HOST.NAME}\nSeverity: {EVENT.SEVERITY}\nOriginal problem ID: {EVENT.ID}\n{TRIGGER.URL}"
                    },
                    {
                        "event_source": "TRIGGERS",
                        "operation_mode": "UPDATE",
                        "subject": "Updated problem: {EVENT.NAME}",
                        "message": "{USER.FULLNAME} {EVENT.UPDATE.ACTION} problem at {EVENT.UPDATE.DATE} {EVENT.UPDATE.TIME}.\n{EVENT.UPDATE.MESSAGE}\n\nCurrent problem status is {EVENT.STATUS}, acknowledged: {EVENT.ACK.STATUS}."
                    },
                    {
                        "event_source": "DISCOVERY",
                        "operation_mode": "PROBLEM",
                        "subject": "Discovery: {DISCOVERY.DEVICE.STATUS} {DISCOVERY.DEVICE.IPADDRESS}",
                        "message": "Discovery rule: {DISCOVERY.RULE.NAME}\n\nDevice IP: {DISCOVERY.DEVICE.IPADDRESS}\nDevice DNS: {DISCOVERY.DEVICE.DNS}\nDevice status: {DISCOVERY.DEVICE.STATUS}\nDevice uptime: {DISCOVERY.DEVICE.UPTIME}\n\nDevice service name: {DISCOVERY.SERVICE.NAME}\nDevice service port: {DISCOVERY.SERVICE.PORT}\nDevice service status: {DISCOVERY.SERVICE.STATUS}\nDevice service uptime: {DISCOVERY.SERVICE.UPTIME}"
                    },
                    {
                        "event_source": "AUTOREGISTRATION",
                        "operation_mode": "PROBLEM",
                        "subject": "Autoregistration: {HOST.HOST}",
                        "message": "Host name: {HOST.HOST}\nHost IP: {HOST.IP}\nAgent port: {HOST.PORT}"
                    }
                ]
            },
            {
                "name": "Telegram",
                "type": "WEBHOOK",
                "parameters": [
                    {
                        "name": "Message",
                        "value": "{ALERT.MESSAGE}"
                    },
                    {
                        "name": "ParseMode",
                        "value": ""
                    },
                    {
                        "name": "Subject",
                        "value": "{ALERT.SUBJECT}"
                    },
                    {
                        "name": "To",
                        "value": "{ALERT.SENDTO}"
                    },
                    {
                        "name": "Token",
                        "value": "<PLACE YOUR TOKEN>"
                    }
                ],
                "status": "DISABLED",
                "script": "var Telegram = {\n    token: null,\n    to: null,\n    message: null,\n    proxy: null,\n    parse_mode: null,\n\n    sendMessage: function() {\n        var params = {\n            chat_id: Telegram.to,\n            text: Telegram.message,\n            disable_web_page_preview: true,\n            disable_notification: false\n        },\n        data,\n        response,\n        request = new CurlHttpRequest(),\n        url = 'https://api.telegram.org/bot' + Telegram.token + '/sendMessage';\n\n        if (Telegram.parse_mode !== null) {\n            params['parse_mode'] = Telegram.parse_mode;\n        }\n\n        if (Telegram.proxy) {\n            request.SetProxy(Telegram.proxy);\n        }\n\n        request.AddHeader('Content-Type: application/json');\n        data = JSON.stringify(params);\n\n        // Remove replace() function if you want to see the exposed token in the log file.\n        Zabbix.Log(4, '[Telegram Webhook] URL: ' + url.replace(Telegram.token, '<TOKEN>'));\n        Zabbix.Log(4, '[Telegram Webhook] params: ' + data);\n        response = request.Post(url, data);\n        Zabbix.Log(4, '[Telegram Webhook] HTTP code: ' + request.Status());\n\n        try {\n            response = JSON.parse(response);\n        }\n        catch (error) {\n            response = null;\n        }\n\n        if (request.Status() !== 200 || typeof response.ok !== 'boolean' || response.ok !== true) {\n            if (typeof response.description === 'string') {\n                throw response.description;\n            }\n            else {\n                throw 'Unknown error. Check debug log for more information.'\n            }\n        }\n    }\n}\n\ntry {\n    var params = JSON.parse(value);\n\n    if (typeof params.Token === 'undefined') {\n        throw 'Incorrect value is given for parameter \"Token\": parameter is missing';\n    }\n\n    Telegram.token = params.Token;\n\n    if (params.HTTPProxy) {\n        Telegram.proxy = params.HTTPProxy;\n    } \n\n    if (['Markdown', 'HTML', 'MarkdownV2'].indexOf(params.ParseMode) !== -1) {\n        Telegram.parse_mode = params.ParseMode;\n    }\n\n    Telegram.to = params.To;\n    Telegram.message = params.Subject + '\\n' + params.Message;\n    Telegram.sendMessage();\n\n    return 'OK';\n}\ncatch (error) {\n    Zabbix.Log(4, '[Telegram Webhook] notification failed: ' + error);\n    throw 'Sending failed: ' + error + '.';\n}",
                "timeout": "10s",
                "description": "https://git.zabbix.com/projects/ZBX/repos/zabbix/browse/templates/media/telegram\n\n1. Register bot: send \"/newbot\" to @BotFather and follow instructions\n2. Copy and paste the obtained token into the \"Token\" field above\n3. If you want to send personal notifications, you need to get chat id of the user you want to send messages to:\n    3.1. Send \"/getid\" to \"@myidbot\" in Telegram messenger\n    3.2. Copy returned chat id and save it in the \"Telegram Webhook\" media for the user\n    3.3. Ask the user to send \"/start\" to your bot (Telegram bot won't send anything to the user without it)\n4. If you want to send group notifications, you need to get group id of the group you want to send messages to:\n    4.1. Add \"@myidbot\" to your group\n    4.2. Send \"/getgroupid@myidbot\" in your group\n    4.3. Copy returned group id save it in the \"Telegram Webhook\" media for the user you created for  group notifications\n    4.4. Send \"/start@your_bot_name_here\" in your group (Telegram bot won't send anything to the group without it)",
                "message_templates": [
                    {
                        "event_source": "TRIGGERS",
                        "operation_mode": "PROBLEM",
                        "subject": "Problem: {EVENT.NAME}",
                        "message": "Problem started at {EVENT.TIME} on {EVENT.DATE}\nProblem name: {EVENT.NAME}\nHost: {HOST.NAME}\nSeverity: {EVENT.SEVERITY}\nOperational data: {EVENT.OPDATA}\nOriginal problem ID: {EVENT.ID}\n{TRIGGER.URL}"
                    },
                    {
                        "event_source": "TRIGGERS",
                        "operation_mode": "RECOVERY",
                        "subject": "Resolved in {EVENT.DURATION}: {EVENT.NAME}",
                        "message": "Problem has been resolved in {EVENT.DURATION} at {EVENT.RECOVERY.TIME} on {EVENT.RECOVERY.DATE}\nProblem name: {EVENT.NAME}\nHost: {HOST.NAME}\nSeverity: {EVENT.SEVERITY}\nOriginal problem ID: {EVENT.ID}\n{TRIGGER.URL}"
                    },
                    {
                        "event_source": "TRIGGERS",
                        "operation_mode": "UPDATE",
                        "subject": "Updated problem: {EVENT.NAME}",
                        "message": "{USER.FULLNAME} {EVENT.UPDATE.ACTION} problem at {EVENT.UPDATE.DATE} {EVENT.UPDATE.TIME}.\n{EVENT.UPDATE.MESSAGE}\n\nCurrent problem status is {EVENT.STATUS}, acknowledged: {EVENT.ACK.STATUS}."
                    },
                    {
                        "event_source": "DISCOVERY",
                        "operation_mode": "PROBLEM",
                        "subject": "Discovery: {DISCOVERY.DEVICE.STATUS} {DISCOVERY.DEVICE.IPADDRESS}",
                        "message": "Discovery rule: {DISCOVERY.RULE.NAME}\n\nDevice IP: {DISCOVERY.DEVICE.IPADDRESS}\nDevice DNS: {DISCOVERY.DEVICE.DNS}\nDevice status: {DISCOVERY.DEVICE.STATUS}\nDevice uptime: {DISCOVERY.DEVICE.UPTIME}\n\nDevice service name: {DISCOVERY.SERVICE.NAME}\nDevice service port: {DISCOVERY.SERVICE.PORT}\nDevice service status: {DISCOVERY.SERVICE.STATUS}\nDevice service uptime: {DISCOVERY.SERVICE.UPTIME}"
                    },
                    {
                        "event_source": "AUTOREGISTRATION",
                        "operation_mode": "PROBLEM",
                        "subject": "Autoregistration: {HOST.HOST}",
                        "message": "Host name: {HOST.HOST}\nHost IP: {HOST.IP}\nAgent port: {HOST.PORT}"
                    }
                ]
            },
            {
                "name": "TOPdesk",
                "type": "WEBHOOK",
                "parameters": [
                    {
                        "name": "alert_message",
                        "value": "{ALERT.MESSAGE}"
                    },
                    {
                        "name": "alert_subject",
                        "value": "{ALERT.SUBJECT}"
                    },
                    {
                        "name": "event_id",
                        "value": "{EVENT.ID}"
                    },
                    {
                        "name": "event_nseverity",
                        "value": "{EVENT.NSEVERITY}"
                    },
                    {
                        "name": "event_source",
                        "value": "{EVENT.SOURCE}"
                    },
                    {
                        "name": "event_update_status",
                        "value": "{EVENT.UPDATE.STATUS}"
                    },
                    {
                        "name": "event_value",
                        "value": "{EVENT.VALUE}"
                    },
                    {
                        "name": "severity_average",
                        "value": "P3"
                    },
                    {
                        "name": "severity_default",
                        "value": "P5"
                    },
                    {
                        "name": "severity_disaster",
                        "value": "P1"
                    },
                    {
                        "name": "severity_high",
                        "value": "P2"
                    },
                    {
                        "name": "severity_information",
                        "value": "P5"
                    },
                    {
                        "name": "severity_not_classified",
                        "value": "P5"
                    },
                    {
                        "name": "severity_warning",
                        "value": "P4"
                    },
                    {
                        "name": "topdesk_api",
                        "value": "<put your TOPdesk API URL>"
                    },
                    {
                        "name": "topdesk_issue_key",
                        "value": "{EVENT.TAGS.__zbx_tpd_issuekey}"
                    },
                    {
                        "name": "topdesk_password",
                        "value": "<put your TOPdesk application password>"
                    },
                    {
                        "name": "topdesk_status",
                        "value": "<put default status for new tickets>"
                    },
                    {
                        "name": "topdesk_user",
                        "value": "<put your TOPdesk username>"
                    },
                    {
                        "name": "trigger_id",
                        "value": "{TRIGGER.ID}"
                    },
                    {
                        "name": "zbxurl",
                        "value": "{$ZABBIX.URL}"
                    }
                ],
                "status": "DISABLED",
                "script": "var Media = {\n    params: {},\n    name: '',\n    labels: [],\n    HTTPProxy: '',\n\n    setParams: function (params) {\n        if (typeof params !== 'object') {\n            return;\n        }\n\n        Media.params = params;\n        Media.params.api += Media.params.api.endsWith('/') ? '' : '/';\n    },\n\n    setProxy: function (HTTPProxy) {\n        if (typeof HTTPProxy !== 'undefined' && HTTPProxy.trim() !== '') {\n            Media.HTTPProxy = HTTPProxy;\n        }\n    },\n\n    request: function (method, query, data) {\n        ['api', 'token'].forEach(function (field) {\n            if (typeof Media.params !== 'object' || typeof Media.params[field] === 'undefined'\n                    || Media.params[field] === '') {\n                throw 'Required ' + Media.name + ' param is not set: \"' + field + '\".';\n            }\n        });\n\n        var response,\n            url = Media.params.api + query,\n            request = new CurlHttpRequest();\n\n        request.AddHeader('Content-Type: application/json');\n        request.AddHeader('Accept: application/json');\n        request.AddHeader('Authorization: ' + Media.params.token);\n        request.SetProxy(Media.HTTPProxy);\n\n        if (typeof data !== 'undefined') {\n            data = JSON.stringify(data);\n        }\n\n        Zabbix.Log(4, '[ ' + Media.name + ' Webhook ] Sending request: ' +\n            url + ((typeof data === 'string') ? ('\\n' + data) : ''));\n\n        switch (method) {\n            case 'get':\n                response = request.Get(url, data);\n                break;\n\n            case 'post':\n                response = request.Post(url, data);\n                break;\n\n            case 'put':\n                response = request.Put(url, data);\n                break;\n\n            default:\n                throw 'Unsupported HTTP request method: ' + method;\n        }\n\n        Zabbix.Log(4, '[ ' + Media.name + ' Webhook ] Received response with status code ' +\n            request.Status() + '\\n' + response);\n\n        if (response !== null) {\n            try {\n                response = JSON.parse(response);\n            }\n            catch (error) {\n                Zabbix.Log(4, '[ ' + Media.name + ' Webhook ] Failed to parse response.');\n                response = null;\n            }\n        }\n\n        if (request.Status() < 200 || request.Status() >= 300) {\n            var message = 'Request failed with status code ' + request.Status();\n\n            if (response !== null) {\n                if (typeof response.errors === 'object' && Object.keys(response.errors).length > 0) {\n                    message += ': ' + JSON.stringify(response.errors);\n                }\n                else if (typeof response.errorMessages === 'object' && Object.keys(response.errorMessages).length > 0) {\n                    message += ': ' + JSON.stringify(response.errorMessages);\n                }\n                else if (typeof response.message === 'string') {\n                    message += ': ' + response.message;\n                }\n            }\n\n            throw message + ' Check debug log for more information.';\n        }\n\n        return {\n            status: request.Status(),\n            response: response\n        };\n    }\n};\n\ntry {\n    var result = {tags: {}},\n        params = JSON.parse(value),\n        media = {},\n        fields = {},\n        resp = {},\n        required_params = [\n            'alert_subject',\n            'alert_message',\n            'event_id',\n            'event_source',\n            'event_value',\n            'event_update_status',\n            'topdesk_api',\n            'topdesk_user',\n            'topdesk_password'\n        ],\n        severities = [\n            'not_classified',\n            'information',\n            'warning',\n            'average',\n            'high',\n            'disaster',\n            'resolved',\n            'default'\n        ],\n        priority;\n\n    Object.keys(params)\n        .forEach(function (key) {\n            if (required_params.indexOf(key) !== -1 && params[key].trim() === '') {\n                throw 'Parameter \"' + key + '\" cannot be empty.';\n            }\n            if (key.startsWith('topdesk_')) {\n                media[key.substring(8)] = params[key];\n            }\n        });\n\n    // Possible values of event_source:\n    // 0 - Trigger, 1 - Discovery, 2 - Autoregistration, 3 - Internal.\n    if ([0, 1, 2, 3].indexOf(parseInt(params.event_source)) === -1) {\n        throw 'Incorrect \"event_source\" parameter given: \"' + params.event_source + '\".\\nMust be 0-3.';\n    }\n\n    // Check event_value for trigger-based and internal events.\n    // Possible values: 1 for problem, 0 for recovering\n    if (params.event_value !== '0' && params.event_value !== '1'\n        && (params.event_source === '0' || params.event_source === '3')) {\n        throw 'Incorrect \"event_value\" parameter given: ' + params.event_value + '\\nMust be 0 or 1.';\n    }\n\n    // Check event_update_status only for trigger-based events.\n    // Possible values: 0 - Webhook was called because of problem/recovery event, 1 - Update operation.\n    if (params.event_source === '0' && params.event_update_status !== '0' && params.event_update_status !== '1') {\n        throw 'Incorrect \"event_update_status\" parameter given: ' + params.event_update_status + '\\nMust be 0 or 1.';\n    }\n\n    // Check event_id for a numeric value.\n    if (isNaN(parseInt(params.event_id)) || params.event_id < 1) {\n        throw 'Incorrect \"event_id\" parameter given: ' + params.event_id + '\\nMust be a positive number.';\n    }\n\n    if ((params.event_source === '1' || params.event_source === '2')  && params.event_value === '0') {\n        throw 'Recovery operations are supported only for Trigger and Internal actions.';\n    }\n\n    if ([0, 1, 2, 3, 4, 5].indexOf(parseInt(params.event_nseverity)) === -1) {\n        params.event_nseverity = '7';\n    }\n\n    if (params.event_value === '0') {\n        params.event_nseverity = '6';\n    }\n\n    priority = params['severity_' + severities[params.event_nseverity]];\n    params.zbxurl = params.zbxurl + (params.zbxurl.endsWith('/') ? '' : '/');\n\n    Media.name = 'TOPdesk';\n    Media.setParams(media);\n    Media.params.token = 'Basic ' + btoa(Media.params.user + ':' + Media.params.password);\n    Media.setProxy(params.HTTPProxy);\n\n    // Create an issue.\n    // Numeric value of the event that triggered an action (1 for problem, 0 for recovering).\n    // Numeric value of of the problem update status. Possible values:\n    // 0 - Webhook was called because of problem/recovery event, 1 - Update operation.\n    if ((params.event_source == 0 && params.event_value == 1 && params.event_update_status == 0)\n            || (params.event_source == 3 && params.event_value == 1)\n            || params.event_source == 1 || params.event_source == 2) {\n        Zabbix.Log(4, '[ ' + Media.name + ' Webhook ] Request of the ticket creating.');\n        fields.caller = {dynamicName: 'Zabbix'};\n        fields.briefDescription = params.alert_subject;\n        fields.request = params.alert_message.replace(/\\n/g, '<br>');\n        fields.priority = {name: priority};\n        fields.processingStatus = {name: Media.params.status};\n        fields.externalNumber = params.event_id;\n        fields.request += '<br>' + params.zbxurl;\n\n        if (params.event_source === '0') {\n            fields.request += 'tr_events.php?triggerid=' + params.trigger_id + '&eventid=' + params.event_id;\n        }\n\n        resp = Media.request('post', 'tas/api/incidents', fields);\n        if (typeof resp.response !== 'object' || typeof resp.response.id === 'undefined') {\n            throw 'Cannot create ' + Media.name + ' issue. Check debug log for more information.';\n        }\n\n        if (params.event_source == 0 && params.event_value == 1 && params.event_update_status == 0) {\n            result.tags.__zbx_tpd_issuekey = resp.response.number;\n            result.tags.__zbx_tpd_issuelink = Media.params.api +\n                'tas/secure/incident?action=show&unid=' + resp.response.id;\n        }\n    }\n    // Update a created issue.\n    else {\n        if (params.event_source == 3 && params.event_value == 0) {\n            throw 'Internal event recovery actions are not supported.';\n        }\n\n        Zabbix.Log(4, '[ ' + Media.name + ' Webhook ] Request of the ticket updating.');\n        fields.action = params.alert_message.replace(/\\n/g, '<br>');\n\n        resp = Media.request('put', 'tas/api/incidents/number/' + Media.params.issue_key, fields);\n        if (typeof resp.response !== 'object' || typeof resp.response.id === 'undefined'\n                || resp.response.number !== Media.params.issue_key) {\n            throw 'Cannot update ' + Media.name + ' issue. Check debug log for more information.';\n        }\n    }\n\n    return JSON.stringify(result);\n}\ncatch (error) {\n    Zabbix.Log(3, '[ ' + Media.name + ' Webhook ] ERROR: ' + error);\n    throw 'Sending failed: ' + error;\n}",
                "process_tags": "YES",
                "show_event_menu": "YES",
                "event_menu_url": "{EVENT.TAGS.__zbx_tpd_issuelink}",
                "event_menu_name": "TOPdesk: {EVENT.TAGS.__zbx_tpd_issuekey}",
                "description": "Please refer to https://developers.topdesk.com/documentation/index.html and https://www.zabbix.com/documentation/5.2/manual/config/notifications/media/webhook#example_scripts.\n  \nSet global macro {$ZABBIX.URL} with your Zabbix server URL.\nAdd a dedicated user with the media type \"TOPdesk\".\nChange the values of the variables topdesk_api (URL), topdesk_password, topdesk_user. The topdesk_status is the default status for creating a new TOPdesk ticket.",
                "message_templates": [
                    {
                        "event_source": "TRIGGERS",
                        "operation_mode": "PROBLEM",
                        "subject": "Problem: {EVENT.NAME}",
                        "message": "Problem started at {EVENT.TIME} on {EVENT.DATE}\nProblem name: {EVENT.NAME}\nHost: {HOST.NAME}\nSeverity: {EVENT.SEVERITY}\nOperational data: {EVENT.OPDATA}\nOriginal problem ID: {EVENT.ID}\n{TRIGGER.URL}"
                    },
                    {
                        "event_source": "TRIGGERS",
                        "operation_mode": "RECOVERY",
                        "subject": "Resolved in {EVENT.DURATION}: {EVENT.NAME}",
                        "message": "Problem has been resolved at {EVENT.RECOVERY.TIME} on {EVENT.RECOVERY.DATE}\nProblem name: {EVENT.NAME}\nProblem duration: {EVENT.DURATION}\nHost: {HOST.NAME}\nSeverity: {EVENT.SEVERITY}\nOriginal problem ID: {EVENT.ID}\n{TRIGGER.URL}"
                    },
                    {
                        "event_source": "TRIGGERS",
                        "operation_mode": "UPDATE",
                        "subject": "Updated problem in {EVENT.AGE}: {EVENT.NAME}",
                        "message": "{USER.FULLNAME} {EVENT.UPDATE.ACTION} problem at {EVENT.UPDATE.DATE} {EVENT.UPDATE.TIME}.\n{EVENT.UPDATE.MESSAGE}\n\nCurrent problem status is {EVENT.STATUS}, age is {EVENT.AGE}, acknowledged: {EVENT.ACK.STATUS}."
                    },
                    {
                        "event_source": "DISCOVERY",
                        "operation_mode": "PROBLEM",
                        "subject": "Discovery: {DISCOVERY.DEVICE.STATUS} {DISCOVERY.DEVICE.IPADDRESS}",
                        "message": "Discovery rule: {DISCOVERY.RULE.NAME}\n\nDevice IP: {DISCOVERY.DEVICE.IPADDRESS}\nDevice DNS: {DISCOVERY.DEVICE.DNS}\nDevice status: {DISCOVERY.DEVICE.STATUS}\nDevice uptime: {DISCOVERY.DEVICE.UPTIME}\n\nDevice service name: {DISCOVERY.SERVICE.NAME}\nDevice service port: {DISCOVERY.SERVICE.PORT}\nDevice service status: {DISCOVERY.SERVICE.STATUS}\nDevice service uptime: {DISCOVERY.SERVICE.UPTIME}"
                    },
                    {
                        "event_source": "AUTOREGISTRATION",
                        "operation_mode": "PROBLEM",
                        "subject": "Autoregistration: {HOST.HOST}",
                        "message": "Host name: {HOST.HOST}\nHost IP: {HOST.IP}\nAgent port: {HOST.PORT}"
                    }
                ]
            },
            {
                "name": "VictorOps",
                "type": "WEBHOOK",
                "parameters": [
                    {
                        "name": "event_info",
                        "value": "{$ZABBIX.URL}/tr_events.php?triggerid={TRIGGER.ID}&eventid={EVENT.ID}"
                    },
                    {
                        "name": "event_nseverity",
                        "value": "{EVENT.NSEVERITY}"
                    },
                    {
                        "name": "event_recovery_value",
                        "value": "{EVENT.RECOVERY.VALUE}"
                    },
                    {
                        "name": "event_source",
                        "value": "{EVENT.SOURCE}"
                    },
                    {
                        "name": "event_update_status",
                        "value": "{EVENT.UPDATE.STATUS}"
                    },
                    {
                        "name": "event_value",
                        "value": "{EVENT.VALUE}"
                    },
                    {
                        "name": "field:entity_display_name",
                        "value": "{ALERT.SUBJECT}"
                    },
                    {
                        "name": "field:entity_id",
                        "value": "{EVENT.ID}"
                    },
                    {
                        "name": "field:hostname",
                        "value": "{HOST.NAME}"
                    },
                    {
                        "name": "field:monitoring_tool",
                        "value": "Zabbix"
                    },
                    {
                        "name": "field:operational_data",
                        "value": "{EVENT.OPDATA}"
                    },
                    {
                        "name": "field:severity",
                        "value": "{EVENT.SEVERITY}"
                    },
                    {
                        "name": "field:state_message",
                        "value": "{ALERT.MESSAGE}"
                    },
                    {
                        "name": "field_p:trigger_description",
                        "value": "{TRIGGER.DESCRIPTION}"
                    },
                    {
                        "name": "field_r:event_duration",
                        "value": "{EVENT.DURATION}"
                    },
                    {
                        "name": "field_r:recovery time",
                        "value": "{EVENT.RECOVERY.DATE} {EVENT.RECOVERY.TIME}"
                    },
                    {
                        "name": "priority_average",
                        "value": "WARNING"
                    },
                    {
                        "name": "priority_default",
                        "value": "INFO"
                    },
                    {
                        "name": "priority_disaster",
                        "value": "CRITICAL"
                    },
                    {
                        "name": "priority_high",
                        "value": "WARNING"
                    },
                    {
                        "name": "priority_information",
                        "value": "INFO"
                    },
                    {
                        "name": "priority_not_classified",
                        "value": "INFO"
                    },
                    {
                        "name": "priority_resolved",
                        "value": "OK"
                    },
                    {
                        "name": "priority_update",
                        "value": "INFO"
                    },
                    {
                        "name": "priority_warning",
                        "value": "INFO"
                    },
                    {
                        "name": "vops_endpoint",
                        "value": "<PLACE ENDPOINT URL HERE>"
                    },
                    {
                        "name": "vops_routing_key",
                        "value": "{ALERT.SENDTO}"
                    }
                ],
                "status": "DISABLED",
                "script": "var VictorOps = {\n    params: {},\n\n    setParams: function (params) {\n        if (typeof params !== 'object') {\n            return;\n        }\n\n        VictorOps.params = params;\n        if (VictorOps.params.endpoint) {\n            if (!VictorOps.params.endpoint.endsWith('/')) {\n                VictorOps.params.endpoint += '/';\n            }\n\n            if (typeof VictorOps.params.routing_key !== 'undefined'\n                    && VictorOps.params.routing_key !== '{ALERT.SENDTO}'\n                    && VictorOps.params.routing_key !== 'Default') {\n                VictorOps.params.endpoint += VictorOps.params.routing_key;\n            }\n        }\n    },\n\n    setProxy: function (HTTPProxy) {\n        VictorOps.HTTPProxy = HTTPProxy;\n    },\n\n    addFields: function (fields) {\n        var data = {};\n\n        if (typeof fields === 'object') {\n            Object.keys(fields)\n                .forEach(function(field) {\n                    if (fields[field] === '') {\n                        Zabbix.Log(4, '[ VictorOps Webhook ] Field \"' + field +\n                            '\" can\\'t be empty. The field ignored.');\n                    }\n                    else {\n                        try {\n                            var parts = field.split(':'),\n                                prefix = parts[0].split('_');\n\n                            if (typeof prefix[1] === 'undefined'\n                                    || (prefix[1] === 'p' && params.event_value === '1'\n                                        && (params.event_update_status === '0'\n                                            || params.event_update_status === '{EVENT.UPDATE.STATUS}'))\n                                    || (prefix[1] === 'r' && params.event_value === '0'\n                                        && (params.event_update_status === '0'\n                                            || params.event_update_status === '{EVENT.UPDATE.STATUS}'))\n                                    || (prefix[1] === 'u' && params.event_update_status === '1')) {\n                                data[field.substring(field.indexOf(':') + 1)] = fields[field];\n                            }\n                        }\n                        catch (error) {\n                            Zabbix.Log(4, '[ VictorOps Webhook ] Can\\'t parse field \"' + field +\n                                '\". The field ignored.');\n                        }\n                    }\n                });\n        }\n\n        return data;\n    },\n\n    request: function (data) {\n        if (typeof VictorOps.params !== 'object' || typeof VictorOps.params.endpoint === 'undefined'\n                || VictorOps.params.endpoint === '' ) {\n            throw 'Required parameter is not set: \"vops_endpoint\".';\n        }\n\n        var response,\n            url = VictorOps.params.endpoint,\n            request = new CurlHttpRequest();\n\n        request.AddHeader('Content-Type: application/json');\n\n        if (typeof VictorOps.HTTPProxy !== 'undefined' && VictorOps.HTTPProxy !== '') {\n            request.SetProxy(VictorOps.HTTPProxy);\n        }\n\n        if (typeof data !== 'undefined') {\n            data = JSON.stringify(data);\n        }\n\n        Zabbix.Log(4, '[ VictorOps Webhook ] Sending request: ' + url +\n            ((typeof data === 'string') ? ('\\n' + data) : ''));\n\n        response = request.Post(url, data);\n\n        Zabbix.Log(4, '[ VictorOps Webhook ] Received response with status code ' +\n            request.Status() + '\\n' + response);\n\n        if (response !== null) {\n            try {\n                response = JSON.parse(response);\n            }\n            catch (error) {\n                Zabbix.Log(4, '[ VictorOps Webhook ] Failed to parse response received from VictorOps');\n                response = null;\n            }\n        }\n\n        if (request.Status() < 200 || request.Status() >= 300) {\n            var message = 'Request failed with status code ' + request.Status();\n\n            if (response !== null && typeof response.messages !== 'undefined') {\n                message += ': ' + JSON.stringify(response.messages);\n            }\n\n            throw message + '. Check debug log for more information.';\n        }\n\n        return response;\n    }\n};\n\ntry {\n    var params = JSON.parse(value),\n        fields = {},\n        vops = {},\n        required_params = ['event_source', 'event_value', 'priority_update'],\n        severities = [\n            {name: 'not_classified', color: '#97AAB3'},\n            {name: 'information', color: '#7499FF'},\n            {name: 'warning', color: '#FFC859'},\n            {name: 'average', color: '#FFA059'},\n            {name: 'high', color: '#E97659'},\n            {name: 'disaster', color: '#E45959'},\n            {name: 'resolved', color: '#009900'},\n            {name: 'default', color: '#000000'}\n        ];\n\n    Object.keys(params)\n        .forEach(function (key) {\n            if (key.startsWith('vops_')) {\n                vops[key.substring(5)] = params[key];\n            }\n            else if (key.startsWith('field')) {\n                fields[key.substring(5)] = params[key];\n            }\n            else if (required_params.indexOf(key) !== -1 && params[key] === '') {\n                throw 'Parameter \"' + key + '\" can\\'t be empty.';\n            }\n        });\n\n    if ([0, 1, 2, 3].indexOf(parseInt(params.event_source)) === -1) {\n        throw 'Incorrect \"event_source\" parameter given: ' + params.event_source + '\\nMust be 0-3.';\n    }\n\n    // Check {EVENT.VALUE} for trigger-based and internal events.\n    if (params.event_value !== '0' && params.event_value !== '1'\n            && (params.event_source === '0' || params.event_source === '3')) {\n        throw 'Incorrect \"event_value\" parameter given: ' + params.event_value + '\\nMust be 0 or 1.';\n    }\n\n    // Check {EVENT.UPDATE.STATUS} only for trigger-based events.\n    if (params.event_update_status !== '0' && params.event_update_status !== '1' && params.event_source === '0') {\n        throw 'Incorrect \"event_update_status\" parameter given: ' + params.event_update_status + '\\nMust be 0 or 1.';\n    }\n\n    if ([0, 1, 2, 3, 4, 5].indexOf(parseInt(params.event_nseverity)) === -1) {\n        params.event_nseverity = '7';\n    }\n\n    if (params.event_value === '0') {\n        params.event_nseverity = '6';\n    }\n\n    if (params.event_update_status === '1') {\n        fields[':message_type'] = params.priority_update;\n    }\n    else {\n        fields[':message_type'] = params['priority_' + severities[params.event_nseverity].name]\n            || 'INFO';\n    }\n\n    if (params.event_info && params.event_source === '0') {\n        fields[':event_info'] = params.event_info;\n    }\n\n    VictorOps.setParams(vops);\n    VictorOps.setProxy(params.HTTPProxy);\n    VictorOps.request(VictorOps.addFields(fields));\n\n    return 'OK';\n}\ncatch (error) {\n    Zabbix.Log(3, '[ VictorOps Webhook ] ERROR: ' + error);\n    throw 'Sending failed: ' + error;\n}",
                "message_templates": [
                    {
                        "event_source": "TRIGGERS",
                        "operation_mode": "PROBLEM",
                        "subject": "Problem: {EVENT.NAME}",
                        "message": "Problem started at {EVENT.TIME} on {EVENT.DATE}\nProblem name: {EVENT.NAME}\nHost: {HOST.NAME}\nSeverity: {EVENT.SEVERITY}\nOperational data: {EVENT.OPDATA}\nOriginal problem ID: {EVENT.ID}\n{TRIGGER.URL}"
                    },
                    {
                        "event_source": "TRIGGERS",
                        "operation_mode": "RECOVERY",
                        "subject": "Resolved in {EVENT.DURATION}: {EVENT.NAME}",
                        "message": "Problem has been resolved at {EVENT.RECOVERY.TIME} on {EVENT.RECOVERY.DATE}\nProblem name: {EVENT.NAME}\nProblem duration: {EVENT.DURATION}\nHost: {HOST.NAME}\nSeverity: {EVENT.SEVERITY}\nOriginal problem ID: {EVENT.ID}\n{TRIGGER.URL}"
                    },
                    {
                        "event_source": "TRIGGERS",
                        "operation_mode": "UPDATE",
                        "subject": "[{EVENT.STATUS}] {EVENT.NAME}",
                        "message": "{USER.FULLNAME} {EVENT.UPDATE.ACTION} problem at {EVENT.UPDATE.DATE} {EVENT.UPDATE.TIME}.\n{EVENT.UPDATE.MESSAGE}\n\nCurrent problem status is {EVENT.STATUS}, acknowledged: {EVENT.ACK.STATUS}."
                    },
                    {
                        "event_source": "DISCOVERY",
                        "operation_mode": "PROBLEM",
                        "subject": "Discovery: {DISCOVERY.DEVICE.STATUS} {DISCOVERY.DEVICE.IPADDRESS}",
                        "message": "Discovery rule: {DISCOVERY.RULE.NAME}\n\nDevice IP: {DISCOVERY.DEVICE.IPADDRESS}\nDevice DNS: {DISCOVERY.DEVICE.DNS}\nDevice status: {DISCOVERY.DEVICE.STATUS}\nDevice uptime: {DISCOVERY.DEVICE.UPTIME}\n\nDevice service name: {DISCOVERY.SERVICE.NAME}\nDevice service port: {DISCOVERY.SERVICE.PORT}\nDevice service status: {DISCOVERY.SERVICE.STATUS}\nDevice service uptime: {DISCOVERY.SERVICE.UPTIME}"
                    },
                    {
                        "event_source": "AUTOREGISTRATION",
                        "operation_mode": "PROBLEM",
                        "subject": "Autoregistration: {HOST.HOST}",
                        "message": "Host name: {HOST.HOST}\nHost IP: {HOST.IP}\nAgent port: {HOST.PORT}"
                    }
                ]
            },
            {
                "name": "Zammad",
                "type": "WEBHOOK",
                "parameters": [
                    {
                        "name": "alert_message",
                        "value": "{ALERT.MESSAGE}"
                    },
                    {
                        "name": "alert_subject",
                        "value": "{ALERT.SUBJECT}"
                    },
                    {
                        "name": "event_id",
                        "value": "{EVENT.ID}"
                    },
                    {
                        "name": "event_nseverity",
                        "value": "{EVENT.NSEVERITY}"
                    },
                    {
                        "name": "event_source",
                        "value": "{EVENT.SOURCE}"
                    },
                    {
                        "name": "event_tags",
                        "value": "{EVENT.TAGSJSON}"
                    },
                    {
                        "name": "event_update_message",
                        "value": "{EVENT.UPDATE.MESSAGE}"
                    },
                    {
                        "name": "event_update_status",
                        "value": "{EVENT.UPDATE.STATUS}"
                    },
                    {
                        "name": "event_value",
                        "value": "{EVENT.VALUE}"
                    },
                    {
                        "name": "trigger_id",
                        "value": "{TRIGGER.ID}"
                    },
                    {
                        "name": "zabbix_url",
                        "value": "{$ZABBIX.URL}"
                    },
                    {
                        "name": "zammad_access_token",
                        "value": "<PUT YOUR ACCESS TOKEN>"
                    },
                    {
                        "name": "zammad_customer",
                        "value": "<PUT YOUR CUSTOMER EMAIL>"
                    },
                    {
                        "name": "zammad_enable_tags",
                        "value": "true"
                    },
                    {
                        "name": "zammad_ticket_id",
                        "value": "{EVENT.TAGS.__zbx_zammad_ticket_id}"
                    },
                    {
                        "name": "zammad_url",
                        "value": "<PUT YOUR ZAMMAD URL>"
                    }
                ],
                "status": "DISABLED",
                "script": "var Zammad = {\n    params: {},\n\n    setParams: function (params) {\n        if (typeof params !== 'object') {\n            return;\n        }\n\n        Zammad.params = params;\n        if (typeof Zammad.params.url === 'string') {\n            if (!Zammad.params.url.endsWith('/')) {\n                Zammad.params.url += '/';\n            }\n        }\n    },\n\n    request: function (method, query, data) {\n        ['url', 'access_token'].forEach(function (field) {\n            if (typeof Zammad.params !== 'object' || typeof Zammad.params[field] === 'undefined'\n                || Zammad.params[field] === '' ) {\n                throw 'Required param is not set: \"' + field + '\".';\n            }\n        });\n\n        var response,\n            url = Zammad.params.url + query,\n            request = new CurlHttpRequest();\n\n        if (typeof Zammad.HTTPProxy === 'string' && Zammad.HTTPProxy.trim() !== '') {\n            request.SetProxy(Zammad.HTTPProxy);\n        }\n\n        request.AddHeader('Content-Type: application/json');\n        request.AddHeader('Authorization: Token token=' + Zammad.params.access_token);\n\n        if (typeof data !== 'undefined') {\n            data = JSON.stringify(data);\n        }\n\n        Zabbix.Log(4, '[ Zammad Webhook ] Sending request: ' +\n            url + ((typeof data === 'string') ? (' ' + data) : ''));\n\n        switch (method) {\n            case 'get':\n                response = request.Get(url, data);\n                break;\n\n            case 'post':\n                response = request.Post(url, data);\n                break;\n\n            case 'put':\n                response = request.Put(url, data);\n                break;\n\n            default:\n                throw 'Unsupported HTTP request method: ' + method;\n        }\n\n        Zabbix.Log(4, '[ Zammad Webhook ] Received response with status code ' + request.Status() + ': ' + response);\n\n        if (response !== null) {\n            try {\n                response = JSON.parse(response);\n            }\n            catch (error) {\n                Zabbix.Log(4, '[ Zammad Webhook ] Failed to parse response received from Zammad');\n                response = null;\n            }\n        }\n\n        if (request.Status() < 200 || request.Status() >= 300) {\n            var message = 'Request failed with status code ' + request.Status();\n\n            if (response !== null && typeof response.errors !== 'undefined'\n                && Object.keys(response.errors).length > 0) {\n                message += ': ' + JSON.stringify(response.errors);\n            }\n            else if (response !== null && typeof response.errorMessages !== 'undefined'\n                && Object.keys(response.errorMessages).length > 0) {\n                message += ': ' + JSON.stringify(response.errorMessages);\n            }\n\n            throw message + ' Check debug log for more information.';\n        }\n\n        return {\n            status: request.Status(),\n            response: response\n        };\n    },\n\n    setTicketTags: function(tags, ticket_id) {\n        try {\n            var tags_json = JSON.parse(tags),\n                result;\n\n            for (var i in tags_json) {\n                result = Zammad.request('get',\n                    '/api/v1/tags/add?object=Ticket&o_id=' + ticket_id +\n                    '&item=' + tags_json[i].tag);\n\n                if (typeof result.response !== 'object'\n                    || result.status != 200) {\n                    Zabbix.Log(4, '[ Zammad Webhook ] Cannot add ticket tag:' + tags_json[i].tag);\n                }\n            }\n        }\n        catch (error) {\n            Zabbix.Log(4, '[ Zammad Webhook ] Failed to add ticket tags:' + error);\n        }\n\n        return;\n    },\n\n    createTicket: function(subject, message, priority) {\n        var data = {\n                title: subject,\n                group: 'Users',\n                article: {\n                    subject: subject,\n                    body: message,\n                    type: 'note',\n                    internal: false\n                },\n                customer: Zammad.params.customer\n            },\n            result;\n\n        if (priority) {\n            data.priority_id = priority;\n        }\n\n        result = Zammad.request('post', 'api/v1/tickets', data);\n\n        if (typeof result.response !== 'object'\n            || typeof result.response.id === 'undefined'\n            || result.status != 201) {\n            throw 'Cannot create Zammad ticket. Check debug log for more information.';\n        }\n\n        return result.response.id;\n    },\n\n    updateTicket: function(subject, message) {\n        var data = {\n            ticket_id: Zammad.params.ticket_id,\n            subject: subject,\n            body: message || '',\n            type: 'note',\n            internal: false\n        };\n\n        result = Zammad.request('post', 'api/v1/ticket_articles', data);\n\n        if (typeof result.response !== 'object'\n            || typeof result.response.id === 'undefined'\n            || result.status != 201) {\n            throw 'Cannot update Zammad ticket. Check debug log for more information.';\n        }\n    }\n};\n\ntry {\n    var params = JSON.parse(value),\n        params_zammad = {},\n        params_update = {},\n        result = {tags: {}},\n        required_params = [\n            'alert_subject', 'customer',\n            'event_source', 'event_value',\n            'event_update_status'\n        ],\n        severities = [\n            {name: 'not_classified', color: '#97AAB3'},\n            {name: 'information', color: '#7499FF'},\n            {name: 'warning', color: '#FFC859'},\n            {name: 'average', color: '#FFA059'},\n            {name: 'high', color: '#E97659'},\n            {name: 'disaster', color: '#E45959'},\n            {name: 'resolved', color: '#009900'},\n            {name: null, color: '#000000'}\n        ],\n        priority;\n\n    Object.keys(params)\n        .forEach(function (key) {\n            if (key.startsWith('zammad_')) {\n                params_zammad[key.substring(7)] = params[key].trim();\n            }\n            else if (key.startsWith('event_update_')) {\n                params_update[key.substring(13)] = params[key];\n            }\n            else if (required_params.indexOf(key) !== -1 && params[key].trim() === '') {\n                throw 'Parameter \"' + key + '\" cannot be empty.';\n            }\n        });\n\n    if ([0, 1, 2, 3].indexOf(parseInt(params.event_source)) === -1) {\n        throw 'Incorrect \"event_source\" parameter given: ' + params.event_source + '\\nMust be 0-3.';\n    }\n\n    // Check {EVENT.VALUE} for trigger-based and internal events.\n    if (params.event_value !== '0' && params.event_value !== '1'\n        && (params.event_source === '0' || params.event_source === '3')) {\n        throw 'Incorrect \"event_value\" parameter given: ' + params.event_value + '\\nMust be 0 or 1.';\n    }\n\n    // Check {EVENT.UPDATE.STATUS} only for trigger-based events.\n    if (params.event_source === '0' && params.event_update_status !== '0' && params.event_update_status !== '1') {\n        throw 'Incorrect \"event_update_status\" parameter given: ' + params.event_update_status + '\\nMust be 0 or 1.';\n    }\n\n    if (params.event_source !== '0' && params.event_value === '0') {\n        throw 'Recovery operations are supported only for trigger-based actions.';\n    }\n\n    if (params.event_source === '0'\n        && ((params.event_value === '1' && params.event_update_status === '1')\n            || (params.event_value === '0'\n                && (params.event_update_status === '0' || params.event_update_status === '1')))\n        && (isNaN(parseInt(params.zammad_ticket_id)) || parseInt(params.zammad_ticket_id) < 1 )) {\n        throw 'Incorrect \"zammad_ticket_id\" parameter given: ' + params.zammad_ticket_id +\n            '\\nMust be positive integer.';\n    }\n\n    if ([0, 1, 2, 3, 4, 5].indexOf(parseInt(params.event_nseverity)) === -1) {\n        params.event_nseverity = '7';\n    }\n\n    if (params.event_value === '0') {\n        params.event_nseverity = '6';\n    }\n\n    priority = params['severity_' + severities[params.event_nseverity].name];\n    priority = priority && priority.trim() || severities[7].name;\n\n    Zammad.setParams(params_zammad);\n    Zammad.HTTPProxy = params.HTTPProxy;\n\n    // Create ticket for non trigger-based events.\n    if (params.event_source !== '0'\n        && params.event_value !== '0') {\n        Zammad.createTicket(params.alert_subject, params.alert_message, priority, params.event_tags);\n    }\n    // Create ticket for trigger-based events.\n    else if (params.event_value === '1' && params_update.status === '0') {\n        var ticket_id = Zammad.createTicket(params.alert_subject,\n            params.alert_subject + '\\n' + params.alert_message + '\\n' +\n            params.zabbix_url + (params.zabbix_url.endsWith('/') ? '' : '/') +\n            'tr_events.php?triggerid=' + params.trigger_id + '&eventid=' + params.event_id + '\\n',\n            priority);\n\n        result.tags.__zbx_zammad_ticket_id = ticket_id;\n        result.tags.__zbx_zammad_ticketlink = params.zammad_url +\n            (params.zammad_url.endsWith('/') ? '' : '/') + '#ticket/zoom/' + ticket_id;\n\n        if (Zammad.params.enable_tags.toLowerCase() === 'true') {\n            Zammad.setTicketTags(params.event_tags, ticket_id);\n        }\n    }\n    // Update created ticket for trigger-based event.\n    else {\n        Zammad.updateTicket(params.alert_subject, params.alert_message);\n    }\n\n    return JSON.stringify(result);\n}\ncatch (error) {\n    Zabbix.Log(3, '[ Zammad Webhook ] ERROR: ' + error);\n    throw 'Sending failed: ' + error;\n}",
                "process_tags": "YES",
                "show_event_menu": "YES",
                "event_menu_url": "{EVENT.TAGS.__zbx_zammad_ticketlink}",
                "event_menu_name": "Zammad: ticket #{EVENT.TAGS.__zbx_zammad_ticket_id}",
                "message_templates": [
                    {
                        "event_source": "TRIGGERS",
                        "operation_mode": "PROBLEM",
                        "subject": "Problem: {EVENT.NAME}",
                        "message": "Problem started at {EVENT.TIME} on {EVENT.DATE}\nProblem name: {EVENT.NAME}\nHost: {HOST.NAME}\nSeverity: {EVENT.SEVERITY}\nOperational data: {EVENT.OPDATA}\nOriginal problem ID: {EVENT.ID}\n{TRIGGER.URL}"
                    },
                    {
                        "event_source": "TRIGGERS",
                        "operation_mode": "RECOVERY",
                        "subject": "Resolved: {EVENT.NAME}",
                        "message": "Problem has been resolved in {EVENT.DURATION} at {EVENT.RECOVERY.TIME} on {EVENT.RECOVERY.DATE}\nProblem name: {EVENT.NAME}\nHost: {HOST.NAME}\nSeverity: {EVENT.SEVERITY}\nOriginal problem ID: {EVENT.ID}\n{TRIGGER.URL}"
                    },
                    {
                        "event_source": "TRIGGERS",
                        "operation_mode": "UPDATE",
                        "subject": "Updated problem: {EVENT.NAME}",
                        "message": "{USER.FULLNAME} {EVENT.UPDATE.ACTION} problem at {EVENT.UPDATE.DATE} {EVENT.UPDATE.TIME}.\n{EVENT.UPDATE.MESSAGE}\n\nCurrent problem status is {EVENT.STATUS}, acknowledged: {EVENT.ACK.STATUS}."
                    },
                    {
                        "event_source": "DISCOVERY",
                        "operation_mode": "PROBLEM",
                        "subject": "Discovery: {DISCOVERY.DEVICE.STATUS} {DISCOVERY.DEVICE.IPADDRESS}",
                        "message": "Discovery rule: {DISCOVERY.RULE.NAME}\n\nDevice IP: {DISCOVERY.DEVICE.IPADDRESS}\nDevice DNS: {DISCOVERY.DEVICE.DNS}\nDevice status: {DISCOVERY.DEVICE.STATUS}\nDevice uptime: {DISCOVERY.DEVICE.UPTIME}\n\nDevice service name: {DISCOVERY.SERVICE.NAME}\nDevice service port: {DISCOVERY.SERVICE.PORT}\nDevice service status: {DISCOVERY.SERVICE.STATUS}\nDevice service uptime: {DISCOVERY.SERVICE.UPTIME}"
                    },
                    {
                        "event_source": "AUTOREGISTRATION",
                        "operation_mode": "PROBLEM",
                        "subject": "Autoregistration: {HOST.HOST}",
                        "message": "Host name: {HOST.HOST}\nHost IP: {HOST.IP}\nAgent port: {HOST.PORT}"
                    }
                ]
            },
            {
                "name": "Zendesk",
                "type": "WEBHOOK",
                "parameters": {
                    "1": {
                        "name": "alert_message",
                        "value": "{ALERT.MESSAGE}"
                    },
                    "2": {
                        "name": "alert_subject",
                        "value": "{ALERT.SUBJECT}"
                    },
                    "3": {
                        "name": "event_id",
                        "value": "{EVENT.ID}"
                    },
                    "4": {
                        "name": "event_nseverity",
                        "value": "{EVENT.NSEVERITY}"
                    },
                    "5": {
                        "name": "event_source",
                        "value": "{EVENT.SOURCE}"
                    },
                    "6": {
                        "name": "event_tags",
                        "value": "{EVENT.TAGS}"
                    },
                    "7": {
                        "name": "event_update_status",
                        "value": "{EVENT.UPDATE.STATUS}"
                    },
                    "8": {
                        "name": "event_value",
                        "value": "{EVENT.VALUE}"
                    },
                    "9": {
                        "name": "severity_average",
                        "value": "normal"
                    },
                    "10": {
                        "name": "severity_default",
                        "value": "-"
                    },
                    "11": {
                        "name": "severity_disaster",
                        "value": "urgent"
                    },
                    "12": {
                        "name": "severity_high",
                        "value": "high"
                    },
                    "13": {
                        "name": "severity_information",
                        "value": "low"
                    },
                    "14": {
                        "name": "severity_not_classified",
                        "value": "low"
                    },
                    "0": {
                        "name": "severity_warning",
                        "value": "normal"
                    },
                    "15": {
                        "name": "trigger_id",
                        "value": "{TRIGGER.ID}"
                    },
                    "16": {
                        "name": "zbxurl",
                        "value": "{$ZABBIX.URL}"
                    },
                    "17": {
                        "name": "zendesk_issue_key",
                        "value": "{EVENT.TAGS.__zbx_zdk_issuekey}"
                    },
                    "18": {
                        "name": "zendesk_token",
                        "value": "<put your {enduser_email_address}/token:{api_token}>"
                    },
                    "19": {
                        "name": "zendesk_type",
                        "value": "incident"
                    },
                    "20": {
                        "name": "zendesk_url",
                        "value": "<put your Zendesk URL>"
                    }
                },
                "status": "DISABLED",
                "script": "var Zendesk = {\n    params: {},\n\n    setParams: function (params) {\n        if (typeof params !== 'object') {\n            return;\n        }\n\n        Zendesk.params = params;\n        if (typeof Zendesk.params.url === 'string') {\n            if (!Zendesk.params.url.endsWith('/')) {\n                Zendesk.params.url += '/';\n            }\n            Zendesk.params.url += 'api/v2/';\n        }\n    },\n\n    addCustomFields: function (data, fields) {\n        if (typeof fields === 'object' && Object.keys(fields).length) {\n            var schema = Zendesk.getSchema(),\n                arr = [],\n                i,\n                n;\n\n            if (schema) {\n                Object.keys(fields)\n                    .forEach(function(field) {\n                        for (i = 0, n = schema.ticket_fields.length; i < n; i++) {\n                            if (schema.ticket_fields[i].id == field\n                                && ['text', 'integer', 'date'].indexOf(schema.ticket_fields[i].type) !== -1){\n\n                                switch (schema.ticket_fields[i].type) {\n                                    case 'integer':\n                                        fields[field] = parseInt(fields[field]);\n                                        break;\n                                    case 'date':\n                                        if (fields[field].match(/^\\d{4}[.-]\\d{2}[.-]\\d{2}$/) !== null) {\n                                            fields[field] = fields[field].replace(/\\./g, '-');\n                                        }\n                                        else {\n                                            fields[field] = '';\n                                        }\n                                        break;\n                                }\n\n                                arr.push({id: field, value: fields[field]});\n                                break;\n                            }\n                        }\n                    });\n\n                if (arr.length) {\n                    data.ticket['custom_fields'] = arr;\n                }\n            }\n            else {\n                Zabbix.Log(4, '[Zendesk Webhook] Failed to retrieve field schema.');\n            }\n        }\n\n        return data;\n    },\n\n    request: function (method, query, data) {\n        ['url', 'token', 'type'].forEach(function (field) {\n            if (typeof Zendesk.params !== 'object' || typeof Zendesk.params[field] === 'undefined') {\n                throw 'Required Zendesk param is not set: ' + field + '\\n' + Zendesk.params[field];\n            }\n        });\n\n        var response,\n            url = Zendesk.params.url + query,\n            request = new CurlHttpRequest();\n\n        if (typeof Zendesk.HTTPProxy === 'string' && Zendesk.HTTPProxy.trim() !== '') {\n            request.SetProxy(Zendesk.HTTPProxy);\n        }\n\n        request.AddHeader('Content-Type: application/json');\n        request.AddHeader('Authorization: Basic ' + btoa(Zendesk.params.token));\n\n        if (typeof data !== 'undefined') {\n            data = JSON.stringify(data);\n        }\n\n        Zabbix.Log(4, '[Zendesk Webhook] Sending request: ' + url + ((typeof data === 'string') ? (' ' + data) : ''));\n\n        switch (method) {\n            case 'get':\n                response = request.Get(url, data);\n                break;\n\n            case 'post':\n                response = request.Post(url, data);\n                break;\n\n            case 'put':\n                response = request.Put(url, data);\n                break;\n\n            default:\n                throw 'Unsupported HTTP request method: ' + method;\n        }\n\n        Zabbix.Log(4, '[Zendesk Webhook] Received response with status code ' + request.Status() + '. ' + response);\n\n        if (response !== null) {\n            try {\n                response = JSON.parse(response);\n            }\n            catch (error) {\n                Zabbix.Log(4, '[Zendesk Webhook] Failed to parse response received from Zendesk.');\n            }\n        }\n\n        if (request.Status() < 200 || request.Status() >= 300) {\n            var message = 'Request failed with status code ' + request.Status();\n\n            if (response !== null && typeof response.error !== 'undefined'\n                && Object.keys(response.error).length > 0) {\n                message += ': ' + JSON.stringify(response.error);\n            }\n            else if (response !== null && typeof response.description !== 'undefined'\n                && Object.keys(response.description).length > 0) {\n                message += ': ' + JSON.stringify(response.description);\n            }\n            else {\n                message += '. ' + response;\n            }\n            throw message + '. Check debug log for more information.';\n        }\n\n        return {\n            status: request.Status(),\n            response: response\n        };\n    },\n\n    getSchema: function() {\n        var result = Zendesk.request('get', 'ticket_fields.json');\n\n        return result.response;\n    },\n\n    createIssue: function(data, fields) {\n        var result = Zendesk.request('post', 'tickets.json', Zendesk.addCustomFields(data, fields));\n\n        if (typeof result.response !== 'object' || typeof result.response.ticket.id === 'undefined'\n            || result.status != 201) {\n            throw 'Cannot create Zendesk issue. Check debug log for more information.';\n        }\n\n        return result.response.ticket.id;\n    },\n\n    updateIssue: function(data, fields) {\n        Zendesk.request('put', 'tickets/' + Zendesk.params.issue_key + '.json', Zendesk.addCustomFields(data, fields));\n    }\n};\n\ntry {\n    var params = JSON.parse(value),\n        fields = {},\n        zendesk = {},\n        update = {},\n        data = {},\n        result = {tags: {}},\n        required_params = [\n            'alert_subject',\n            'alert_message',\n            'event_id',\n            'event_source',\n            'event_value',\n            'event_update_status'\n        ],\n        severities = [\n            {name: 'not_classified', color: '#97AAB3'},\n            {name: 'information', color: '#7499FF'},\n            {name: 'warning', color: '#FFC859'},\n            {name: 'average', color: '#FFA059'},\n            {name: 'high', color: '#E97659'},\n            {name: 'disaster', color: '#E45959'},\n            {name: 'resolved', color: '#009900'},\n            {name: 'default', color: '#000000'}\n        ],\n        priority;\n\n    Object.keys(params)\n        .forEach(function (key) {\n            if (key.startsWith('zendesk_')) {\n                zendesk[key.substring(8)] = params[key];\n            }\n            else if (key.startsWith('customfield_')) {\n                fields[key.substring(12)] = params[key];\n            }\n            else if (key.startsWith('event_update_')) {\n                update[key.substring(13)] = params[key];\n            }\n            else if (required_params.indexOf(key) !== -1 && params[key].trim() === '') {\n                throw 'Parameter ' + key + ' cannot be empty.';\n            }\n        });\n\n    // Possible values: question, incident, problems, task\n    if (['question', 'incident', 'problem', 'task'].indexOf(params.zendesk_type) === -1) {\n        throw 'Incorrect \"zendesk_type\" parameter given: ' + params.zendesk_type +\n            '\\nMust be one of question, incident, problem, task.';\n    }\n\n    // Possible values: 0 - Trigger, 1 - Discovery, 2 - Autoregistration, 3 - Internal.\n    if ([0, 1, 2, 3].indexOf(parseInt(params.event_source)) === -1) {\n        throw 'Incorrect \"event_source\" parameter given: ' + params.event_source + '\\nMust be 0-3.';\n    }\n\n    // Check {EVENT.VALUE} for trigger-based and internal events.\n    // Possible values: 1 for problem, 0 for recovering\n    if (params.event_value !== '0' && params.event_value !== '1'\n        && (params.event_source === '0' || params.event_source === '3')) {\n        throw 'Incorrect \"event_value\" parameter given: ' + params.event_value + '\\nMust be 0 or 1.';\n    }\n\n    // Check {EVENT.UPDATE.STATUS} only for trigger-based events.\n    // Possible values: 0 - Webhook was called because of problem/recovery event, 1 - Update operation.\n    if (params.event_source === '0' && params.event_update_status !== '0' && params.event_update_status !== '1') {\n        throw 'Incorrect \"event_update_status\" parameter given: ' + params.event_update_status + '\\nMust be 0 or 1.';\n    }\n\n    if (params.event_source !== '0' && params.event_value === '0') {\n        throw 'Recovery operations are supported only for trigger-based actions.';\n    }\n\n    // Zendesk_issue_key must be a positive integer if an update action is being performed.\n    if (params.event_source === '0' && ((params.event_value === '1' && params.event_update_status === '1')\n        || (params.event_value === '0' && (params.event_update_status === '0' || params.event_update_status === '1')))\n        && (isNaN(parseInt(params.zendesk_issue_key)) || parseInt(params.zendesk_issue_key) < 1 )) {\n        throw 'Incorrect \"zendesk_issue_key\" parameter given: ' + params.zendesk_issue_key +\n            '\\nMust be positive integer.';\n    }\n\n    if ([0, 1, 2, 3, 4, 5].indexOf(parseInt(params.event_nseverity)) === -1) {\n        params.event_nseverity = '7';\n    }\n\n    if (params.event_value === '0') {\n        params.event_nseverity = '6';\n    }\n\n    priority = params['severity_' + severities[params.event_nseverity].name] || severities[7].name;\n\n    Zendesk.setParams(zendesk);\n    Zendesk.HTTPProxy = params.HTTPProxy;\n\n    // Create issue for non trigger-based events.\n    if (params.event_source !== '0' && params.event_value !== '0') {\n        data = {\n            ticket: {\n                external_id: params.event_id,\n                type: Zendesk.params.type,\n                status: 'new',\n                subject: params.alert_subject,\n                comment: {\n                    body: params.alert_message,\n                    public: 'false'\n                },\n                priority: priority,\n                tags: params.event_tags\n            }\n        };\n\n        Zendesk.createIssue(data, fields);\n    }\n    // Create issue for trigger-based events.\n    else if (params.event_value === '1' && update.status === '0') {\n        data = {\n            ticket: {\n                external_id: params.event_id,\n                type: Zendesk.params.type,\n                status: 'new',\n                subject: params.alert_subject,\n                comment: {\n                    body: params.zbxurl + (params.zbxurl.endsWith('/') ? '' : '/') + 'tr_events.php?triggerid=' +\n                        params.trigger_id + '&eventid=' + params.event_id + '\\n' + params.alert_message,\n                    public: 'false'\n                },\n                priority: priority,\n                tags: params.event_tags\n            }\n        };\n        var key = Zendesk.createIssue(data, fields);\n\n        result.tags.__zbx_zdk_issuekey = key;\n        result.tags.__zbx_zdk_issuelink = params.zendesk_url +\n            (params.zendesk_url.endsWith('/') ? '' : '/') + 'agent/tickets/' + key;\n    }\n    // Update created issue for trigger-based event.\n    else {\n        data = {\n            ticket: {\n                type: Zendesk.params.type,\n                subject: params.alert_subject,\n                comment: {\n                    body: params.alert_message,\n                    public: 'false'\n                }\n            }\n        };\n\n        Zendesk.updateIssue(data, fields);\n    }\n\n    return JSON.stringify(result);\n}\ncatch (error) {\n    Zabbix.Log(3, '[Zendesk Webhook] ERROR: ' + error);\n    throw 'Sending failed: ' + error;\n}",
                "process_tags": "YES",
                "show_event_menu": "YES",
                "event_menu_url": "{EVENT.TAGS.__zbx_zdk_issuelink}",
                "event_menu_name": "Zendesk: {EVENT.TAGS.__zbx_zdk_issuekey}",
                "message_templates": [
                    {
                        "event_source": "TRIGGERS",
                        "operation_mode": "PROBLEM",
                        "subject": "{EVENT.NAME}",
                        "message": "Problem started at {EVENT.TIME} on {EVENT.DATE}\nProblem name: {EVENT.NAME}\nHost: {HOST.NAME}\nSeverity: {EVENT.SEVERITY}\nOperational data: {EVENT.OPDATA}\nOriginal problem ID: {EVENT.ID}\n{TRIGGER.URL}"
                    },
                    {
                        "event_source": "TRIGGERS",
                        "operation_mode": "RECOVERY",
                        "subject": "{EVENT.NAME}",
                        "message": "Problem has been resolved in {EVENT.DURATION} at {EVENT.RECOVERY.TIME} on {EVENT.RECOVERY.DATE}\nProblem name: {EVENT.NAME}\nHost: {HOST.NAME}\nSeverity: {EVENT.SEVERITY}\nOperational data: {EVENT.OPDATA}\nOriginal problem ID: {EVENT.ID}\n{TRIGGER.URL}"
                    },
                    {
                        "event_source": "TRIGGERS",
                        "operation_mode": "UPDATE",
                        "subject": "{EVENT.NAME}",
                        "message": "{USER.FULLNAME} {EVENT.UPDATE.ACTION} problem at {EVENT.UPDATE.DATE} {EVENT.UPDATE.TIME}.\n{EVENT.UPDATE.MESSAGE}\n\nCurrent problem status is {EVENT.STATUS}, acknowledged: {EVENT.ACK.STATUS}."
                    },
                    {
                        "event_source": "DISCOVERY",
                        "operation_mode": "PROBLEM",
                        "subject": "Discovery: {DISCOVERY.DEVICE.STATUS} {DISCOVERY.DEVICE.IPADDRESS}",
                        "message": "Discovery rule: {DISCOVERY.RULE.NAME}\n\nDevice IP: {DISCOVERY.DEVICE.IPADDRESS}\nDevice DNS: {DISCOVERY.DEVICE.DNS}\nDevice status: {DISCOVERY.DEVICE.STATUS}\nDevice uptime: {DISCOVERY.DEVICE.UPTIME}\n\nDevice service name: {DISCOVERY.SERVICE.NAME}\nDevice service port: {DISCOVERY.SERVICE.PORT}\nDevice service status: {DISCOVERY.SERVICE.STATUS}\nDevice service uptime: {DISCOVERY.SERVICE.UPTIME}"
                    },
                    {
                        "event_source": "AUTOREGISTRATION",
                        "operation_mode": "PROBLEM",
                        "subject": "Autoregistration: {HOST.HOST}",
                        "message": "Host name: {HOST.HOST}\nHost IP: {HOST.IP}\nAgent port: {HOST.PORT}"
                    },
                    {
                        "event_source": "INTERNAL",
                        "operation_mode": "PROBLEM",
                        "subject": "Internal problem: {EVENT.NAME}",
                        "message": "Internal problem started at {EVENT.TIME} on {EVENT.DATE}\nProblem name: {EVENT.NAME}\nHost: {HOST.NAME}\nOperational data: {EVENT.OPDATA}\nOriginal problem ID: {EVENT.ID}"
                    }
                ]
            }
        ]
    }
}